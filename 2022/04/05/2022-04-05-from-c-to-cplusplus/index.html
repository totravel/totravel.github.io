<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"totravel.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.13.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="本文可以帮助熟悉 C 语言并且已经了解面向对象程序设计思想的读者快速认识 C++ 这门语言。">
<meta property="og:type" content="article">
<meta property="og:title" content="从 C 语言到 C++">
<meta property="og:url" content="https://totravel.github.io/2022/04/05/2022-04-05-from-c-to-cplusplus/">
<meta property="og:site_name" content="旅行 · 之间">
<meta property="og:description" content="本文可以帮助熟悉 C 语言并且已经了解面向对象程序设计思想的读者快速认识 C++ 这门语言。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-04-05T11:52:45.000Z">
<meta property="article:modified_time" content="2022-11-22T17:02:36.647Z">
<meta property="article:author" content="totravel">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="面向对象">
<meta property="article:tag" content="重载">
<meta property="article:tag" content="友元函数">
<meta property="article:tag" content="虚函数">
<meta property="article:tag" content="泛型编程">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://totravel.github.io/2022/04/05/2022-04-05-from-c-to-cplusplus/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":"","permalink":"https://totravel.github.io/2022/04/05/2022-04-05-from-c-to-cplusplus/","path":"2022/04/05/2022-04-05-from-c-to-cplusplus/","title":"从 C 语言到 C++"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>从 C 语言到 C++ | 旅行 · 之间</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">旅行 · 之间</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">总是跌跌撞撞，到底是顺其自然还是无头苍蝇？傻傻分不清……</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">47</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">2</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">19</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">面向过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-number">1.1.</span> <span class="nav-text">标准输入输出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-number">1.1.1.</span> <span class="nav-text">头文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">1.1.2.</span> <span class="nav-text">命名空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-number">1.1.3.</span> <span class="nav-text">标准输入输出流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">标准输出流</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E6%B5%81"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">标准输入流</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%A7%8B%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.1.4.</span> <span class="nav-text">原始字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%BD%E5%AD%97%E7%AC%A6%E5%9E%8B"><span class="nav-number">1.1.5.</span> <span class="nav-text">宽字符型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="nav-number">1.1.6.</span> <span class="nav-text">格式化输出</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">1.2.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.2.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-number">1.2.2.</span> <span class="nav-text">常量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">空指针常量</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-number">1.2.3.</span> <span class="nav-text">引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.</span> <span class="nav-text">类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E6%8E%A8%E6%96%AD%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.1.</span> <span class="nav-text">自动推断类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#string-%E7%B1%BB"><span class="nav-number">1.3.2.</span> <span class="nav-text">string 类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.3.3.</span> <span class="nav-text">强制类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE"><span class="nav-number">1.3.4.</span> <span class="nav-text">枚举</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%BA%E6%9E%9A%E4%B8%BE"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">强枚举</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="nav-number">1.3.5.</span> <span class="nav-text">类型别名</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E5%90%8D"><span class="nav-number">1.4.1.</span> <span class="nav-text">重载函数名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E5%BC%95%E7%94%A8%E8%B0%83%E7%94%A8"><span class="nav-number">1.4.2.</span> <span class="nav-text">传引用调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82"><span class="nav-number">1.4.3.</span> <span class="nav-text">默认实参</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.4.4.</span> <span class="nav-text">lambda 表达式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">1.5.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0%E7%9A%84-for-%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.5.1.</span> <span class="nav-text">新的 for 语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-number">1.5.2.</span> <span class="nav-text">数组作为函数参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88"><span class="nav-number">1.6.</span> <span class="nav-text">指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%9A%84%E5%BC%95%E7%94%A8"><span class="nav-number">1.6.1.</span> <span class="nav-text">指针变量的引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%8F%98%E9%87%8F"><span class="nav-number">1.6.2.</span> <span class="nav-text">动态变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="nav-number">1.6.3.</span> <span class="nav-text">动态数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%AD%E8%A8%80"><span class="nav-number">1.7.</span> <span class="nav-text">断言</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%AD%E8%A8%80"><span class="nav-number">1.7.1.</span> <span class="nav-text">静态断言</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.</span> <span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E3%80%81%E6%96%87%E4%BB%B6-IO"><span class="nav-number">2.1.</span> <span class="nav-text">流、文件 IO</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="nav-number">2.1.1.</span> <span class="nav-text">读取文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="nav-number">2.1.2.</span> <span class="nav-text">写入文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-number">2.1.3.</span> <span class="nav-text">流作为函数参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6-IO"><span class="nav-number">2.1.4.</span> <span class="nav-text">字符 IO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA-1"><span class="nav-number">2.1.5.</span> <span class="nav-text">格式化输出</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%93%8D%E7%BA%B5%E5%85%83"><span class="nav-number">2.1.5.1.</span> <span class="nav-text">操纵元</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86-string-%E7%B1%BB"><span class="nav-number">2.2.</span> <span class="nav-text">标准 string  类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#getline-%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.1.</span> <span class="nav-text">getline() 函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E6%88%90-C-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.2.2.</span> <span class="nav-text">转换成 C 字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90%E6%88%90%E6%95%B0%E5%AD%97"><span class="nav-number">2.2.3.</span> <span class="nav-text">解析成数字</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%91%E9%87%8F"><span class="nav-number">2.3.</span> <span class="nav-text">向量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E7%BB%93%E6%9E%84%E5%88%B0%E7%B1%BB"><span class="nav-number">2.4.</span> <span class="nav-text">从结构到类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">2.4.1.</span> <span class="nav-text">浅拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%AE%9A%E4%B9%89"><span class="nav-number">2.4.2.</span> <span class="nav-text">类定义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.5.</span> <span class="nav-text">构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8C%BA%E5%9F%9F"><span class="nav-number">2.5.1.</span> <span class="nav-text">初始化区域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.5.2.</span> <span class="nav-text">显式调用构造函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E6%96%B9%E6%B3%95%E5%90%8D"><span class="nav-number">2.6.</span> <span class="nav-text">重载方法名</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.6.1.</span> <span class="nav-text">默认构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%A7%94%E6%89%98"><span class="nav-number">2.6.2.</span> <span class="nav-text">构造函数委托</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">2.6.3.</span> <span class="nav-text">继承</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">2.7.</span> <span class="nav-text">析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8-const-%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">2.8.</span> <span class="nav-text">用 const 修饰成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="nav-number">2.9.</span> <span class="nav-text">友元函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.10.</span> <span class="nav-text">重载运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E4%BA%8E%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.10.1.</span> <span class="nav-text">用于自动类型转换的构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E6%8F%92%E5%85%A5%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.10.2.</span> <span class="nav-text">重载插入运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.11.</span> <span class="nav-text">拷贝构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E9%80%94"><span class="nav-number">2.11.1.</span> <span class="nav-text">拷贝构造函数的用途</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.11.2.</span> <span class="nav-text">重载赋值运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E6%96%B9%E6%8B%AC%E5%8F%B7"><span class="nav-number">2.11.3.</span> <span class="nav-text">重载方括号</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-1"><span class="nav-number">2.12.</span> <span class="nav-text">命名空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">2.12.1.</span> <span class="nav-text">创建命名空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%90%E5%AE%9A%E5%90%8D%E7%A7%B0"><span class="nav-number">2.12.2.</span> <span class="nav-text">限定名称</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E5%90%8D%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">2.12.3.</span> <span class="nav-text">无名命名空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%88%AB%E5%90%8D"><span class="nav-number">2.12.4.</span> <span class="nav-text">命名空间别名</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF-1"><span class="nav-number">2.13.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.13.1.</span> <span class="nav-text">基类的构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="nav-number">2.13.2.</span> <span class="nav-text">私有成员的继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%97%E4%BF%9D%E6%8A%A4%E6%88%90%E5%91%98%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="nav-number">2.13.3.</span> <span class="nav-text">受保护成员的继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E4%B9%89%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">2.13.4.</span> <span class="nav-text">重定义成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">2.13.5.</span> <span class="nav-text">不继承的函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E6%80%A7"><span class="nav-number">2.14.</span> <span class="nav-text">多态性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">2.14.1.</span> <span class="nav-text">虚函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E5%AE%9A%E4%B9%89"><span class="nav-number">2.14.2.</span> <span class="nav-text">重写和重定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E8%BD%AC%E6%8D%A2%E6%88%90%E5%9F%BA%E7%B1%BB"><span class="nav-number">2.14.3.</span> <span class="nav-text">派生类转换成基类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">2.14.4.</span> <span class="nav-text">虚析构函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">2.15.</span> <span class="nav-text">异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%92%8C%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="nav-number">2.15.1.</span> <span class="nav-text">抛出异常和捕获异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="nav-number">2.15.2.</span> <span class="nav-text">异常类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA-catch-%E8%AF%AD%E5%8F%A5%E5%9D%97"><span class="nav-number">2.15.3.</span> <span class="nav-text">多个 catch 语句块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#throw-%E5%88%97%E8%A1%A8"><span class="nav-number">2.15.4.</span> <span class="nav-text">throw 列表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">泛型编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF"><span class="nav-number">3.1.</span> <span class="nav-text">模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">3.1.1.</span> <span class="nav-text">函数模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">3.1.2.</span> <span class="nav-text">类模板</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93"><span class="nav-number">3.2.</span> <span class="nav-text">标准模板库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">3.2.1.</span> <span class="nav-text">迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%86%E5%90%91%E9%81%8D%E5%8E%86"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">逆向遍历</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8"><span class="nav-number">3.2.2.</span> <span class="nav-text">容器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">顺序容器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">栈和队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">3.2.2.3.</span> <span class="nav-text">集合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%98%A0%E5%B0%84"><span class="nav-number">3.2.2.4.</span> <span class="nav-text">映射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%81%8D%E5%8E%86"><span class="nav-number">3.2.2.5.</span> <span class="nav-text">容器的初始化和遍历</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%93%E9%A2%98"><span class="nav-number">4.</span> <span class="nav-text">专题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E7%9A%84%E6%95%B0%E7%BB%84"><span class="nav-number">4.1.</span> <span class="nav-text">安全的数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.2.</span> <span class="nav-text">正则表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">4.3.</span> <span class="nav-text">多线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">4.4.</span> <span class="nav-text">智能指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">4.5.</span> <span class="nav-text">文件系统</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="totravel"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">totravel</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/totravel" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;totravel" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:totravel@foxmail.com" title="E-Mail → mailto:totravel@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_nd.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://totravel.github.io/2022/04/05/2022-04-05-from-c-to-cplusplus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="totravel">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="旅行 · 之间">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="从 C 语言到 C++ | 旅行 · 之间">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          从 C 语言到 C++
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-05 19:52:45" itemprop="dateCreated datePublished" datetime="2022-04-05T19:52:45+08:00">2022-04-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-11-23 01:02:36" itemprop="dateModified" datetime="2022-11-23T01:02:36+08:00">2022-11-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h2><h3 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h3><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><p>C 源程序通常用 <code>printf()</code> 函数向标准输出写入数据，用 <code>scanf()</code> 函数从标准输入读取数据，为此要在文件开头用 <code>#include</code> 预处理包含头文件 <code>stdio.h</code>。C++ 源程序同样可以这么做，但 C++ 有自己的一套做法。</p>
<p>C++ 仍然使用 <code>#include</code> 预编译指令来包含头文件，但是包含头文件的语法和 C 语言有很大不同。在包含 C++ 的标准头文件时不再使用扩展名 <code>.h</code>。在 C 语言中就有的头文件不仅省略扩展名，还要加上字符 <code>c</code> 作为前缀，比如 <code>math.h</code> 变成 <code>cmath</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span> <span class="comment">// 可以</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span>  <span class="comment">// 最好</span></span></span><br></pre></td></tr></table></figure>

<p>标准输入输出要用到 <code>cin</code> 和 <code>cout</code> 两个变量，它们在头文件<code>iostream</code> 中定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iosteam&gt;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>命名空间可以解决命名冲突。变量名、函数名和类名等标识符被放置在各个命名空间中。不同命名空间中的变量可以使用同一个名字。</p>
<p>要使用命名空间中的变量，要借助作用域解析运算符 <code>::</code>。比如要使用命名空间 <code>std</code> 中的变量 <code>cin</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cin;</span><br></pre></td></tr></table></figure>

<p><code>cin</code> 和 <code>cout</code> 这两个变量都定义在命名空间 <code>std</code> 中。其他标准头文件也都是在这个命名空间中定义变量和声明函数的。</p>
<p>如果用 <code>using</code> 预编译指令列出每个变量，就不必在每次使用变量时都加上命名空间前缀。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在预编译指令 <code>using namespace</code> 之后跟上一个命名空间，表示要使用该命名空间中的任何变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来可以直接使用 cin 和 cout 等命名空间 `std` 中的任何变量</span></span><br></pre></td></tr></table></figure>

<p>C++ 源程序通常以下面两个语句开头：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iosteam&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<p>可以把第二个语句置于函数体内，这样它的作用就仅限于它所在的函数体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h4><p>C++ 将程序输入输出的数据看成水流，认为数据就像水一样在流动。程序输出的数据构成输出流；输入程序的数据构成输入流。</p>
<h5 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流"></a>标准输出流</h5><p><code>std::cout</code> 是标准输出流，要配合插入运算符 <code>&lt;&lt;</code> 使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><code>cout</code> 会根据操作数的类型以适当的格式输出该操作数的值，不必担心格式问题。</p>
<p>使用 <code>cout</code> 可以连续输出若干项。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;Hello &quot;</span> &lt;&lt; <span class="string">&quot;World!&quot;</span>; <span class="comment">// 输出 Hello World!</span></span><br></pre></td></tr></table></figure>

<p>要使光标换行，除了在字符串中使用转义字符 <code>\n</code> 之外，还可以直接使用 <code>endl</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="标准输入流"><a href="#标准输入流" class="headerlink" title="标准输入流"></a>标准输入流</h5><p><code>std::cin</code> 是标准输入流，要配合提取运算符 <code>&gt;&gt;</code> 使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age;</span><br><span class="line">cin &gt;&gt; age;</span><br></pre></td></tr></table></figure>

<p>同样，<code>cin</code> 也会根据变量的类型将用户的输入适当转换后再赋给变量。</p>
<p><code>cin</code> 支持连续给若干变量赋值。<code>cin</code> 总是忽略空白字符，从而把用户的输入分割成若干项，再依次赋给各个变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> year, month, day;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; year &gt;&gt; month &gt;&gt; day; <span class="comment">// 输入 2022 3 15</span></span><br><span class="line"><span class="comment">// 等价于 C 语言中的</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;year, &amp;month, &amp;day);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; year &lt;&lt; <span class="string">&#x27;-&#x27;</span> &lt;&lt; month &lt;&lt; <span class="string">&#x27;-&#x27;</span> &lt;&lt; day; <span class="comment">// 输出 2022-3-15</span></span><br></pre></td></tr></table></figure>

<p>由于 <code>&lt;&lt;</code> 总是忽略空白字符，因此无法用它来获取含空白字符的字符串。为此 <code>cin</code> 提供了 <code>getline()</code> 方法，用来获取一行文本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">10</span>];</span><br><span class="line">cin.<span class="built_in">getline</span>(s, <span class="number">10</span>); <span class="comment">// 输入 &quot;Hello World!&quot;</span></span><br><span class="line">cout &lt;&lt; s;          <span class="comment">// 输出 &quot;Hello Wor&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>cin</code> 其实是一个对象。要访问对象的成员函数，用圆点运算符。</p>
</blockquote>
<p>如需连续忽略若干字符，可用 <code>ignore()</code> 方法。它在忽略的字符达到第一个参数所指定的数量或遇到第二个参数指定的字符时返回。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">10</span>];</span><br><span class="line">cin.<span class="built_in">ignore</span>(<span class="number">6</span>, <span class="string">&#x27;\n&#x27;</span>); <span class="comment">// 输入 &quot;Hello World!&quot;, 被忽略的是 &quot;Hello &quot;</span></span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line">cout &lt;&lt; s;           <span class="comment">// 输出 &quot;World!&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h4><p>当一个字符串中有太多字符需要转义时，就可以采用这种语法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">R&quot;(C:\Users\Peter\Downloads)&quot;</span>; <span class="comment">// 输出 &quot;C:\Users\Peter\Downloads&quot;</span></span><br></pre></td></tr></table></figure>

<p>原始字符串以 <code>R</code> 开头，字符序列置于小括号和双引号之中。</p>
<h4 id="宽字符型"><a href="#宽字符型" class="headerlink" title="宽字符型"></a>宽字符型</h4><p><code>wchar_t</code> 称为宽字符型。宽字符型是相对于传统的只占用 1 字节的字符型 <code>char</code> 而言的。</p>
<p>宽字符型的大小和平台相关：在 Windows 上是两个字节；在 Linux 上是 4 字节。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>); <span class="comment">// 2 or 4</span></span><br></pre></td></tr></table></figure>

<p>宽字符型的字符或字符串字面量要以 <code>L</code> 开头。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wchar_t</span> wc = <span class="string">L&#x27;A&#x27;</span>;</span><br><span class="line"><span class="type">wchar_t</span> ws[] = <span class="string">L&quot;Hello World!&quot;</span>;</span><br><span class="line">wcout &lt;&lt; ws;</span><br></pre></td></tr></table></figure>

<h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><p>在输出浮点数时，要保留 2 位小数，只需像下面这样调用 <code>cout</code> 的两个成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cout.<span class="built_in">setf</span>(ios::fixed);</span><br><span class="line">cout.<span class="built_in">setf</span>(ios::showpoint);</span><br><span class="line">cout.<span class="built_in">precision</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> price = <span class="number">78.5</span>;</span><br><span class="line">cout &lt;&lt; price; <span class="comment">// 输出 78.50</span></span><br></pre></td></tr></table></figure>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>C++ 提供了新的初始化变量的方式：将初始值置于一对小括号中，跟在变量名之后，就像函数调用那样。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">age</span><span class="params">(<span class="number">18</span>)</span>, <span class="title">count</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="type">int</span> age = <span class="number">18</span>, count = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>C 语言中，将数组元素的初始值置于一对大括号中的初始化方式已不再局限于数组的初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">int</span> age = &#123; <span class="number">18</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 习惯上省略中间的等号</span></span><br><span class="line"><span class="type">int</span> arr[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">int</span> age &#123; <span class="number">18</span> &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>在声明变量的语句前添加 <code>const</code> 修饰符，变量声明就变成常量声明。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure>

<p>常量可理解为只读变量，必须初始化，但不能被改写。</p>
<h5 id="空指针常量"><a href="#空指针常量" class="headerlink" title="空指针常量"></a>空指针常量</h5><p>要表示空指针，既不是用常量 <code>NULL</code>，也不是用数字 0，而是用常量 <code>nullptr</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<p>常量 <code>NULL</code> 实际上就是数字 <code>0</code>，可以赋给 <code>int</code> 型变量，而常量 <code>nullptr</code> 则不行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">n = <span class="literal">NULL</span>;    <span class="comment">// 合法</span></span><br><span class="line">n = <span class="literal">nullptr</span>; <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure>

<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>引用是指对已有变量的引用，就像给已有变量起别名。别名可以当作变量名使用。要创建变量的引用，用声明运算符 <code>&amp;</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="type">int</span> &amp;ref = age; <span class="comment">// 引用 ref 是对变量 age 的引用</span></span><br><span class="line">ref = <span class="number">19</span>;       <span class="comment">// 等价于 age = 19</span></span><br><span class="line">cout &lt;&lt; age;    <span class="comment">// 输出 19</span></span><br></pre></td></tr></table></figure>

<p>引用很像指针，唯一区别是无需取值运算符 <code>*</code> 就可以访问它引用的变量。引用和常量一样必须初始化且不能被改写（改成其他变量的引用）。</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><h4 id="自动推断类型"><a href="#自动推断类型" class="headerlink" title="自动推断类型"></a>自动推断类型</h4><p>有初始值的变量可用 <code>auto</code> 声明，表示由编译器推断其类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> age = <span class="number">18</span>;     <span class="comment">// 自动推断为整型</span></span><br><span class="line"><span class="keyword">auto</span> price = <span class="number">19.9</span>; <span class="comment">// 自动推断为浮点型</span></span><br></pre></td></tr></table></figure>

<h4 id="string-类"><a href="#string-类" class="headerlink" title="string 类"></a><code>string</code> 类</h4><p>C++ 和 C 语言一样没有字符串型。在 C 语言中，字符串通常按字符数组处理，而在 C++ 中，通常使用 <code>string</code> 类。</p>
<blockquote>
<p>像基本类型 <code>int</code> <code>double</code> 那样使用类名即可创建类的对象。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string s = <span class="string">&quot;Hello World!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><code>string</code> 类在头文件 <code>string</code> 中声明，命名空间是 <code>std</code>。</p>
<p>可以像访问字符数组的元素那样访问 <code>string</code> 对象中的字符。它的 <code>length()</code> 方法返回字符个数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">    cout &lt;&lt; s[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="comment">// 输出 &quot;a b c d &quot;</span></span><br></pre></td></tr></table></figure>

<p><code>at()</code> 方法的作用和方括号相同，但它会检查索引是否合法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">at</span>(<span class="number">2</span>); <span class="comment">// 输出 &#x27;c&#x27;</span></span><br><span class="line">s.<span class="built_in">at</span>(<span class="number">2</span>) = <span class="string">&#x27;C&#x27;</span>;   <span class="comment">// s 变成 &quot;abCd&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以用 <code>==</code> 比较两个字符串是否相同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">cout &lt;&lt; (s == <span class="string">&quot;abcd&quot;</span>); <span class="comment">// 输出 1</span></span><br><span class="line">cout &lt;&lt; (s == <span class="string">&quot;ABC&quot;</span>);  <span class="comment">// 输出 0</span></span><br></pre></td></tr></table></figure>

<p>加号 <code>+</code> 可将 <code>string</code> 对象中的字符串和另一个字符或字符串拼接在一起，并返回一个新的 <code>string</code> 对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string firstName = <span class="string">&quot;Alexandar&quot;</span>;</span><br><span class="line">string lastName = <span class="string">&quot;Peter&quot;</span>;</span><br><span class="line">string fullName = firstName + <span class="string">&#x27; &#x27;</span> + lastName; <span class="comment">// 拼接字符</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;My name is &quot;</span> + fullName; <span class="comment">// 拼接字符串</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>empty()</code></td>
<td>若包含的是空字符串，则返回 <code>true</code></td>
</tr>
<tr>
<td><code>substr(pos, len)</code></td>
<td>返回 <code>len</code> 个字符，从 <code>pos</code> 开始</td>
</tr>
<tr>
<td><code>erase(pos, len)</code></td>
<td>删除 <code>len</code> 个字符，从 <code>pos</code> 开始</td>
</tr>
<tr>
<td><code>insert(pos, str)</code></td>
<td>在 <code>pos</code> 处插入字符串 <code>str</code></td>
</tr>
<tr>
<td><code>find(str)</code></td>
<td>查找子字符串 <code>str</code>, 找不到则返回 <code>string::npos</code></td>
</tr>
</tbody></table>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>C++ 支持 3 种强制类型转换：</p>
<ul>
<li>C 语言风格</li>
<li>函数风格</li>
<li>类型转换运算符</li>
</ul>
<p>C 语言风格也就是 C 语言中强制类型转换的方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="number">1.5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n = (<span class="type">int</span>)f;</span><br></pre></td></tr></table></figure>

<p>函数风格是 C++ 早期强制类型转换的方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="number">1.5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n = <span class="built_in">double</span>(f);</span><br></pre></td></tr></table></figure>

<p>类型转换运算符共有 4 个，它们的应用场景不同。<code>static_cast</code> 适用于编译阶段的强制类型转换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="number">1.5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(f);</span><br></pre></td></tr></table></figure>

<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>枚举类型是需要事先规定变量所有可能取值的类型。在声明新的枚举类型时，要在一对大括号中列出所有可能的取值，这些取值本质上是一组 <code>int</code> 型的全局常量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123; MON, TUE, WED, THU, FRI, SAT, SUN &#125;;</span><br></pre></td></tr></table></figure>

<p>上述语句声明了一个新的枚举类型 <code>Weekday</code>，该类型的变量的取值只能是在大括号中列出的七个常量之一。</p>
<p>枚举常量的值可以指定。默认情况下，枚举常量的值依次递增，第一个枚举常量的默认值是 0。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED = <span class="number">0</span>, GREEN = <span class="number">1</span>, BLUE = <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED, GREEN, BLUE &#125;;</span><br></pre></td></tr></table></figure>

<p>不同的枚举常量可以使用同一个值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Month</span> &#123; JAN = <span class="number">31</span>, FEB = <span class="number">28</span>, MAR = <span class="number">31</span> &#125;; <span class="comment">// 合法</span></span><br></pre></td></tr></table></figure>

<h5 id="强枚举"><a href="#强枚举" class="headerlink" title="强枚举"></a>强枚举</h5><p>枚举常量都是全局常量，故不能出现同名的枚举常量，就算是用在不同的枚举中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123; MON, TUE, WED, THU, FRI, SAT, SUN &#125;;</span><br><span class="line">Weekday today = MON; <span class="comment">// MON 是全局常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Workday</span> &#123; MON, TUE, WED, THU, FRI &#125;; <span class="comment">// 非法, 常量重复定义</span></span><br></pre></td></tr></table></figure>

<p>另外，由于枚举常量本质上是整型常量，因而一个枚举常量可以直接和整数比较而无需做显式转换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123; MON, TUE, WED, THU, FRI, SAT, SUN &#125;;</span><br><span class="line"></span><br><span class="line">Weekday today = MON;</span><br><span class="line"><span class="keyword">if</span> (today &gt; <span class="number">4</span>) <span class="comment">// 合法</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Today is a weekend day.&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Today is a workday.&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>强枚举则不具备上述两个特性：强枚举常量不会自动转换为整型，要和整数比较，必须显示转换；强枚举常量不是全局常量，要引用它们，必须借助运算符 <code>::</code>。要声明强枚举，在 <code>enum</code> 后插入关键字 <code>class</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Weekday</span> &#123; MON, TUE, WED, THU, FRI, SAT, SUN &#125;;</span><br><span class="line"></span><br><span class="line">Weekday today = Weekday::MON;    <span class="comment">// 须借助运算符 `::`</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(today) &gt; <span class="number">4</span>) <span class="comment">// 须显示转换</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Today is a weekend day.&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Today is a workday.&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>给现有的类型起一个别名，在 C 语言中用的是 <code>typedef</code> 关键字，在 C++ 中用的是 <code>using</code> 关键字。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> uint;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">using</span> uint = <span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*pAdd)</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">using</span> pAdd = <span class="built_in">int</span> (*)(<span class="type">int</span> a, <span class="type">int</span> b);</span><br></pre></td></tr></table></figure>

<p>实际上，<code>typedef</code> 关键字之后就是一个声明语句，只不过变量名被解释为类型的别名。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="重载函数名"><a href="#重载函数名" class="headerlink" title="重载函数名"></a>重载函数名</h4><p>在 C++ 中，不同的函数可以使用同一个名称。也就是说，允许存在同名函数。但它们的参数必须有所不同。实际调用的函数将根据实参的类型和数量自动匹配。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">ave</span><span class="params">(<span class="type">double</span> n1, <span class="type">double</span> n2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n1 + n2) / <span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">ave</span><span class="params">(<span class="type">double</span> n1, <span class="type">double</span> n2, <span class="type">double</span> n3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n1 + n2 + n3) / <span class="number">3.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除法运算符的两种用法就是重载的例子，它是由编译器实现的。</p>
<h4 id="传引用调用"><a href="#传引用调用" class="headerlink" title="传引用调用"></a>传引用调用</h4><p>引用可以作为函数的形参。在这种情况下，函数可以修改实参的值（实参必须是变量）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">(<span class="type">int</span> &amp;n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="built_in">fn</span>(age);     <span class="comment">// 变量 age 被修改</span></span><br><span class="line">    cout &lt;&lt; age; <span class="comment">// 输出 123</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h4><p>函数的参数可设置默认值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">showNumber</span><span class="params">(<span class="type">int</span> num = <span class="number">123</span>)</span> <span class="comment">// 参数 num 的默认值为 123</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">showNumber</span>(); <span class="comment">// 输出 123</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有默认实参的形参应置于参数列表的末尾。</p>
<h4 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h4><p>lambda 表达式是匿名函数的表达式。lambda 表达式的完整形式包含 5 个部分：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ variables ]( params ) options -&gt; ret &#123; statement; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>[ variables]</code> 捕获列表</li>
<li><code>( params )</code> 参数列表</li>
<li><code>options</code> 选项列表</li>
<li><code>ret</code> 返回类型</li>
<li><code>&#123; statement; &#125;</code> 函数体</li>
</ul>
<p>lambda 表达式的参数列表、选项列表和返回类型都可以省略，调用方式与普通函数相同。最简单的 lambda 表达式仅由一对中括号和函数体组成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fn = [] &#123; <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span>; &#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">fn</span>(); <span class="comment">// &quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure>

<p>在 lambda 表达式的函数体中可以访问表达式所在作用域中的哪些变量由捕获列表决定：</p>
<ul>
<li><code>[]</code> 不能访问任何变量</li>
<li><code>[&amp;]</code> 引用所有变量</li>
<li><code>[=]</code> 拷贝所有变量</li>
<li><code>[ foo, &amp;bar ]</code> 拷贝变量 <code>foo</code>，引用 <code>bar</code> 变量</li>
</ul>
<p>在 lambda 表达式内部不能修改它从外部捕获的变量。如果需要修改捕获的变量，需要添加 <code>mutable</code> 选项。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> data = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> fn = [data] () <span class="keyword">mutable</span> -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> ++data; &#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">fn</span>(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组本质上是只读指针变量。</p>
<h4 id="新的-for-语句"><a href="#新的-for-语句" class="headerlink" title="新的 for 语句"></a>新的 <code>for</code> 语句</h4><p>遍历数组一般采用 for 循环。C++ 提供了一种新的 for 语句，可以省去数组下标。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v: arr) &#123;</span><br><span class="line">    cout &lt;&lt; v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组 <code>arr</code> 的元素会依次赋给变量 <code>v</code>。</p>
<p>如果要改写数组元素，可将 <code>v</code> 定义成引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> &amp;v: arr) &#123;</span><br><span class="line">    v++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组作为函数参数"><a href="#数组作为函数参数" class="headerlink" title="数组作为函数参数"></a>数组作为函数参数</h4><p>数组可以作为实参，但这不会拷贝数组的元素，只是传递数组的地址。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">(<span class="type">int</span> arr[])</span></span>;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">(<span class="type">int</span> *arr)</span></span>;</span><br></pre></td></tr></table></figure>

<p>数组形参本质上是指针变量（不是只读的）。</p>
<p>要禁止函数修改数组的元素，可用 <code>const</code> 关键字修饰形参的类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">(<span class="type">const</span> <span class="type">int</span> arr[])</span> <span class="comment">// arr 的元素是只读变量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">1</span>;    <span class="comment">// 非法</span></span><br><span class="line">    arr = <span class="literal">nullptr</span>; <span class="comment">// 合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要禁止函数改变形参的指向，只能将形参定义为只读指针变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">(<span class="type">int</span> *<span class="type">const</span> arr)</span> <span class="comment">// arr 是只读指针变量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">1</span>;    <span class="comment">// 合法</span></span><br><span class="line">    arr = <span class="literal">nullptr</span>; <span class="comment">// 非法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><h4 id="指针变量的引用"><a href="#指针变量的引用" class="headerlink" title="指针变量的引用"></a>指针变量的引用</h4><p>不仅可以定义普通变量的引用，还可以定义指针变量的引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> v = <span class="number">18</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;v; <span class="comment">// p 指向 v</span></span><br><span class="line"><span class="type">int</span> *&amp;r = p; <span class="comment">// r 引用 p</span></span><br><span class="line">cout &lt;&lt; *r;  <span class="comment">// 19</span></span><br></pre></td></tr></table></figure>

<h4 id="动态变量"><a href="#动态变量" class="headerlink" title="动态变量"></a>动态变量</h4><p>动态变量没有标识符，只能通过指针引用。动态变量用 <code>new</code> 关键字声明，返回值是变量的地址。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">// p 指向 int 型动态变量</span></span><br><span class="line">*p = <span class="number">42</span>;</span><br><span class="line">cout &lt;&lt; *p; <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>

<p>用来分配给动态变量的内存空间称为 <strong>自由存储空间</strong>。如果没有足够的内存空间，<code>new</code> 语句会抛出异常。如果不捕获这个异常，程序将终止。</p>
<p>不再使用的动态变量要用 <code>delete</code> 关键字销毁，以便回收它占用的内存空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure>

<p>动态变量被销毁后，指针变量的值会变成不确定的值，就像未初始化的变量一样，称为 <strong>悬虚指针</strong>。</p>
<p>像下面这样在函数中声明的变量就是 <strong>自动变量</strong>，因为它们是随着函数调用自动创建、随着函数返回自动销毁的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">18</span>;</span><br></pre></td></tr></table></figure>

<h4 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h4><p><code>new</code> 关键字除了可以定义动态变量，还可以定义动态数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> size;</span><br><span class="line">cin &gt;&gt; size;</span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[size]; <span class="comment">// 动态数组的大小在程序运行期间才确定</span></span><br></pre></td></tr></table></figure>

<p>比起动态变量，销毁动态数组的 <code>delete</code> 语句多了一对方括号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span>[] p;</span><br></pre></td></tr></table></figure>

<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>要验证是否满足某个条件，可用 <code>assert()</code> 宏，如果条件不满足，程序就会终止，并输出断言失败 <code>Assertion failed!</code> 的提示和其他信息。<code>assert()</code> 宏在头文件 <code>cassert</code> 中定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fact</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(n &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n * <span class="built_in">fact</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">fact</span>(<span class="number">-1</span>); <span class="comment">// Assertion failed!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以禁用 <code>assert()</code> 宏，只需在包含头文件 <code>cassert</code> 之前定义 <code>NDEBUG</code> 宏。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="静态断言"><a href="#静态断言" class="headerlink" title="静态断言"></a>静态断言</h4><p>静态断言在编译阶段就起作用。如果条件不满足，编译就会终止，并输出提示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) &gt; <span class="number">4</span>, <span class="string">&quot;integer too small&quot;</span>);</span><br><span class="line"><span class="comment">// error: static assertion failed: integer too small</span></span><br></pre></td></tr></table></figure>

<p>静态断言的条件只能包含常量。</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="流、文件-IO"><a href="#流、文件-IO" class="headerlink" title="流、文件 IO"></a>流、文件 IO</h3><p>流是一个对象，包含一个字节序列。流入程序的字节序列构成输入流；流出程序的字节序列构成输出流。<code>cin</code> 是来自键盘的输入流；<code>cout</code> 是发往屏幕的输出流。</p>
<h4 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h4><p>类 <code>ifstream</code> 和 <code>ofstream</code> 分别是输入文件流和输出文件流，它们在头文件 <code>fstream</code> 中声明，命名空间是 <code>std</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<p>要借助输入文件流读取文件的内容，要先创建一个输入文件流对象，再调用它的 <code>open()</code> 方法打开文件。之后，就可以用提取运算符 <code>&gt;&gt;</code> 读取文件的内容了。不再需要读取流对象时，要调用它的 <code>close()</code> 方法关闭文件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ifstream fin;</span><br><span class="line">fin.<span class="built_in">open</span>(<span class="string">&quot;infile.dat&quot;</span>); <span class="comment">// 打开文件</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">fin &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">fin.<span class="built_in">close</span>();            <span class="comment">// 关闭文件</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，若已经到达文件末尾，则表达式 <code>fin &gt;&gt; num</code> 的值为 <code>false</code>。这就是说，该表达式可以作为循环控制条件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> next, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (fin &gt;&gt; next) &#123;</span><br><span class="line">    sum += next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种判断文件是否到达末尾的方式是调用 <code>eof()</code> 方法，它在到达文件末尾时返回 <code>true</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (! fin.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件有可能打开失败，比如文件不存在。想知道上一个操作是否失败，调用 <code>fail()</code> 方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fin.<span class="built_in">fail</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Opening failed\n&quot;</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>exit()</code> 函数用来终止程序，唯一的参数将成为程序的退出码。</p>
<h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h4><p>输出文件流的用法类似。如果要打开的文件不存在，就会自动创建一个。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ofstream fout;</span><br><span class="line">fout.<span class="built_in">open</span>(<span class="string">&quot;outfile.dat&quot;</span>);</span><br><span class="line">fout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">fout.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>

<p>程序写入文件的内容会成为文件的全部内容。带有两个参数的 <code>open()</code> 方法可以改变这种行为。这需要用到定义在命名空间 <code>ios</code> 中的一系列常量，比如 <code>iso::app</code> 表示将新的内容追加到文件末尾。这些常量经过按位与运算可以合并起来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fout.<span class="built_in">open</span>(<span class="string">&quot;outfile.dat&quot;</span>, ios::app);</span><br></pre></td></tr></table></figure>

<h4 id="流作为函数参数"><a href="#流作为函数参数" class="headerlink" title="流作为函数参数"></a>流作为函数参数</h4><p>流可以作为函数参数，但必须是传引用调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sayHi</span><span class="params">(ostream &amp;out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sayHi</span>(cout);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符-IO"><a href="#字符-IO" class="headerlink" title="字符 IO"></a>字符 IO</h4><p>任何输入输出流都拥有下表列出的成员函数。</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td><code>get()</code></td>
<td>从输入流读取一个字符</td>
<td><code>get(c)</code></td>
</tr>
<tr>
<td><code>put()</code></td>
<td>把一个字符放入输出流</td>
<td></td>
</tr>
<tr>
<td><code>putback()</code></td>
<td>把一个字符放回输入流</td>
<td></td>
</tr>
</tbody></table>
<h4 id="格式化输出-1"><a href="#格式化输出-1" class="headerlink" title="格式化输出"></a>格式化输出</h4><p>前面为了在输出带有 2 位小数的浮点数，调用了 <code>cout</code> 的两个成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout.<span class="built_in">setf</span>(ios::fixed);</span><br><span class="line">cout.<span class="built_in">setf</span>(ios::showpoint);</span><br><span class="line">cout.<span class="built_in">precision</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>调用 <code>setf()</code> 方法是为了设置标志。<code>ios::fixed</code> 表示不使用科学计数法；<code>ios::showpoint</code> 表示始终显示为带有小数点的小数。<code>precision()</code> 方法的参数表示要保留几位小数。</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>ios::showpos</code></td>
<td>在正数前面添加正号 <code>+</code></td>
</tr>
<tr>
<td><code>ios::left</code></td>
<td>左对齐，配合 <code>width</code> 方法使用</td>
</tr>
</tbody></table>
<p><code>setf()</code> 方法设置的标志可用 <code>unsetf()</code> 方法撤销。</p>
<p><code>width()</code> 方法用来设置内容的最小宽度，调用一次，生效一次。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cout.<span class="built_in">width</span>(<span class="number">4</span>);</span><br><span class="line">cout &lt;&lt; <span class="number">1</span>; <span class="comment">// 输出 &quot;   1&quot;</span></span><br><span class="line"></span><br><span class="line">cout.<span class="built_in">width</span>(<span class="number">4</span>);</span><br><span class="line">cout.<span class="built_in">setf</span>(ios::left);</span><br><span class="line">cout &lt;&lt; <span class="number">1</span>; <span class="comment">// 输出 &quot;1   &quot;</span></span><br><span class="line"></span><br><span class="line">cout.<span class="built_in">setf</span>(ios::showpos);</span><br><span class="line">cout &lt;&lt; <span class="number">1</span>; <span class="comment">// 输出 &quot;+1&quot;</span></span><br></pre></td></tr></table></figure>

<p>输出流都拥有上述成员函数。</p>
<h5 id="操纵元"><a href="#操纵元" class="headerlink" title="操纵元"></a>操纵元</h5><p>用来换行的 <code>endl</code> 就是操纵元，而不是常量。要使用其它操纵元，要包含头文件 <code>iomanip</code>。操纵元是定义在命名空间 <code>std</code> 中的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<p>要用操纵元，只需把它置于插入运算符 <code>&lt;&lt;</code> 之后，就像要输出它一样。操纵元是通过调用某个成员函数来实现它的作用的。比如操纵元 <code>setw()</code> 会调用 <code>width()</code> 方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">4</span>) &lt;&lt; <span class="number">1</span>; <span class="comment">// 输出 &quot;   1&quot;</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">cout.<span class="built_in">width</span>(<span class="number">4</span>);</span><br><span class="line">cout &lt;&lt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>操纵元 <code>setprecision()</code> 会调用 <code>precision()</code> 方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cout.<span class="built_in">setf</span>(ios::fixed);</span><br><span class="line">cout.<span class="built_in">setf</span>(ios::showpoint);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; <span class="number">1.0</span>; <span class="comment">// 输出 &quot;1.00&quot;</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">cout.<span class="built_in">precision</span>(<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="number">1.0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="标准-string-类"><a href="#标准-string-类" class="headerlink" title="标准 string  类"></a>标准 <code>string </code> 类</h3><p><code>string</code> 类有两个构造函数。<code>string</code> 对象不存储字符串的结束标志 <code>\0</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s1;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">string s2 = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="getline-函数"><a href="#getline-函数" class="headerlink" title="getline() 函数"></a><code>getline()</code> 函数</h4><p>头文件 <code>string</code> 声明了一个 <code>getline()</code> 函数（有别于 <code>cin</code> 的 <code>getline()</code> 方法），它可从输入流获取一行文本并保存到 <code>string</code> 对象中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string line;</span><br><span class="line"><span class="built_in">getline</span>(cin, line); <span class="comment">// 输入 &quot;Hello World!&quot;</span></span><br><span class="line">cout &lt;&lt; line;       <span class="comment">// 输出 &quot;Hello World!&quot;</span></span><br></pre></td></tr></table></figure>

<p>标准库重载了 <code>getline()</code> 函数。带有三个参数的 <code>getline()</code> 函数可以指定行结束符（默认是 <code>\n</code>）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string line, s;</span><br><span class="line"><span class="built_in">getline</span>(cin, line, <span class="string">&#x27;!&#x27;</span>) &gt;&gt; s; <span class="comment">// 输入 &quot;Hello World! Good day&quot;</span></span><br><span class="line">cout &lt;&lt; line &lt;&lt; endl;         <span class="comment">// 输出 &quot;Hello World&quot;</span></span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;            <span class="comment">// 输出 &quot;Good&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>getline()</code> 的返回值是第一个参数的引用。故：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getline</span>(cin, line, <span class="string">&#x27;!&#x27;</span>) &gt;&gt; s;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="built_in">getline</span>(cin, line, <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">cin &gt;&gt; s;</span><br></pre></td></tr></table></figure>

<h4 id="转换成-C-字符串"><a href="#转换成-C-字符串" class="headerlink" title="转换成 C 字符串"></a>转换成 C 字符串</h4><p>字符串会自动转换成 <code>string</code> 对象，所以可以把一个字符串赋给 <code>string</code> 对象。<code>string</code> 对象不会自动转换成字符串，所以不能把一个 <code>string</code> 对象赋给字符数组，或者作为字符串函数的参数。要得到 <code>string</code> 对象中的字符串，可以调用它的 <code>c_str()</code> 方法，它返回字符串的指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;HelloWorld!&quot;</span>;</span><br><span class="line"><span class="type">char</span> s2[<span class="number">6</span>];</span><br><span class="line"><span class="built_in">strncpy</span>(s2, s1.<span class="built_in">c_str</span>(), <span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; s2; <span class="comment">// 输出 &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="解析成数字"><a href="#解析成数字" class="headerlink" title="解析成数字"></a>解析成数字</h4><p>头文件 <code>string</code> 声明了四个函数，它们不仅可以从字符串解析数字，还可以从 <code>string</code> 对象解析数字。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;98&quot;</span>;</span><br><span class="line"><span class="type">int</span> num = <span class="built_in">stoi</span>(s1);</span><br><span class="line">cout &lt;&lt; num; <span class="comment">// 98</span></span><br></pre></td></tr></table></figure>

<p><code>stoi()</code> <code>stol()</code> <code>stof()</code> <code>stod()</code> 分别将字符串转换成 <code>int</code> <code>long</code> <code>float</code> <code>double</code> 型。</p>
<p><code>to_string()</code> 函数能够返回任意类型的数字的字符串表示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line">string s1 = <span class="built_in">to_string</span>(num);</span><br><span class="line">cout &lt;&lt; s1; <span class="comment">// &quot;123&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p>向量在头文件 <code>vector</code> 中声明，命名空间是 <code>std</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<p>向量可看作长度可变的数组。声明 <code>int</code> 型向量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br></pre></td></tr></table></figure>

<p>向量是 C++ 标准模板库的一部分。向量是一个对象。上例中，<code>vector&lt;int&gt;</code> 是一个类，而 <code>v</code> 是它的一个对象。</p>
<p>元素的初始化和读写方式和数组一样。向量的 <code>size()</code> 方法返回元素个数，即向量长度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span> &#125;;</span><br><span class="line">v[<span class="number">2</span>] = <span class="number">14</span>;</span><br><span class="line">cout &lt;&lt; v[<span class="number">2</span>]; <span class="comment">// 14</span></span><br><span class="line">cout &lt;&lt; v.<span class="built_in">size</span>(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>向量的使用存在两条限制：只能顺序添加新元素；添加新元素只能用 <code>push_back()</code> 方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span> &#125;;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">14</span>); <span class="comment">// 相当于 v[3] = 14</span></span><br><span class="line">cout &lt;&lt; v[<span class="number">3</span>]; <span class="comment">// 14</span></span><br></pre></td></tr></table></figure>

<p>向量有一个带有一个参数的构造函数，可指定元素个数，初始值为 0。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; v.<span class="built_in">size</span>(); <span class="comment">// 3</span></span><br><span class="line">cout &lt;&lt; v.<span class="built_in">capacity</span>(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>向量的 <code>capacity()</code> 方法返回向量的容量。不同于向量的长度，向量的容量还算上未初始化的元素，反映了向量实际占用内存。 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">cout &lt;&lt; v.<span class="built_in">size</span>(); <span class="comment">// 4</span></span><br><span class="line">cout &lt;&lt; v.<span class="built_in">capacity</span>(); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>可用 <code>reserve()</code> 方法增大容量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">v.<span class="built_in">reserve</span>(<span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; v.<span class="built_in">size</span>(); <span class="comment">// 3</span></span><br><span class="line">cout &lt;&lt; v.<span class="built_in">capacity</span>(); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>可以 <code>resize()</code> 方法改变长度。如果长度变小，超出的元素将被直接丢弃。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">6</span>);</span><br><span class="line">cout &lt;&lt; v.<span class="built_in">size</span>(); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<h3 id="从结构到类"><a href="#从结构到类" class="headerlink" title="从结构到类"></a>从结构到类</h3><p>在 C++ 中，结构的成员可以是函数。在成员函数中，要访问成员变量，直接用变量名即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; year &lt;&lt; <span class="string">&#x27;-&#x27;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; day;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 C 语言中，定义结构变量也要用到 <code>struct</code> 关键字，在 C++ 中则不用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date today = &#123; <span class="number">2022</span>, <span class="number">3</span>, <span class="number">20</span> &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>一个结构变量可以赋给另一个同一类型的结构变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Date d1 = &#123; <span class="number">2022</span>, <span class="number">03</span>, <span class="number">20</span> &#125;;</span><br><span class="line">Date d2;</span><br><span class="line"></span><br><span class="line">d2 = d1;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">d2.year  = d1.year;</span><br><span class="line">d2.month = d1.month;</span><br><span class="line">d2.day   = d1.day;</span><br><span class="line"></span><br><span class="line">d2.<span class="built_in">output</span>(); <span class="comment">// 2022-3-20</span></span><br></pre></td></tr></table></figure>

<p>这种拷贝每一个成员变量的值的行为称为 <strong>浅拷贝</strong>。</p>
<h4 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h4><p>在 C++ 中，结构类型是特殊的类。特殊之处在于，结构的成员都是公开的。也就是说，任何函数都可以访问结构的成员。而类的成员有可能是私有的、受保护的。也就是说，类的某些成员只有某些函数可以访问。</p>
<p>将结构定义中的关键字 <code>struct</code> 替换成 <code>class</code>，结构定义就变成类定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; year &lt;&lt; <span class="string">&#x27;-&#x27;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; day;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对象不能像结构变量那样用一对大括号来初始化成员变量。对象有其他初始化成员变量的方式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date today = &#123; <span class="number">2022</span>, <span class="number">3</span>, <span class="number">20</span> &#125;; <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure>

<p>习惯上，类定义只包含函数声明。在定义成员函数时，要在函数名前面添加类名作为 <strong>类型限定符</strong>，两者用 <strong>作用域解析运算符</strong> <code>::</code> 隔开。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">()</span></span>;  <span class="comment">// 成员函数声明</span></span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Date::output</span><span class="params">()</span> <span class="comment">// 成员函数定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; year &lt;&lt; <span class="string">&#x27;-&#x27;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; day;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成员默认都是私有的。在成员列表中插入标号可以改变成员的访问权限。标号 <code>private</code> <code>protected</code> <code>public</code> 分别表示私有成员、受保护成员和公开成员。只有成员函数可以访问私有成员和受保护成员（不区分是不是同一个对象）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// 以下是公开成员</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// 以下是私有成员</span></span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对象也可以浅拷贝，并且私有成员和受保护成员也会被拷贝。</p>
</blockquote>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>函数名是类名且没有返回值的公开方法被视为构造函数。构造函数用来完成对象的初始化工作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d); <span class="comment">// 带有 3 个参数的构造函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Date::<span class="built_in">Date</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d)</span><br><span class="line">&#123;</span><br><span class="line">    year = y;</span><br><span class="line">    month = m;</span><br><span class="line">    day = d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>类的定义要以分号 <code>;</code> 结尾。</p>
</blockquote>
<p>要调用构造函数，只需在变量名后面跟上参数列表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Date <span class="title">today</span><span class="params">(<span class="number">2022</span>, <span class="number">3</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">today.<span class="built_in">output</span>(); <span class="comment">// 2022-3-20</span></span><br></pre></td></tr></table></figure>

<h4 id="初始化区域"><a href="#初始化区域" class="headerlink" title="初始化区域"></a>初始化区域</h4><p>在构造函数的参数列表之后、函数体之前的区域称为初始化区域。初始化区域用来初始化成员变量。上例的构造函数可改写成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date::<span class="built_in">Date</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d): <span class="built_in">year</span>(y), <span class="built_in">month</span>(m), <span class="built_in">day</span>(d) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="显式调用构造函数"><a href="#显式调用构造函数" class="headerlink" title="显式调用构造函数"></a>显式调用构造函数</h4><p>可以显式调用构造函数，它将返回一个新的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date today = <span class="built_in">Date</span>(<span class="number">1949</span>, <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">today.<span class="built_in">output</span>(); <span class="comment">// 1949-10-1</span></span><br></pre></td></tr></table></figure>

<p>在调用构造函数时，也可以用 <code>new</code> 关键字。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date *today = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1949</span>, <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">today-&gt;<span class="built_in">output</span>(); <span class="comment">// 1949-10-1</span></span><br></pre></td></tr></table></figure>

<h3 id="重载方法名"><a href="#重载方法名" class="headerlink" title="重载方法名"></a>重载方法名</h3><p>成员函数的名称也可以重载。重载构造函数名可以提供多种初始化对象的方式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>();                    <span class="comment">// 不带参数的构造函数</span></span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d); <span class="comment">// 带有 3 个参数的构造函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Date::<span class="built_in">Date</span>(): <span class="built_in">year</span>(<span class="number">1997</span>), <span class="built_in">month</span>(<span class="number">5</span>), <span class="built_in">day</span>(<span class="number">20</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Date::<span class="built_in">Date</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d): <span class="built_in">year</span>(y), <span class="built_in">month</span>(m), <span class="built_in">day</span>(d) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Date birthday;     <span class="comment">// 要调用不带参数的构造函数, 就不要在变量名后面跟上参数列表</span></span><br><span class="line">birthday.<span class="built_in">output</span>(); <span class="comment">// 1997-5-20</span></span><br><span class="line"></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">(<span class="number">2022</span>, <span class="number">3</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">today.<span class="built_in">output</span>();    <span class="comment">// 2022-3-20</span></span><br></pre></td></tr></table></figure>

<h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><p>不带参数的构造函数称为默认构造函数。变量名后面没有跟上参数列表就会调用默认构造函数。</p>
<p>如果没有定义构造函数，编译器就会自动生成一个什么都不做的默认构造函数。如果定义了构造函数，编译器就不再提供默认构造函数。除非存在默认构造函数，否则变量名后面必须跟上参数列表。</p>
<p>声明类数组时会调用默认构造函数，因此要作为数组基类型的类必须拥有默认构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date date[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<h4 id="构造函数委托"><a href="#构造函数委托" class="headerlink" title="构造函数委托"></a>构造函数委托</h4><p>构造函数可以调用另一个构造函数。上例的默认构造函数可改写成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date::<span class="built_in">Date</span>(): <span class="built_in">Date</span>(<span class="number">1997</span>, <span class="number">5</span>, <span class="number">20</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>可以通过继承现有的类来定义新的类。被继承的类称为 <strong>基类</strong>，新的类称为 <strong>派生类</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>: <span class="keyword">public</span> Foo &#123; ... &#125;; <span class="comment">// Bar 继承 Foo</span></span><br></pre></td></tr></table></figure>

<p>如果派生类的构造函数没有显式调用基类的构造函数，编译器会让派生类调用基类的默认构造函数。此时，如果基类没有默认构造函数，编译就无法通过。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bar::<span class="built_in">Bar</span>() &#123;&#125;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">Bar::<span class="built_in">Bar</span>(): <span class="built_in">Foo</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>函数名是带有 <code>~</code> 前缀的类名且没有参数和返回值的公开方法被视为析构函数。析构函数用来释放内存，避免内存泄漏。每个类最多只能有一个析构函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Date</span>() &#123; <span class="comment">// 析构函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destroyed&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="用-const-修饰成员函数"><a href="#用-const-修饰成员函数" class="headerlink" title="用 const 修饰成员函数"></a>用 <code>const</code> 修饰成员函数</h3><p>要禁止成员函数修改成员变量，在函数声明的末尾插入 <code>const</code>，在函数定义的初始化区域插入 <code>const</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Point::getX</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="comment">// 非法</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用 <code>const</code> 修饰的成员函数调用了另一个成员函数，则后者也必须用 <code>const</code> 修饰。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Point::getX</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fn</span>(); <span class="comment">// 成员函数 `fn()` 也要用 `const` 修饰</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>友元函数不是成员函数，但它和成员函数一样能访问私有成员变量。友元函数要像成员函数那样在类的定义中声明，并且开头要加上关键字 <code>friend</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">int</span> <span class="title">getX</span><span class="params">(Point &amp;point)</span></span>; <span class="comment">// 友元函数的声明</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">(Point &amp;point)</span> <span class="comment">// 友元函数的定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> point.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>友元函数的定义不需要包含类型限定符，只能像普通函数那样直接调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point p;</span><br><span class="line">cout &lt;&lt; <span class="built_in">getX</span>(p); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h3><p>可以用运算符 <code>==</code> 来比较两个 <code>string</code> 对象中的字符串是否相同。这是重载运算符 <code>==</code> 带来的便利。</p>
<p>运算符本质上是函数，它们的操作数就是函数的参数。重载运算符实际上就是重载函数名。重载运算符可以让运算符支持更多类型的操作数。重载运算符时，函数名是带有关键字 <code>operator</code> 作为前缀的运算符，比如 <code>operator==</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x1, <span class="type">int</span> y1): <span class="built_in">x</span>(x1), <span class="built_in">y</span>(y1) &#123;&#125;;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(Point &amp;a, Point &amp;b);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(Point &amp;A, Point &amp;B)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> A.x == B.x &amp;&amp; A.y == B.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重载运算符 <code>==</code> 后，就可以用它来比较两个 <code>Point</code> 对象是否相同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">A</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span>, <span class="title">B</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span>, <span class="title">C</span><span class="params">(<span class="number">2</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; (A == B); <span class="comment">// 1</span></span><br><span class="line">cout &lt;&lt; (A == C); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>重载运算符不能改变参数的数量。也就是说，不能把一元运算符变成二元运算符。</p>
<h4 id="用于自动类型转换的构造函数"><a href="#用于自动类型转换的构造函数" class="headerlink" title="用于自动类型转换的构造函数"></a>用于自动类型转换的构造函数</h4><p>涉及对象的自动类型转换，要依靠只有一个参数的构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;(Account &amp;a, Account &amp;b);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(Account &amp;a, Account &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.total &gt; b.total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子重载了运算符 <code>&gt;</code>，使它可以用来比较两个 <code>Account</code> 对象，但不能用来比较一个 <code>Account</code> 对象和一个整数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Account a, b;</span><br><span class="line">a &gt; b; <span class="comment">// 合法</span></span><br><span class="line">a &gt; <span class="number">0</span>; <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure>

<p>要支持第二种比较，只需添加一个单参数构造函数。这相当于告诉编译器如何将一个整数转换成 <code>Account</code> 对象，也就实现了整数到 <code>Account</code> 对象的自动类型转换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Account</span>(<span class="type">int</span> money = <span class="number">0</span>): <span class="built_in">total</span>(money) &#123;&#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种自动类型转换不仅适用于运算符，也适用于所有需要做类型转换的地方，比如函数的参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Account</span>(<span class="type">int</span> money = <span class="number">0</span>): <span class="built_in">total</span>(money) &#123;&#125;;</span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(Account &amp;account)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; account.total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">output</span>(<span class="number">99</span>); <span class="comment">// 合法, 99 自动转换成 Account 对象</span></span><br></pre></td></tr></table></figure>

<h4 id="重载插入运算符"><a href="#重载插入运算符" class="headerlink" title="重载插入运算符"></a>重载插入运算符</h4><p>前文已经多次使用插入运算符来显示信息。插入运算符可以构成表达式链。这是因为插入运算符和 <code>+</code> <code>==</code> 等运算符一样也有一个返回值，那就是它的第一个操作数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;Hello &quot;</span> &lt;&lt; <span class="string">&quot;World!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，第一个插入运算符会返回 <code>cout</code>，因此对于第二个插入运算符来说，它的左操作数是 <code>cout</code>。</p>
<p>重载插入或提取运算符的函数都必须返回第一个参数的引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Account &amp;account);</span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp;in, Account &amp;account);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Account &amp;account)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; <span class="string">&#x27;$&#x27;</span> &lt;&lt; account.total;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp;in, Account &amp;account)</span><br><span class="line">&#123;</span><br><span class="line">    in &gt;&gt; account.total;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Account account;</span><br><span class="line">cin &gt;&gt; account;  <span class="comment">// 输入 99</span></span><br><span class="line">cout &lt;&lt; account; <span class="comment">// 输出 $99</span></span><br></pre></td></tr></table></figure>

<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>类的拷贝构造函数是只有一个参数的构造函数，这个参数必须是一个对象的引用，对象的类型就是这个类，通常用 <code>const</code> 关键字修饰。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> s[]);</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String &amp;s);</span><br><span class="line">    ~<span class="built_in">String</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">String::<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> s[]) <span class="comment">// 用于自动类型转换的构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;cast&quot;</span> &lt;&lt; endl;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(p, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::<span class="built_in">String</span>(<span class="type">const</span> String &amp;s) <span class="comment">// 拷贝构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::~<span class="built_in">String</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拷贝构造函数的任务是构造实参的一个完整的、独立的拷贝。在上面的例子中，不能简单地将 <code>s.p</code> 赋给 <code>p</code>，那样会造成两个对象的 <code>p</code> 指向同一个字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String::<span class="built_in">String</span>(<span class="type">const</span> String &amp;s) <span class="comment">// 拷贝构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;copied&quot;</span> &lt;&lt; endl;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s.p) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(p, s.p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建一个完整的、独立的拷贝称为 <strong>深拷贝</strong>。</p>
</blockquote>
<p>有了拷贝构造函数，就可以在声明语句中用一个对象来初始化另一个对象。</p>
<p>下面语句先调用构造函数 <code>String(const char s[])</code> 将字符串 <code>&quot;Peter&quot;</code> 转换成 <code>String</code> 匿名对象，再调用拷贝构造函数，用匿名对象完成 <code>firstName</code> 的初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String firstName = <span class="string">&quot;Peter&quot;</span>; <span class="comment">// 输出 &quot;copied&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上，此处由于 g++ 的优化并不会调用拷贝构造函数。添加 <code>-fno-elide-constructors</code> 选项可以禁用这种优化。</p>
</blockquote>
<p>注意区分声明语句和赋值语句。赋值语句永远不会调用拷贝构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = s2; <span class="comment">// 声明语句</span></span><br><span class="line"></span><br><span class="line">String s1;      <span class="comment">// 声明语句</span></span><br><span class="line">s1 = s2;        <span class="comment">// 赋值语句</span></span><br></pre></td></tr></table></figure>

<p>声明语句也并非一定会调用拷贝构造函数。只有变量名和初始值之间有等号时，才会调用拷贝构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">a</span><span class="params">(<span class="string">&quot;Peter&quot;</span>)</span></span>;      <span class="comment">// 只发生自动类型转换</span></span><br><span class="line">String c &#123; <span class="string">&quot;Peter&quot;</span> &#125;;   <span class="comment">// 只发生自动类型转换</span></span><br><span class="line"></span><br><span class="line">String b = <span class="string">&quot;Peter&quot;</span>;     <span class="comment">// 发生自动类型转换并调用拷贝构造函数</span></span><br><span class="line">String d = &#123; <span class="string">&quot;Peter&quot;</span> &#125;; <span class="comment">// 发生自动类型转换并调用拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<h4 id="拷贝构造函数的用途"><a href="#拷贝构造函数的用途" class="headerlink" title="拷贝构造函数的用途"></a>拷贝构造函数的用途</h4><p>拷贝构造函数是包含指针成员的类必不可少的构造函数，它和用于自动类型转换的构造函数一样，是由编译器根据需要调用的。有三个情形会调用拷贝构造函数：</p>
<ol>
<li>情形一：用一个对象来初始化另一个对象</li>
<li>情形二：对象作为函数参数</li>
<li>情形三：对象作为函数返回值</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">foo</span>(<span class="string">&quot;foo&quot;</span>); <span class="comment">// 输出 &quot;copied&quot;</span></span><br><span class="line"><span class="built_in">bar</span>();      <span class="comment">// 输出 &quot;copied&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="重载赋值运算符"><a href="#重载赋值运算符" class="headerlink" title="重载赋值运算符"></a>重载赋值运算符</h4><p>虽然赋值运算符也是二元运算符，但它只需要右操作数作为参数。赋值运算符必须是类的成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> String &amp;right);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> String::<span class="keyword">operator</span>=(<span class="type">const</span> String &amp;right)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>赋值运算符的任务和拷贝构造函数一样，要构造实参的一个完整的、独立的拷贝。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> String::<span class="keyword">operator</span>=(<span class="type">const</span> String &amp;right)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;assigned&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(right.p) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(p, right.p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面第二个语句先将 <code>&quot;Peter&quot;</code> 转换成 <code>String</code> 对象，再将这个对象赋给 <code>firstName</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String firstName = <span class="string">&quot;&quot;</span>;</span><br><span class="line">firstName = <span class="string">&quot;Peter&quot;</span>; <span class="comment">// 输出 &quot;assigned&quot;</span></span><br></pre></td></tr></table></figure>

<p>实际上，上述定义存在一个 Bug。如果赋值运算符的左、右操作数是同一个，那么 <code>p</code> 就是 <code>right.p</code>，在调用 <code>strcpy()</code> 之前，<code>right.p</code> 已被销毁。要解决这个 Bug，只需增加一个 <code>if</code> 语句，判断左、右操作数是不是同一个，如果是，就立即返回，什么都不做。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> String::<span class="keyword">operator</span>=(<span class="type">const</span> String &amp;right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;right) <span class="keyword">return</span>; <span class="comment">// this 是预定义指针变量, 保存了对象的地址</span></span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(right.p) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(p, right.p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重载方括号"><a href="#重载方括号" class="headerlink" title="重载方括号"></a>重载方括号</h4><p>方括号运算符和赋值运算符一样，必须是类的成员，它应该返回元素的引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>&amp; String::<span class="keyword">operator</span>[](<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;accessed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String firstName = <span class="string">&quot;Peter&quot;</span>;</span><br><span class="line">firstName[<span class="number">0</span>] = <span class="string">&#x27;p&#x27;</span>;   <span class="comment">// 输出 &quot;accessed&quot;</span></span><br><span class="line">cout &lt;&lt; firstName[<span class="number">0</span>]; <span class="comment">// 输出 &quot;accessed&quot; 和 &#x27;p&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="命名空间-1"><a href="#命名空间-1" class="headerlink" title="命名空间"></a>命名空间</h3><h4 id="创建命名空间"><a href="#创建命名空间" class="headerlink" title="创建命名空间"></a>创建命名空间</h4><p>将代码置于 <strong>命名空间分组</strong> 中，就可以将代码中声明的变量名、函数名、类名等标识符放到指定命名空间中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ns1 &#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ns1 &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子包含两个命名空间分组，它们都把标识符放到命名空间 <code>ns1</code> 中。</p>
<p>不属于任何命名空间分组的代码中声明的标识符自动放到 <strong>全局命名空间</strong> 中。整个程序无需限定符就可以直接用全局命名空间中的标识符。</p>
<h4 id="限定名称"><a href="#限定名称" class="headerlink" title="限定名称"></a>限定名称</h4><p>要使用命名空间中 <code>ns1</code> 中的标识符，用 <code>using</code> 指令。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ns1;</span><br></pre></td></tr></table></figure>

<p>有了这条指令，就可以直接使用命名空间中 <code>ns1</code> 中的任何标识符。</p>
<p>不用这条指令也能使用命名空间中的标识符，但每次都要用到作用域解析运算符 <code>::</code>。比如要使用命名空间中 <code>ns1</code> 中的变量 <code>a</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ns1::a = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>如果用 <code>using</code> 指令提前说明，就可以省去前缀 <code>ns1::</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ns1::a;</span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="无名命名空间"><a href="#无名命名空间" class="headerlink" title="无名命名空间"></a>无名命名空间</h4><p>每个文件都是一个编译单元，每个编译单元都有一个无名命名空间。要把名称放到无名命名空间也要使用命名空分组，但是命名空间的具体名称要省略。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编译单元内部可直接使用无名命名空间中的名称。</p>
<p>无名命名空间通常用来放置模块内部使用的辅助函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">()</span></span>; <span class="comment">// 函数声明</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ns1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">cls1</span> <span class="comment">// 类定义</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">()</span> </span>&#123; <span class="comment">// 函数定义</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="命名空间别名"><a href="#命名空间别名" class="headerlink" title="命名空间别名"></a>命名空间别名</h4><p>可以用 <code>namespace</code> 指令给命名空间起别名。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> fs = std::filesystem;</span><br></pre></td></tr></table></figure>

<h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h3><p>派生类会继承基类的成员变量和成员函数，包括私有成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> v1; &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> v1 = <span class="number">123</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>: <span class="keyword">public</span> Foo &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">Bar bar;</span><br><span class="line">cout &lt;&lt; bar.<span class="built_in">f1</span>(); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<h4 id="基类的构造函数"><a href="#基类的构造函数" class="headerlink" title="基类的构造函数"></a>基类的构造函数</h4><p>派生类不会继承基类的构造函数，但可以显示调用基类的构造函数。派生类默认会调用基类的默认构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() &#123; cout &lt;&lt; <span class="string">&quot;Foo() called&quot;</span>; &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Bar bar; <span class="comment">// &quot;Foo() called&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="私有成员的继承"><a href="#私有成员的继承" class="headerlink" title="私有成员的继承"></a>私有成员的继承</h4><p>派生类会继承私有成员，但是派生类新增的成员函数不能直接访问私有成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;f2() called&quot;</span>; &#125;;</span><br><span class="line">    <span class="type">int</span> v1 = <span class="number">123</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>: <span class="keyword">public</span> Foo</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">b1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        v1 = <span class="number">0</span>; <span class="comment">// 非法</span></span><br><span class="line">        <span class="built_in">f2</span>();   <span class="comment">// 非法</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="受保护成员的继承"><a href="#受保护成员的继承" class="headerlink" title="受保护成员的继承"></a>受保护成员的继承</h4><p>派生类会继承受保护成员，派生类新增的成员函数可以直接访问受保护成员。对其他函数来说，受保护成员相当于私有成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;f3 called&quot;</span>; &#125;;</span><br><span class="line">    <span class="type">int</span> v2 = <span class="number">456</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>: <span class="keyword">public</span> Foo</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">b2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        v2 = <span class="number">0</span>; <span class="comment">// 合法</span></span><br><span class="line">        <span class="built_in">f3</span>();   <span class="comment">// 合法</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>三种成员对各种函数的可见性如下表所示：</p>
<table>
<thead>
<tr>
<th>Base member</th>
<th>Base method</th>
<th>Drived method</th>
<th>Other function</th>
</tr>
</thead>
<tbody><tr>
<td>私有成员</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>受保护成员</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>公开成员</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody></table>
<h4 id="重定义成员函数"><a href="#重定义成员函数" class="headerlink" title="重定义成员函数"></a>重定义成员函数</h4><p>派生类不仅可以原封不动地继承基类的成员函数，还可以对它们进行重定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> v1; &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> v1 = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> v2 = <span class="number">456</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>: <span class="keyword">public</span> Foo</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> v2; &#125;; <span class="comment">// 重定义</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Bar bar;</span><br><span class="line">cout &lt;&lt; bar.<span class="built_in">f1</span>(); <span class="comment">// 456</span></span><br></pre></td></tr></table></figure>

<p>参数列表要和基类保持一致才是重定义，否则就变成重载。</p>
<p>重定义了成员函数的派生类仍然可以调用基类的版本，只是要借助作用域解析运算符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bar bar;</span><br><span class="line">cout &lt;&lt; bar.Foo::<span class="built_in">f1</span>(); <span class="comment">// 123</span></span><br><span class="line">cout &lt;&lt; bar.<span class="built_in">f1</span>();      <span class="comment">// 456</span></span><br></pre></td></tr></table></figure>

<h4 id="不继承的函数"><a href="#不继承的函数" class="headerlink" title="不继承的函数"></a>不继承的函数</h4><p>派生类不会继承基类的拷贝构造函数、赋值运算符和析构函数。</p>
<p>派生类在定义自己的拷贝构造函数和赋值运算符时，通常要先调用基类的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>: <span class="keyword">public</span> Foo</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bar</span>(<span class="type">const</span> Bar &amp;bar);</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> Bar &amp;right);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Bar::<span class="built_in">Bar</span>(<span class="type">const</span> Bar &amp;bar): <span class="built_in">Foo</span>(bar) <span class="comment">// 调用基类的拷贝构造函数, 此处存在自动类型转换</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> Bar::<span class="keyword">operator</span>=(<span class="type">const</span> Bar &amp;right)</span><br><span class="line">&#123;</span><br><span class="line">    Foo::<span class="keyword">operator</span>=(right); <span class="comment">// 调用基类的赋值运算符</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>派生类的析构函数会自动调用基类的析构函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Foo</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Foo() called&quot;</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>: <span class="keyword">public</span> Foo &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Bar bar; <span class="comment">// &quot;~Foo() called&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><p>虚函数是在基类中声明和定义、在派生类中重定义的成员函数，在某种意义上是可以先使用再定义的成员函数。虚函数的声明要用 <code>virtual</code> 关键字修饰。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>; <span class="comment">// 虚函数的声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>; <span class="comment">// 虚函数的声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::fn</span><span class="params">()</span> </span>&#123; <span class="built_in">f1</span>(); &#125;            <span class="comment">// 基类的另一个成员函数调用了虚函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::f1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f1&quot;</span>; &#125; <span class="comment">// 虚函数的定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B::f1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::f1&quot;</span>; &#125; <span class="comment">// 重定义虚函数</span></span><br><span class="line"></span><br><span class="line">B b;</span><br><span class="line">b.<span class="built_in">fn</span>(); <span class="comment">// &quot;B::f1&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果基类的成员函数调用了虚函数，而且派生类重定义了这个虚函数，那么基类的成员函数就会调用重定义的版本。在派生类中重定义虚函数就称为 <strong>重写</strong>。</p>
<h4 id="重写和重定义"><a href="#重写和重定义" class="headerlink" title="重写和重定义"></a>重写和重定义</h4><p>如果基类的成员函数调用的不是虚函数，那么基类的成员函数就永远不会调用重定义的版本。</p>
<p>派生类 <code>B</code> 重定义了基类 <code>A</code> 的两个成员函数 <code>f1()</code> 和 <code>f2()</code>，基类的另一个成员函数 <code>fn()</code> 调用了这个两个成员函数。由于 <code>f1()</code> 是虚函数，因此 <code>fn()</code> 调用的是 <code>B::f1()</code>，而 <code>f2()</code> 不是虚函数，所以 <code>fn()</code> 调用的是 <code>A::f2()</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>; <span class="comment">// 声明</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>; <span class="comment">// 声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>; <span class="comment">// 声明</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>; <span class="comment">// 声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::fn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f1</span>(); <span class="comment">// &quot;B::f1&quot;</span></span><br><span class="line">    <span class="built_in">f2</span>(); <span class="comment">// &quot;A::f2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::f1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f1&quot;</span>; &#125; <span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::f2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f2&quot;</span>; &#125; <span class="comment">// 定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B::f1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::f1&quot;</span>; &#125; <span class="comment">// 重写</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B::f2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::f2&quot;</span>; &#125; <span class="comment">// 重定义</span></span><br></pre></td></tr></table></figure>

<h4 id="派生类转换成基类"><a href="#派生类转换成基类" class="headerlink" title="派生类转换成基类"></a>派生类转换成基类</h4><p>派生类的对象可以自动转换成基类的对象，但反过来不行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(A a)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(B b)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f1</span>( <span class="built_in">B</span>() ); <span class="comment">// 合法</span></span><br><span class="line"><span class="built_in">f2</span>( <span class="built_in">A</span>() ); <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure>

<p>虽然派生类的对象可以转换成基类的对象，但是转换过程中会丢失派生类新增的成员，包括在派生类中重写的虚函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">fn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="type">int</span> a1 = <span class="number">123</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">fn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="type">int</span> b1 = <span class="number">456</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">A::fn</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a1; &#125; <span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">B::fn</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> b1; &#125; <span class="comment">// 重写</span></span><br><span class="line"></span><br><span class="line">A a = <span class="built_in">B</span>();      <span class="comment">// 会丢失数据</span></span><br><span class="line">a.b1;           <span class="comment">// 非法</span></span><br><span class="line">cout &lt;&lt; a.<span class="built_in">fn</span>(); <span class="comment">// 123, 没有调用重写的版本</span></span><br></pre></td></tr></table></figure>

<p>将派生类的对象赋给基类的变量会丢失数据，将派生类的指针转换成基类的指针则不会。也就是说，派生类的成员仍然存在，重写的虚函数仍然可用。然而，基类的指针仍然不能用来访问派生类才有的成员，不过可以用基类的指针调用虚函数，而在虚函数中可以访问派生类的成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A *pA = <span class="keyword">new</span> B;    <span class="comment">// 不会丢失数据</span></span><br><span class="line">pA-&gt;b1;           <span class="comment">// 非法</span></span><br><span class="line">cout &lt;&lt; pA-&gt;<span class="built_in">fn</span>(); <span class="comment">// 456, 会调用重写的版本</span></span><br></pre></td></tr></table></figure>

<h4 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h4><p>在用 <code>delete</code> 关键字释放派生类对象占用的内存时，如果用的是基类的指针，而且析构函数不是虚函数，派生类的析构函数就不会被调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">A</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">B</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A::~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A::~A&quot;</span>; &#125;</span><br><span class="line">B::~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B::~B&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">A *pA = <span class="keyword">new</span> B;</span><br><span class="line"><span class="keyword">delete</span> pA; <span class="comment">// &quot;A::~A&quot;, 没有调用 B 类的析构函数</span></span><br></pre></td></tr></table></figure>

<p>因此，只有析构函数是虚函数时，派生类的析构函数才会被调用。派生类的析构函数会进一步调用基类的析构函数，从而回收所有内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pA; <span class="comment">// &quot;B::~BA::~A&quot;, 调用了 B 类的析构函数</span></span><br></pre></td></tr></table></figure>

<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="抛出异常和捕获异常"><a href="#抛出异常和捕获异常" class="headerlink" title="抛出异常和捕获异常"></a>抛出异常和捕获异常</h4><p>在 <code>try</code> 语句块中可用 <code>throw</code> 语句抛出异常，抛出的异常可被 <code>catch</code> 语句块捕获。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span> (b &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> b;</span><br><span class="line">    cout &lt;&lt; a / b;</span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">int</span> e) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>catch</code> 语句块通常称为异常处理程序。<code>throw</code> 语句抛出的异常的类型必须和 <code>catch</code> 语句块要捕获的异常相同才会被捕获。如果没有合适的 <code>catch</code> 语句块，程序就会终止。</p>
<h4 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h4><p>抛出的异常通常是异常类的对象。不同的异常类用来标识不同的异常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DivideByZero</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DivideByZero</span>(string msg);</span><br><span class="line">    <span class="function">string <span class="title">getMessage</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string message;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DivideByZero::<span class="built_in">DivideByZero</span>(string msg): <span class="built_in">message</span>(msg) &#123;&#125;</span><br><span class="line"><span class="function">string <span class="title">DivideByZero::getMessage</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> message; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (b &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">DivideByZero</span>(<span class="string">&quot;divide by zero&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="built_in">catch</span> (DivideByZero e) &#123;</span><br><span class="line">    cout &lt;&lt; e.<span class="built_in">getMessage</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小括号中的参数可以省略，只保留类型名。</p>
<h4 id="多个-catch-语句块"><a href="#多个-catch-语句块" class="headerlink" title="多个 catch 语句块"></a>多个 <code>catch</code> 语句块</h4><p>一个 <code>try</code> 语句块后面可以跟上多个 <code>catch</code> 语句块，以便处理多种异常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="built_in">catch</span> (out_of_range e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="built_in">catch</span> (length_error e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="built_in">catch</span> (bad_alloc e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="built_in">catch</span> (...) &#123; <span class="comment">// 小括号中的 `...` 并不是说要省略什么</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小括号中只有 <code>...</code> 的 <code>catch</code> 语句块是默认的 <code>catch</code> 语句块，它可以捕获任意类型的异常，应该作为最后一个 <code>catch</code> 语句块。</p>
<h4 id="throw-列表"><a href="#throw-列表" class="headerlink" title="throw 列表"></a><code>throw</code> 列表</h4><p>在一个函数中可以只抛出异常而不捕获异常。这种情况下，主调函数要负责捕获异常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">DivideByZero</span>(<span class="string">&quot;divide by zero&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    cout &lt;&lt; <span class="built_in">divide</span>(a, b);</span><br><span class="line">&#125; <span class="built_in">catch</span> (DivideByZero e) &#123;</span><br><span class="line">    cout &lt;&lt; e.<span class="built_in">getMessage</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数应该在参数列表之后的 <code>throw</code> 列表中列出可能抛出的异常类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="title">throw</span> <span class="params">(DivideByZero)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">DivideByZero</span>(<span class="string">&quot;divide by zero&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有多个异常，则用逗号隔开，如 <code>throw (out_of_range, length_error, bad_alloc)</code>。</p>
<h2 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h2><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>模板是函数定义或类定义的模板。这类定义可以用模板的参数作为类型名。</p>
<h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><p><code>fn()</code> 函数用于交换两个 <code>int</code> 型变量的值。实际上，只要两个变量的类型相同，都可以用这个函数的算法来交换它们的值。变量的类型不应该被固定为 <code>int</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>借助模板就可以根据需要确定变量的类型。</p>
<p>模板以关键字 <code>template</code> 开头，后跟一对尖括号，即参数列表。类型参数用关键字 <code>class</code> 修饰。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">(T &amp;a, T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">fn</span>(a, b);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; b; <span class="comment">// 21</span></span><br></pre></td></tr></table></figure>

<p>调用模板定义的函数和调用其他函数没什么区别。很多编译器不支持模板函数声明。</p>
<h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4><p>类模板的语法和函数模板没什么区别。类模板的类型参数的用法和函数模板一致。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>();</span><br><span class="line">    ~<span class="built_in">Stack</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T elem)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T top;</span><br><span class="line">    vector&lt;T&gt; *pStack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在声明该类的对象时，类名之后要跟上类型实参的列表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">pop</span>(); <span class="comment">// 3</span></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">pop</span>(); <span class="comment">// 2</span></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">pop</span>(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>成员函数的定义同样要用函数模板，此时函数名之前的类型限定符之后也要跟上类型实参的列表，列表中的类型实参可以是模板的类型参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">Stack&lt;T&gt;::<span class="built_in">Stack</span>(): <span class="built_in">top</span>(<span class="number">0</span>), <span class="built_in">pStack</span>(<span class="keyword">new</span> vector&lt;T&gt;) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">Stack&lt;T&gt;::~<span class="built_in">Stack</span>() &#123; <span class="keyword">delete</span> pStack; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">push</span>(T elem)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (top &lt; pStack-&gt;<span class="built_in">size</span>())</span><br><span class="line">        (*pStack)[top] = elem;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pStack-&gt;<span class="built_in">push_back</span>(elem);</span><br><span class="line">    top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T Stack&lt;T&gt;::<span class="built_in">pop</span>() &#123; <span class="keyword">return</span> (*pStack)[--top]; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="标准模板库"><a href="#标准模板库" class="headerlink" title="标准模板库"></a>标准模板库</h3><p>标准模板库（Standard Template Library，STL）包含栈、队列等数据结构的实现。STL 中的类都是模板类，通常称为 <strong>容器类</strong>，因其用来容纳数据。<code>Vector</code> 类就是一种容器类。</p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>迭代器是在遍历数据结构时用来定位每个数据项的变量。数组下标和指针是最简单的迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂的迭代器是一个对象，但它用起来就像一个指针。每种容器类都有相应的迭代器类。容器类的 <code>begin()</code> 方法返回定位到第一个元素的迭代器，<code>end()</code> 方法返回一个标识，表示最后一个元素之后的位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator p;</span><br><span class="line"><span class="keyword">for</span> (p = v.<span class="built_in">begin</span>(); p != v.<span class="built_in">end</span>(); p++) &#123;</span><br><span class="line">    cout &lt;&lt; *p; <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用 <code>auto</code> 声明迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p = v.<span class="built_in">begin</span>(); p != v.<span class="built_in">end</span>(); p++) &#123;</span><br><span class="line">    cout &lt;&lt; *p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以把迭代器当作指针使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = v.<span class="built_in">begin</span>();</span><br><span class="line">cout &lt;&lt; p[<span class="number">2</span>]; <span class="comment">// 3</span></span><br><span class="line">cout &lt;&lt; *p;   <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>注意，<code>p[2]</code> 或 <code>*(p+2)</code> 返回新的迭代器而不修改原来的迭代器。</p>
<p>并非所有迭代器都支持 <code>++</code> <code>--</code> <code>[]</code> 三种运算。迭代器根据所支持的操作可分为三种：</p>
<ul>
<li>正向迭代器，支持 <code>++</code></li>
<li>双向迭代器，支持 <code>++</code> <code>--</code></li>
<li>随机访问迭代器，支持 <code>++</code> <code>--</code> <code>[]</code></li>
</ul>
<p>这三种迭代器都可以进一步分为常量迭代器和可变迭代器。它们的区别在于允不允许修改数据项。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator p = v.<span class="built_in">begin</span>();</span><br><span class="line">p[<span class="number">2</span>] = <span class="number">0</span>; <span class="comment">// 非法, p 是常量迭代器</span></span><br></pre></td></tr></table></figure>

<h5 id="逆向遍历"><a href="#逆向遍历" class="headerlink" title="逆向遍历"></a>逆向遍历</h5><p>支持双向迭代器的容器类的 <code>rbegin()</code> 方法返回定位到最后一个元素的迭代器，<code>rend()</code> 方法返回一个标识，表示第一个元素之前的位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::reverse_iterator rp;</span><br><span class="line"><span class="keyword">for</span> (rp = v.<span class="built_in">rbegin</span>(); rp != v.<span class="built_in">rend</span>(); rp++) &#123;</span><br><span class="line">    cout &lt;&lt; *rp; <span class="comment">// 321</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><h5 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h5><p>STL 中的顺序容器有向量 <code>vector</code>、双向链表 <code>list</code> 和双端队列 <code>deque</code> 三种。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; l;</span><br><span class="line">l.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">l.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">l.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p = l.<span class="built_in">begin</span>(); p != l.<span class="built_in">end</span>(); p++) &#123;</span><br><span class="line">    cout &lt;&lt; *p; <span class="comment">// 321</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺序容器的常用成员函数如下表所示：</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>push_back(elem)</code></td>
<td>在表尾插入新元素 <code>elem</code></td>
</tr>
<tr>
<td><code>push_front(elem)</code></td>
<td>在表头插入新元素 <code>elem</code></td>
</tr>
<tr>
<td><code>size()</code></td>
<td>返回元素个数</td>
</tr>
<tr>
<td><code>begin()</code></td>
<td>返回定位到第一个元素的迭代器</td>
</tr>
<tr>
<td><code>rbegin()</code></td>
<td>返回定位到最后一个元素的迭代器</td>
</tr>
<tr>
<td><code>end()</code></td>
<td>返回最后一个元素之后的位置的标识</td>
</tr>
<tr>
<td><code>rend()</code></td>
<td>返回第一个元素之前的位置的标识</td>
</tr>
<tr>
<td><code>insert(iterator, elem)</code></td>
<td>在迭代器 <code>iterator</code> 所定位的元素之前插入新元素 <code>iterator</code></td>
</tr>
<tr>
<td><code>erase(iterator)</code></td>
<td>删除迭代器 <code>iterator</code> 所定位的元素并返回定位到下一个元素的迭代器</td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>清空</td>
</tr>
<tr>
<td><code>front()</code></td>
<td>返回第一个元素的引用，相当于 <code>*(c.begin())</code></td>
</tr>
</tbody></table>
<blockquote>
<p>只有列表能保证迭代器不会因为删除或插入新元素而发生错位。</p>
</blockquote>
<p>所有模板类都定义了两个类型：<code>std::list&lt;int&gt;::size_type</code> 是<code>size()</code> 返回的类型，<code>std::list&lt;int&gt;::value_type</code> 是元素的类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt;::value_type value = l.<span class="built_in">front</span>();</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::size_type  size  = l.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>

<h5 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h5><p>容器类栈 <code>stack</code> 和队列 <code>queue</code> 的默认基础容器是 <code>deque</code>。要改变基础容器，需提供两个类型参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; s;</span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">top</span>(); <span class="comment">// 3</span></span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">top</span>(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>不管基础容器是什么，它们的用法是不变的。</p>
<p>栈的成员函数见下表：</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>size()</code></td>
<td>返回元素个数</td>
</tr>
<tr>
<td><code>empty()</code></td>
<td>判断栈是否为空</td>
</tr>
<tr>
<td><code>top()</code></td>
<td>返回栈顶元素的引用</td>
</tr>
<tr>
<td><code>push(elem)</code></td>
<td>入栈</td>
</tr>
<tr>
<td><code>pop()</code></td>
<td>出栈</td>
</tr>
</tbody></table>
<p>队列的成员函数见下表：</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>size()</code></td>
<td>返回元素个数</td>
</tr>
<tr>
<td><code>empty()</code></td>
<td>判断队列是否为空</td>
</tr>
<tr>
<td><code>back()</code></td>
<td>返回队尾元素的引用</td>
</tr>
<tr>
<td><code>push(elem)</code></td>
<td>入队</td>
</tr>
<tr>
<td><code>front()</code></td>
<td>返回队头元素的引用</td>
</tr>
<tr>
<td><code>pop()</code></td>
<td>出队</td>
</tr>
</tbody></table>
<p>它们的 <code>pop()</code> 方法都没有返回值。</p>
<h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h5><p>集合 <code>set</code> 要求每个元素都是独一无二的。插入元素时会忽略已经存在的元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">char</span>&gt; s;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="string">&#x27;b&#x27;</span>); <span class="comment">// 忽略</span></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> p = s.<span class="built_in">find</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">cout &lt;&lt; *p; <span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p = s.<span class="built_in">begin</span>(); p != s.<span class="built_in">end</span>(); p++) &#123;</span><br><span class="line">    cout &lt;&lt; *p; <span class="comment">// abc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>集合的常用成员函数见下表：</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>size()</code></td>
<td>返回元素个数</td>
</tr>
<tr>
<td><code>empty()</code></td>
<td>判断集合是否为空</td>
</tr>
<tr>
<td><code>insert(elem)</code></td>
<td>插入新元素 <code>elem</code></td>
</tr>
<tr>
<td><code>erase(elem)</code></td>
<td>删除值为 <code>elem</code> 的元素</td>
</tr>
<tr>
<td><code>erase(iterator)</code></td>
<td>删除迭代器 <code>iterator</code> 所定位的元素</td>
</tr>
<tr>
<td><code>find(elem)</code></td>
<td>查找值为 <code>elem</code> 的元素，返回定位到该元素的迭代器</td>
</tr>
</tbody></table>
<h5 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h5><p>映射 <code>map</code> 用来存储键值对。键名必须都是独一无二的。声明映射，要提供两个类型参数，一个指定键名的类型，一个指定键值的类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::map;</span><br><span class="line"></span><br><span class="line">map&lt;string, string&gt; passwd;</span><br></pre></td></tr></table></figure>

<p>映射使用 <code>pair</code> 对象来存储每一个键值对。<code>pair</code> 对象有两个公开成员变量，<code>first</code> 对应键名，<code>second</code> 对应键值。<code>pair</code> 类的头文件是 <code>utility</code>。</p>
<p>映射用来插入新键值对的 <code>insert()</code> 方法要求键值对是一个 <code>pair</code> 对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::pair;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;string, string&gt; <span class="title">user</span><span class="params">(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;123456&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> r = passwd.<span class="built_in">insert</span>(user);</span><br></pre></td></tr></table></figure>

<p><code>insert()</code> 方法返回一个新的表示插入结果的 <code>pair</code> 对象。若插入成功，则该 <code>pair</code> 对象的 <code>second</code> 为 <code>true</code>，而 <code>first</code> 是定位到新键值对的迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = r.first; <span class="comment">// 迭代器</span></span><br><span class="line"><span class="keyword">auto</span> u = *p;      <span class="comment">// 键值对</span></span><br><span class="line">cout &lt;&lt; u.first &lt;&lt; u.second; <span class="comment">// admin123456</span></span><br></pre></td></tr></table></figure>

<p>可以把映射当作数组使用。不过 <code>[]</code> 返回值是键值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;string, string&gt; <span class="title">user</span><span class="params">(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;123456&quot;</span>)</span></span>;</span><br><span class="line">passwd.<span class="built_in">insert</span>(user);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">passwd[<span class="string">&quot;admin&quot;</span>] = <span class="string">&quot;123456&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>映射的常用成员函数见下表：</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>size()</code></td>
<td>返回键值对个数</td>
</tr>
<tr>
<td><code>empty()</code></td>
<td>判断映射是否为空</td>
</tr>
<tr>
<td><code>insert(pair)</code></td>
<td>插入新键值对</td>
</tr>
<tr>
<td><code>erase()</code></td>
<td>根据键名删除键值对</td>
</tr>
<tr>
<td><code>find()</code></td>
<td>根据键名查找键值对，返回迭代器</td>
</tr>
</tbody></table>
<h5 id="容器的初始化和遍历"><a href="#容器的初始化和遍历" class="headerlink" title="容器的初始化和遍历"></a>容器的初始化和遍历</h5><p>可用 <strong>初始值列表</strong> 来初始化容器。初始值列表是将初始值置于大括号中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set&lt;string&gt; colors = &#123; <span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">map&lt;string, string&gt; passwd = &#123;</span><br><span class="line">    &#123; <span class="string">&quot;admin&quot;</span>, <span class="string">&quot;123456&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;Peter&quot;</span>, <span class="string">&quot;2333&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;John&quot;</span>,  <span class="string">&quot;666&quot;</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>遍历容器常用 <code>auto</code> 和 <code>for</code> 语句。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p: colors) &#123;</span><br><span class="line">    cout &lt;&lt; p; <span class="comment">// blue green red</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p: passwd) &#123;</span><br><span class="line">    cout &lt;&lt; p.first; <span class="comment">// John Peter admin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="专题"><a href="#专题" class="headerlink" title="专题"></a>专题</h2><h3 id="安全的数组"><a href="#安全的数组" class="headerlink" title="安全的数组"></a>安全的数组</h3><p>库 <code>array</code> 提供的模板类 <code>std::array</code> 实现了安全的数组。它有两个类型参数，一个指定元素类型，一个指定数组长度。<code>size()</code> 方法返回数组长度。元素的初值都为 0。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">cout &lt;&lt; arr.<span class="built_in">size</span>(); <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> &amp;elem: arr) &#123;</span><br><span class="line">    cout &lt;&lt; elem; <span class="comment">// 12300</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>正则表达式是用来描述模式字符串的一种方式。库 <code>regex</code> 为正则表达式提供支持。类 <code>regex</code> 的构造函数需要一个正则表达式作为参数。要用正则表达式，需借助原始字符串字面值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string pattern = <span class="string">R&quot;(bbccc)&quot;</span>;</span><br><span class="line"><span class="function">regex <span class="title">regExp</span><span class="params">(pattern)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>regex_match()</code> 函数用模式匹配目标字符串，只有目标字符串和模式匹配时才会返回 <code>true</code>；<code>regex_search()</code> 函数用模式匹配子串，只要目标字符串有一个子串和模式匹配就会返回 <code>true</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string line;</span><br><span class="line"><span class="built_in">getline</span>(cin, line); <span class="comment">// 输入 &quot;abbccc&quot;</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">regex_match</span>(line, regExp); <span class="comment">// 输出 0</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">regex_search</span>(line, regExp); <span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure>

<p><code>regex_search()</code> 函数的返回值是布尔型，不能反映子串的位置。要知道每个子串的位置，要用正则表达式迭代器。类 <code>sregex_iterator</code> 的构造函数的参数包括对字符串首尾的引用和正则表达式，它的默认构造函数返回一个表示结束的迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">regex <span class="title">regExp</span><span class="params">(<span class="string">R&quot;(\(?\d&#123;3&#125;\)?(-|\s)\d&#123;3&#125;(-|\s)\d&#123;4&#125;)&quot;</span>)</span></span>;</span><br><span class="line">string text = <span class="string">&quot;Call me at me desk phone (907) 867-5309 \</span></span><br><span class="line"><span class="string">or my cell phone 907-350-3491.&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">sregex_iterator <span class="title">p</span><span class="params">(text.begin(), text.end(), regExp)</span></span>;</span><br><span class="line">sregex_iterator end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p != end) &#123;</span><br><span class="line">    cout &lt;&lt; p-&gt;<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">    p++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (907) 867-5309</span></span><br><span class="line"><span class="comment">// 907-350-3491</span></span><br></pre></td></tr></table></figure>

<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>多线程编程要包含头文件 <code>thread</code>。<code>thread</code> 类的对象代表一个线程，它的构造函数的参数包括线程要调用的函数以及要传递给该函数的参数。要等待线程结束，调用它们的 <code>join()</code> 方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::thread;</span><br><span class="line"><span class="keyword">using</span> std::this_thread::get_id;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(fn, <span class="number">123</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(fn, <span class="number">456</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在线程调用的函数中，可用 <code>get_id()</code> 方法获取线程的 ID。</p>
<p>最终，两个线程的输出有可能相互打断。这是因为上下文切换有可能发生在线程的输出过程中。更致命的是，如果两个线程修改同一个全局变量，变量的值最终是不确定的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30000</span>; i++) n++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(fn)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(fn)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; n; <span class="comment">// n 的值不确定, 每次运行都会有不同的结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要避免两个线程相互干扰，要使用互斥锁。互斥锁用来锁定一段代码，防止两个线程同时调用这段代码。库 <code>mutex</code> 提供的类 <code>mutex</code> 实现了互斥锁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::mutex;</span><br><span class="line"></span><br><span class="line">mutex me;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    me.<span class="built_in">lock</span>();</span><br><span class="line">    ...</span><br><span class="line">    me.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>智能指针是对象的包装器，用来包装占用了自由存储空间的对象。它自动维护对象的引用计数，并在对象的引用计数归零时自动释放对象占用的内存空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::shared_ptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Node</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destroyed&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;Node&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Node)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fn</span>(); <span class="comment">// &quot;destroyed&quot;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;called&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>库 <code>filesystem</code> 是 C++17 新增的标准库。头文件是 <code>filesystem</code>，命名空间是 <code>std::filesystem</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> fs = std::filesystem;</span><br></pre></td></tr></table></figure>

<p>它由一系列函数和类组成。例如，类 <code>path</code> 用于表示路径，函数 <code>exists()</code> 用于检查路径表示的文件是否存在。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs::path mypath = <span class="string">&quot;./include/main.h&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (!fs::<span class="built_in">exists</span>(mypath)) &#123;</span><br><span class="line">  std::cerr &lt;&lt; <span class="string">&quot;No such file or directory\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>path</code> 类的 <code>filename()</code> 方法返回文件名；<code>extension()</code> 方法返回扩展名；<code>parent_path()</code> 方法返回父级目录名；<code>make_preferred()</code> 方法用于统一目录分隔符，在 Windows 上统一为 <code>\</code>；在类 Unix 上统一为 <code>/</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::wcout &lt;&lt; <span class="string">&quot;filename: &quot;</span> &lt;&lt; mypath.<span class="built_in">filename</span>().<span class="built_in">c_str</span>();       <span class="comment">// main.h</span></span><br><span class="line">std::wcout &lt;&lt; <span class="string">&quot;extension: &quot;</span> &lt;&lt; mypath.<span class="built_in">extension</span>().<span class="built_in">c_str</span>();     <span class="comment">// .h</span></span><br><span class="line">std::wcout &lt;&lt; <span class="string">&quot;parent_path: &quot;</span> &lt;&lt; mypath.<span class="built_in">parent_path</span>().<span class="built_in">c_str</span>(); <span class="comment">// ./include</span></span><br><span class="line">std::wcout &lt;&lt; mypath.<span class="built_in">make_preferred</span>().<span class="built_in">c_str</span>();                 <span class="comment">// .\include\main.h</span></span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>totravel
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://totravel.github.io/2022/04/05/2022-04-05-from-c-to-cplusplus/" title="从 C 语言到 C++">https://totravel.github.io/2022/04/05/2022-04-05-from-c-to-cplusplus/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-ND</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a>
              <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag"><i class="fa fa-tag"></i> 面向对象</a>
              <a href="/tags/%E9%87%8D%E8%BD%BD/" rel="tag"><i class="fa fa-tag"></i> 重载</a>
              <a href="/tags/%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0/" rel="tag"><i class="fa fa-tag"></i> 友元函数</a>
              <a href="/tags/%E8%99%9A%E5%87%BD%E6%95%B0/" rel="tag"><i class="fa fa-tag"></i> 虚函数</a>
              <a href="/tags/%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 泛型编程</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/01/30/2022-01-30-vuejs-reactivity/" rel="prev" title="Vue 3 响应式原理初探——从零开始实现响应式 API">
                  <i class="fa fa-chevron-left"></i> Vue 3 响应式原理初探——从零开始实现响应式 API
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/07/11/2022-07-11-modern-cmake-guide/" rel="next" title="现代 CMake 指南">
                  现代 CMake 指南 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">totravel</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.1/jquery.min.js" integrity="sha256-o88AwQnZB+VDvE9tvIXrMQaPlFFSUTR+nldQm1LuPXQ=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  


  <script src="/js/third-party/fancybox.js"></script>


  





</body>
</html>
