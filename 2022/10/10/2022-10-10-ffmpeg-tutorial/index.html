<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"totravel.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.13.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="FFmpeg 是一个开源的跨平台 C 语言音视频编解码和多媒体解封装库。">
<meta property="og:type" content="article">
<meta property="og:title" content="C 库 FFmpeg 入门指南">
<meta property="og:url" content="https://totravel.github.io/2022/10/10/2022-10-10-ffmpeg-tutorial/">
<meta property="og:site_name" content="旅行 · 之间">
<meta property="og:description" content="FFmpeg 是一个开源的跨平台 C 语言音视频编解码和多媒体解封装库。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-10-10T00:50:00.000Z">
<meta property="article:modified_time" content="2023-02-22T13:24:53.260Z">
<meta property="article:author" content="totravel">
<meta property="article:tag" content="C 语言">
<meta property="article:tag" content="FFmpeg">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://totravel.github.io/2022/10/10/2022-10-10-ffmpeg-tutorial/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":"","permalink":"https://totravel.github.io/2022/10/10/2022-10-10-ffmpeg-tutorial/","path":"2022/10/10/2022-10-10-ffmpeg-tutorial/","title":"C 库 FFmpeg 入门指南"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C 库 FFmpeg 入门指南 | 旅行 · 之间</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">旅行 · 之间</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">总是跌跌撞撞，到底是顺其自然还是无头苍蝇？傻傻分不清……</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">47</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">2</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">19</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96"><span class="nav-number">2.</span> <span class="nav-text">获取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E6%A1%A3"><span class="nav-number">3.</span> <span class="nav-text">文档</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA"><span class="nav-number">4.</span> <span class="nav-text">构建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C"><span class="nav-number">5.</span> <span class="nav-text">命令行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#API"><span class="nav-number">6.</span> <span class="nav-text">API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%B0%81%E8%A3%85"><span class="nav-number">6.1.</span> <span class="nav-text">解封装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E5%AA%92%E4%BD%93"><span class="nav-number">6.1.1.</span> <span class="nav-text">打开媒体</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#AVFormatContext"><span class="nav-number">6.1.1.1.</span> <span class="nav-text">AVFormatContext</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AVInputFormat"><span class="nav-number">6.1.1.2.</span> <span class="nav-text">AVInputFormat</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E6%B5%81"><span class="nav-number">6.1.2.</span> <span class="nav-text">检索流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#AVStream"><span class="nav-number">6.1.2.1.</span> <span class="nav-text">AVStream</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AVMediaType"><span class="nav-number">6.1.2.2.</span> <span class="nav-text">AVMediaType</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E7%A0%81"><span class="nav-number">6.2.</span> <span class="nav-text">解码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="nav-number">6.2.1.</span> <span class="nav-text">检索解码器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#AVCodecParameters"><span class="nav-number">6.2.1.1.</span> <span class="nav-text">AVCodecParameters</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AVCodec"><span class="nav-number">6.2.1.2.</span> <span class="nav-text">AVCodec</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="nav-number">6.2.2.</span> <span class="nav-text">打开解码器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#AVCodecContext"><span class="nav-number">6.2.2.1.</span> <span class="nav-text">AVCodecContext</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E7%A0%81%E6%B5%81"><span class="nav-number">6.2.3.</span> <span class="nav-text">解码流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#AVPacket"><span class="nav-number">6.2.3.1.</span> <span class="nav-text">AVPacket</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AVFrame"><span class="nav-number">6.2.3.2.</span> <span class="nav-text">AVFrame</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%BD%8D%E5%B8%A7"><span class="nav-number">6.2.4.</span> <span class="nav-text">定位帧</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B8%85%E7%A9%BA%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="nav-number">6.2.5.</span> <span class="nav-text">清空解码器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E5%B0%81%E8%A3%85"><span class="nav-number">6.3.</span> <span class="nav-text">转封装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0%E5%BB%BA%E5%AA%92%E4%BD%93"><span class="nav-number">6.3.1.</span> <span class="nav-text">新建媒体</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#AVOutputFormat"><span class="nav-number">6.3.1.1.</span> <span class="nav-text">AVOutputFormat</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0%E5%BB%BA%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-number">6.3.2.</span> <span class="nav-text">新建输出流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%E4%B8%BA%E5%AA%92%E4%BD%93%E6%96%87%E4%BB%B6"><span class="nav-number">6.3.3.</span> <span class="nav-text">封装为媒体文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E5%85%B7"><span class="nav-number">6.4.</span> <span class="nav-text">工具</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#av-dump-format"><span class="nav-number">6.4.1.</span> <span class="nav-text">av_dump_format()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F"><span class="nav-number">7.</span> <span class="nav-text">硬件加速</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AMD-AMF"><span class="nav-number">7.1.</span> <span class="nav-text">AMD AMF</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Intel-QSV"><span class="nav-number">7.2.</span> <span class="nav-text">Intel QSV</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NVIDIA-CUDA"><span class="nav-number">7.3.</span> <span class="nav-text">NVIDIA CUDA</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="totravel"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">totravel</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/totravel" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;totravel" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:totravel@foxmail.com" title="E-Mail → mailto:totravel@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_nd.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://totravel.github.io/2022/10/10/2022-10-10-ffmpeg-tutorial/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="totravel">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="旅行 · 之间">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C 库 FFmpeg 入门指南 | 旅行 · 之间">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C 库 FFmpeg 入门指南
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-10-10 08:50:00" itemprop="dateCreated datePublished" datetime="2022-10-10T08:50:00+08:00">2022-10-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-02-22 21:24:53" itemprop="dateModified" datetime="2023-02-22T21:24:53+08:00">2023-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a target="_blank" rel="noopener" href="https://ffmpeg.org/">FFmpeg</a> 是一个开源的跨平台 C 语言音视频编解码和多媒体解封装库，包含 3 个命令行工具：</p>
<ul>
<li><code>ffmpeg</code> 转码器</li>
<li><code>ffprobe</code> 分析器</li>
<li><code>ffplay</code> 播放器</li>
</ul>
<p>还有多个函数库，其中最主要的两个是：</p>
<ul>
<li><code>libavformat</code> 解封装模块，原生支持 MP4 等文件封装格式和 RTMP 等流媒体传输协议。</li>
<li><code>libavcodec</code> 编解码模块，原生支持 MPEG-4、M-JPEG 等视频流的编解码和 MP3、AAC 和 AC3 等音频流的编解码，可以集成第三方编解码器以支持更多的编解码，例如第三方 H.264 (AVC) 编解码器 OpenH264 和第三方 H.265 (HEVC) 编解码器 X265。</li>
</ul>
<h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><p>FFmpeg 的各个稳定版的源码可以从 FFmpeg 官网的下载。 官网还罗列了一些预编译的 FFmpeg 的下载链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.gyan.dev/ffmpeg/builds/">Windows builds from gyan.dev</a><ul>
<li><code>ffmpeg-5.1.2-essentials_build.7z</code> 只包含命令行工具</li>
<li><code>ffmpeg-5.1.2-full_build-shared.7z</code> 包含命令行工具、库和头文件</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://github.com/BtbN/FFmpeg-Builds/releases">BtbN</a><ul>
<li><code>ffmpeg-n5.1-latest-win64-gpl-5.1.zip</code> 只包含命令行工具</li>
<li><code>ffmpeg-n5.1-latest-win64-gpl-shared-5.1.zip</code> 包含命令行工具、库和头文件</li>
</ul>
</li>
</ul>
<p>FFmpeg 没有提供 <code>CMakeLists.txt</code> 文件，也没有提供 <code>*.vcxproj</code> 文件，只提供一个 <code>Makefile</code> 文件，这意味着无法直接用 Visual Studio 来构建 FFmpeg。为了减少在 Windows 上构建 FFmpeg 的麻烦，有人发起了 <a target="_blank" rel="noopener" href="https://github.com/ShiftMediaProject/FFmpeg">Shift Media Project</a> 项目，专门为 FFmpeg 制作 <code>*.vcxproj</code> 文件（见 <code>SMP</code> 子文件夹），同时也提供预编译的 FFmpeg 下载（见发布页）。</p>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>由于 FFmpeg 分成很多模块，每个模块都有很多功能，因此，FFmpeg 的 <a target="_blank" rel="noopener" href="https://ffmpeg.org/documentation.html">文档</a> 也分成很多部分。其中比较常用的有下列几个：</p>
<ul>
<li>Command Line Tools Documentation，介绍各个命令行工具的用法</li>
<li>Components Documentation，各个功能部件的参数的解释</li>
<li>General Documentation<ul>
<li><a target="_blank" rel="noopener" href="https://ffmpeg.org/faq.html">Frequently Asked Questions</a> 常见问题</li>
<li><a target="_blank" rel="noopener" href="https://ffmpeg.org/general.html">Supported External Libraries, Formats, Codecs or Features</a>，介绍 FFmpeg 集成第三方库的方法</li>
<li><a target="_blank" rel="noopener" href="https://ffmpeg.org/platform.html">Platform Specific Information</a>，FFmpeg 在不同平台的构建方法</li>
</ul>
</li>
<li>Community Contributed Documentation<ul>
<li><a target="_blank" rel="noopener" href="https://trac.ffmpeg.org/wiki">Official FFmpeg Wiki</a><ul>
<li><a target="_blank" rel="noopener" href="https://trac.ffmpeg.org/wiki/CompilationGuide/Generic">Generic Compilation Guide</a>，通用编译指南</li>
<li><a target="_blank" rel="noopener" href="https://trac.ffmpeg.org/wiki/CompilationGuide">FFmpeg Compilation Guides</a>，各个平台的编译指南</li>
<li><a target="_blank" rel="noopener" href="https://trac.ffmpeg.org/wiki/HWAccelIntro">Hardware acceleration introduction with FFmpeg</a>，介绍 FFmpeg 对各种硬件加速平台的支持</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>FFmpeg 的编译选项可以用命令 <code>./configure -h</code> 查看。常用选项如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 工具链</span></span><br><span class="line">--toolchain=msvc <span class="comment"># 工具链</span></span><br><span class="line">--host-os=win64  <span class="comment"># or win32</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 标准</span></span><br><span class="line">--prefix=install <span class="comment"># 安装路径</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 授权</span></span><br><span class="line">--enable-gpl      <span class="comment"># 启用 GPL 协议</span></span><br><span class="line">--enable-version3 <span class="comment"># 启用 LGPL3 协议</span></span><br><span class="line">--enable-nonfree  <span class="comment"># 启用付费代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建配置</span></span><br><span class="line">--disable-static            <span class="comment"># 不要静态库</span></span><br><span class="line">--enable-shared             <span class="comment"># 要动态库</span></span><br><span class="line">--enable-small              <span class="comment"># 针对体积优化</span></span><br><span class="line">--disable-runtime-cpudetect <span class="comment"># 不要在运行时检测 CPU 性能</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令行工具</span></span><br><span class="line">--disable-programs <span class="comment"># 禁用所有命令行工具</span></span><br><span class="line">--disable-ffmpeg   <span class="comment"># 禁用 ffmpeg</span></span><br><span class="line">--disable-ffplay   <span class="comment"># 禁用 ffplay</span></span><br><span class="line">--disable-ffprobe  <span class="comment"># 禁用 ffprobe</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文档</span></span><br><span class="line">--disable-doc <span class="comment"># 禁用所有文档</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模块</span></span><br><span class="line">--disable-avcodec</span><br><span class="line">--disable-avformat</span><br><span class="line">--disable-avfilter</span><br><span class="line">--disable-swresample</span><br><span class="line">--disable-swscale</span><br><span class="line">--disable-avdevice</span><br><span class="line">--disable-postproc <span class="comment"># 启用 postproc，需同时启用 GPL 协议，见 --enable-gpl 选项</span></span><br><span class="line">--disable-network  <span class="comment"># 禁用网络</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 独立模块</span></span><br><span class="line">--disable-everything <span class="comment"># 禁用所有独立模块</span></span><br><span class="line"></span><br><span class="line">--enable-encoder=aac,ac3     <span class="comment"># 启用 AAC、AC3 编码器</span></span><br><span class="line">--enable-encoder=mpeg4,mjpeg <span class="comment"># 启用 MPEG-4、M-JPEG 编码器</span></span><br><span class="line">--enable-encoder=libopenh264 <span class="comment"># 启用 OpenH264 作为 H.264 编码器</span></span><br><span class="line"></span><br><span class="line">--enable-decoder=aac,ac3,eac3,mp3 <span class="comment"># 启用 AAC、AC3、MP3 解码器</span></span><br><span class="line">--enable-decoder=mpeg4,mjpeg      <span class="comment"># 启用 MPEG-4、M-JPEG 解码器</span></span><br><span class="line">--enable-decoder=h264             <span class="comment"># 启用内置的 H.264 解码器</span></span><br><span class="line"></span><br><span class="line">--enable-muxer=mp4,avi   <span class="comment"># 启用 AVI、MP4 封装器</span></span><br><span class="line">--enable-demuxer=mov,avi <span class="comment"># 启用 AVI、MP4 解封器</span></span><br><span class="line"><span class="comment"># mov 和 mp4 是同一个解封器，都是 mov,mp4,m4a,3gp,3g2,mj2</span></span><br><span class="line"></span><br><span class="line">--enable-protocol=file <span class="comment"># 启用媒体文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三方库</span></span><br><span class="line">--enable-libopenh264 <span class="comment"># 集成 OpenH264 以支持 H.264 编码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发</span></span><br><span class="line">--disable-debug <span class="comment"># 禁用调试符号</span></span><br></pre></td></tr></table></figure>

<p>可以用下列命令查看 FFmpeg 支持的所有解封装器、编解码器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./configure --list-encoders</span><br><span class="line">./configure --list-decoders</span><br><span class="line"></span><br><span class="line">./configure --list-muxers</span><br><span class="line">./configure --list-demuxers</span><br></pre></td></tr></table></figure>

<p>FFmpeg 已经实现 H.264 解码器，但没有实现 H.264 编码器。</p>
<h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><p>要查看编译好的 FFmpeg 支持的解封装器、编解码器，可以使用命令行工具 <code>ffmpeg</code> 的下列选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./ffmpeg -muxers   <span class="comment"># 查看 FFmpeg 支持封装的格式</span></span><br><span class="line">./ffmpeg -demuxers <span class="comment"># 查看 FFmpeg 支持解封的格式</span></span><br><span class="line">./ffmpeg -decoders <span class="comment"># 查看 FFmpeg 支持的解码器</span></span><br><span class="line">./ffmpeg -encoders <span class="comment"># 查看 FFmpeg 支持的编码器</span></span><br></pre></td></tr></table></figure>

<p>可以用命令行工具 <code>ffmpeg</code> 进行一次转码，以验证刚编译好的 FFmpeg 能否工作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ffmpeg -i input.mp4 -vcodec h264 -acodec aac -r 30 -b 1000k output.mp4</span><br></pre></td></tr></table></figure>

<p><code>-vcodec</code> 和 <code>-acodec</code> 分别用于指定视频编码格式和音频编码格式，没有指定则使用封装格式默认的编码格式。</p>
<p>某种解封装器、编解码器的详细信息可以用 <code>-h</code> 选项查看。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./ffmpeg -h muxer=mp4    <span class="comment"># 查看封装器 MP4</span></span><br><span class="line">./ffmpeg -h demuxer=mov  <span class="comment"># 查看解封器 MOV</span></span><br><span class="line">./ffmpeg -h decoder=aac  <span class="comment"># 查看解码器 AAC</span></span><br><span class="line">./ffmpeg -h encoder=h264 <span class="comment"># 查看编码器 H264</span></span><br></pre></td></tr></table></figure>

<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>可以通过 API 获取 FFmpeg 的编译选项：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libavformat/avformat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libavcodec/avcodec.h&quot;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">avcodec_configuration</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解封装"><a href="#解封装" class="headerlink" title="解封装"></a>解封装</h3><h4 id="打开媒体"><a href="#打开媒体" class="headerlink" title="打开媒体"></a>打开媒体</h4><h5 id="AVFormatContext"><a href="#AVFormatContext" class="headerlink" title="AVFormatContext"></a>AVFormatContext</h5><p>打开媒体要用 <code>avformat_open_input()</code> 函数。在那之前，要先准备一个 <code>AVFormatContext</code> 结构，用于包含解封装操作的上下文。<code>avformat_open_input()</code> 函数负责分配内存并填充其中几个字段。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AVFormatContext* ifmt_ctx = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">avformat_open_input</span>(&amp;ifmt_ctx, <span class="string">&quot;video.mp4&quot;</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  std::cerr &lt;&lt; <span class="string">&quot;Cannot open input file\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">avformat_close_input</span>(&amp;ifmt_ctx);</span><br></pre></td></tr></table></figure>

<p><code>AVFormatContext</code> 结构的内存也可以用 <code>avformat_alloc_context()</code> 函数事先分配，但最后都要用 <code>avformat_close_input()</code> 函数释放。</p>
<p>媒体不一定来源于文件，也有可能来源于网络，也就是流媒体。因此，<code>avformat_open_input()</code> 函数的第二个参数有可能是流媒体的 URL，也有可能是媒体文件的路径。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Input url: &quot;</span> &lt;&lt; ifmt_ctx-&gt;url &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>媒体文件的解封装操作包含文件 I&#x2F;O 操作。文件 I&#x2F;O 操作的上下文由 <code>AVFormatContext</code> 结构的 <code>pb</code> 成员指示。打开媒体文件时，<code>avformat_open_input()</code> 函数自动调用 <code>avio_open()</code> 函数打开文件；关闭媒体文件时，<code>avformat_close_input()</code> 函数自动调用 <code>avio_closep()</code> 函数释放资源。</p>
<h5 id="AVInputFormat"><a href="#AVInputFormat" class="headerlink" title="AVInputFormat"></a>AVInputFormat</h5><p><code>AVFormatContext</code> 结构的 <code>iformat</code> 成员是一个 <code>AVInputFormat</code> 结构，它表示输入媒体的封装格式，其 <code>name</code> 字段是封装格式的名称。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> AVInputFormat* ifmt = ifmt_ctx-&gt;iformat;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Input format: &quot;</span> &lt;&lt; ifmt-&gt;name; <span class="comment">// &quot;mov,mp4,m4a,3gp,3g2,mj2&quot;</span></span><br></pre></td></tr></table></figure>

<p>实际上，<code>avformat_open_input()</code> 函数就可以接受一个 <code>AVFormatContext</code> 结构作为第三个参数，用于强制指定媒体文件的封装格式，设为 <code>nullptr</code> 则由 FFmpeg 自动识别（根据扩展名和文件头部）。</p>
<h4 id="检索流"><a href="#检索流" class="headerlink" title="检索流"></a>检索流</h4><h5 id="AVStream"><a href="#AVStream" class="headerlink" title="AVStream"></a>AVStream</h5><p>在打开媒体文件之后，要用 <code>avformat_find_stream_info()</code> 函数获取视频流和音频流的列表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret = <span class="built_in">avformat_find_stream_info</span>(ifmt_ctx, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  std::cerr &lt;&lt; <span class="string">&quot;Cannot find stream information\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AVFormatContext</code> 结构的 <code>nb_streams</code> 成员指示流的数量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Number of streams: &quot;</span> &lt;&lt; ifmt_ctx-&gt;nb_streams;</span><br></pre></td></tr></table></figure>

<p><code>nb_streams</code> 成员同时也是 <code>streams</code> 成员的长度。<code>streams</code> 成员是 <code>AVStream</code> 结构的列表。每个 <code>AVStream</code> 结构表示一个流，其中包含流的信息，如时间基（单位秒）、时长（以时间基为单位）和帧数等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AVStream* stream = ifmt_ctx-&gt;streams[<span class="number">0</span>];</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Time base: &quot;</span> &lt;&lt; stream-&gt;time_base.num &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; stream-&gt;time_base.den;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Duration: &quot;</span> &lt;&lt; stream-&gt;duration;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Number of frames: &quot;</span> &lt;&lt; stream-&gt;nb_frames;</span><br></pre></td></tr></table></figure>

<p>时间基是一个分数。分数都用一个 <code>AVRational</code> 结构表示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVRational</span>&#123;</span><br><span class="line">  <span class="type">int</span> num; <span class="comment">///&lt; Numerator</span></span><br><span class="line">  <span class="type">int</span> den; <span class="comment">///&lt; Denominator</span></span><br><span class="line">&#125; AVRational;</span><br></pre></td></tr></table></figure>

<p>有了以上三项信息，就可以计算流的平均帧率：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> time_base = <span class="number">1.0</span> * stream-&gt;time_base.num / stream-&gt;time_base.den;</span><br><span class="line"><span class="type">double</span> duration  = stream-&gt;duration * time_base;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Frame rate: &quot;</span> &lt;&lt; stream-&gt;nb_frames / duration;</span><br></pre></td></tr></table></figure>

<p>可以用 <code>av_find_best_stream()</code> 函数获取指定类型的流的索引。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> video_stream_index = <span class="built_in">av_find_best_stream</span>(ifmt_ctx, AVMEDIA_TYPE_VIDEO, </span><br><span class="line">                                             <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (video_stream_index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  std::cerr &lt;&lt; <span class="string">&quot;av_find_best_stream() failed\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="AVMediaType"><a href="#AVMediaType" class="headerlink" title="AVMediaType"></a>AVMediaType</h5><p>第 2 个参数是枚举类型 <code>AVMediaType</code>，用于指示流的类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">AVMediaType</span> &#123;</span><br><span class="line">  AVMEDIA_TYPE_UNKNOWN = <span class="number">-1</span>,  <span class="comment">///&lt; Usually treated as AVMEDIA_TYPE_DATA</span></span><br><span class="line">  AVMEDIA_TYPE_VIDEO,</span><br><span class="line">  AVMEDIA_TYPE_AUDIO,</span><br><span class="line">  AVMEDIA_TYPE_DATA,          <span class="comment">///&lt; Opaque data information usually continuous</span></span><br><span class="line">  AVMEDIA_TYPE_SUBTITLE,</span><br><span class="line">  AVMEDIA_TYPE_ATTACHMENT,    <span class="comment">///&lt; Opaque data information usually sparse</span></span><br><span class="line">  AVMEDIA_TYPE_NB</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以用 <code>av_get_media_type_string()</code> 函数获取类型的名称。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="built_in">av_get_media_type_string</span>(AVMEDIA_TYPE_VIDEO);    <span class="comment">// &quot;video&quot;</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">av_get_media_type_string</span>(AVMEDIA_TYPE_SUBTITLE); <span class="comment">// &quot;subtitle&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><h4 id="检索解码器"><a href="#检索解码器" class="headerlink" title="检索解码器"></a>检索解码器</h4><h5 id="AVCodecParameters"><a href="#AVCodecParameters" class="headerlink" title="AVCodecParameters"></a>AVCodecParameters</h5><p><code>AVStream</code> 结构的 <code>codecpar</code> 成员是一个 <code>AVCodecParameters</code> 结构，包含流的编解码参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVCodecParameters* decode_para = video_stream-&gt;codecpar;</span><br></pre></td></tr></table></figure>

<p><code>AVCodecParameters</code> 结构的 <code>codec_type</code> 成员是枚举类型 <code>AVMediaType</code>。</p>
<p>流的比特率由 <code>bit_rate</code> 成员指示；视频的宽高分别由 <code>width</code> 和 <code>height</code> 两个成员指示；音频的采样率由 <code>sample_rate</code> 成员指示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (decode_para-&gt;codec_type == AVMEDIA_TYPE_VIDEO || </span><br><span class="line">    decode_para-&gt;codec_type == AVMEDIA_TYPE_AUDIO) </span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Bit rate: &quot;</span> &lt;&lt; decode_para-&gt;bit_rate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (decode_para-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Width: &quot;</span>  &lt;&lt; decode_para-&gt;width;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Height: &quot;</span> &lt;&lt; decode_para-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (decode_para-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Sampling rate: &quot;</span> &lt;&lt; decode_para-&gt;sample_rate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>视频的像素格式或音频的采样格式由 <code>format</code> 成员指示，对应的枚举类型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">AVSampleFormat</span> &#123;</span><br><span class="line">  AV_SAMPLE_FMT_NONE = <span class="number">-1</span>,</span><br><span class="line">  AV_SAMPLE_FMT_U8,   <span class="comment">///&lt; unsigned 8 bits</span></span><br><span class="line">  AV_SAMPLE_FMT_S16,  <span class="comment">///&lt; signed 16 bits</span></span><br><span class="line">  AV_SAMPLE_FMT_S32,  <span class="comment">///&lt; signed 32 bits</span></span><br><span class="line">  AV_SAMPLE_FMT_FLT,  <span class="comment">///&lt; float</span></span><br><span class="line">  AV_SAMPLE_FMT_DBL,  <span class="comment">///&lt; double</span></span><br><span class="line"></span><br><span class="line">  AV_SAMPLE_FMT_U8P,  <span class="comment">///&lt; unsigned 8 bits, planar</span></span><br><span class="line">  AV_SAMPLE_FMT_S16P, <span class="comment">///&lt; signed 16 bits, planar</span></span><br><span class="line">  AV_SAMPLE_FMT_S32P, <span class="comment">///&lt; signed 32 bits, planar</span></span><br><span class="line">  AV_SAMPLE_FMT_FLTP, <span class="comment">///&lt; float, planar</span></span><br><span class="line">  AV_SAMPLE_FMT_DBLP, <span class="comment">///&lt; double, planar</span></span><br><span class="line">  AV_SAMPLE_FMT_S64,  <span class="comment">///&lt; signed 64 bits</span></span><br><span class="line">  AV_SAMPLE_FMT_S64P, <span class="comment">///&lt; signed 64 bits, planar</span></span><br><span class="line"></span><br><span class="line">  AV_SAMPLE_FMT_NB    <span class="comment">///&lt; Number of sample formats. DO NOT USE if linking dynamically</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">AVPixelFormat</span> &#123;</span><br><span class="line">  AV_PIX_FMT_NONE = <span class="number">-1</span>,</span><br><span class="line">  AV_PIX_FMT_YUV420P,</span><br><span class="line">  AV_PIX_FMT_YUYV422,</span><br><span class="line">  AV_PIX_FMT_RGB24,</span><br><span class="line">  AV_PIX_FMT_BGR24,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="AVCodec"><a href="#AVCodec" class="headerlink" title="AVCodec"></a>AVCodec</h5><p><code>codec_id</code> 成员是枚举类型 <code>AVCodecID</code>，它是编解码器的标识。用 <code>avcodec_find_decoder()</code> 函数获取编解码器时，要用它作为参数。编解码器用 <code>AVCodec</code> 结构表示，该结构的 <code>name</code> 成员是编解码器的名称。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (decode_para-&gt;codec_type == AVMEDIA_TYPE_VIDEO || </span><br><span class="line">    decode_para-&gt;codec_type == AVMEDIA_TYPE_AUDIO) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> AVCodec* decoder = <span class="built_in">avcodec_find_decoder</span>(decode_para-&gt;codec_id);</span><br><span class="line">  <span class="keyword">if</span> (decoder == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;avcodec_find_decoder() failed\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Decoder: &quot;</span> &lt;&lt; decoder-&gt;name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="打开解码器"><a href="#打开解码器" class="headerlink" title="打开解码器"></a>打开解码器</h4><h5 id="AVCodecContext"><a href="#AVCodecContext" class="headerlink" title="AVCodecContext"></a>AVCodecContext</h5><p>在编解码前，要准备一个 <code>AVCodecContext</code> 结构，用于保存编解码操作的上下文。<code>AVCodecContext</code> 结构的内存要用 <code>avcodec_alloc_context3()</code> 函数分配，用函数 <code>avcodec_free_context()</code> 释放，它的内容要用 <code>avcodec_parameters_to_context()</code> 函数从 <code>AVCodecParameters</code> 结构复制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AVCodecContext* decode_ctx = <span class="built_in">avcodec_alloc_context3</span>(decoder);</span><br><span class="line"><span class="keyword">if</span> (decode_ctx == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  std::cerr &lt;&lt; <span class="string">&quot;avcodec_alloc_context3() failed\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">ret = <span class="built_in">avcodec_parameters_to_context</span>(decode_ctx, decode_para);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  std::cerr &lt;&lt; <span class="string">&quot;avcodec_parameters_to_context() failed\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">avcodec_free_context</span>(&amp;decode_ctx);</span><br></pre></td></tr></table></figure>

<p>准备好 <code>AVCodecContext</code> 结构后，就可以用 <code>avcodec_open2()</code> 函数来打开编解码器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret = <span class="built_in">avcodec_open2</span>(decode_ctx, decoder, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  std::cerr &lt;&lt; <span class="string">&quot;avcodec_open2() failed\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解码流"><a href="#解码流" class="headerlink" title="解码流"></a>解码流</h4><p>流是由数据包组成的。数据包是经过编码压缩的数据帧。数据包和数据帧分别用 <code>AVPacket</code> 和 <code>AVFrame</code> 结构表示。在编解码时，要准备好这两个结构。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AVPacket* packet = <span class="built_in">av_packet_alloc</span>();</span><br><span class="line">AVFrame* frame = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line"><span class="keyword">if</span> (packet == <span class="literal">nullptr</span> || frame == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  std::cerr &lt;&lt; <span class="string">&quot;av_packet_alloc() or av_frame_alloc() failed\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">av_packet_free</span>(&amp;packet);</span><br><span class="line"><span class="built_in">av_frame_free</span>(&amp;frame);</span><br></pre></td></tr></table></figure>

<p>数据包可以用 <code>av_read_frame()</code> 函数从媒体文件中获取。数据包来自哪个流要通过检查 <code>AVPacket</code> 结构的 <code>stream_index</code> 成员才能确定。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">av_read_frame</span>(ifmt_ctx, packet) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (packet-&gt;stream_index == video_stream_index) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">av_packet_unref</span>(packet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在获取下一个数据包之前，都要用 <code>av_packet_unref()</code> 函数重置 <code>AVPacket</code> 结构。</p>
<p>解码时需要反复调用 <code>av_read_frame()</code> 函数从媒体文件读取数据包。解码的过程是先调用 <code>avcodec_send_packet()</code> 函数将数据包发送给解码器，再调用 <code>avcodec_receive_frame()</code> 函数从解码器接收数据帧的过程。注意，并非每发送一个数据包就能接收一个数据帧，也不是每次都只能接收一个数据帧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">av_read_frame</span>(ifmt_ctx, packet) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (packet-&gt;stream_index == video_stream_index) &#123;</span><br><span class="line">    ret = <span class="built_in">avcodec_send_packet</span>(decode_ctx, packet);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      std::cerr &lt;&lt; <span class="string">&quot;avcodec_send_packet() failed\n&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      ret = <span class="built_in">avcodec_receive_frame</span>(decode_ctx, frame);</span><br><span class="line">      <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ret == AVERROR_EOF || ret == <span class="built_in">AVERROR</span>(EAGAIN)) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;avcodec_receive_frame() failed\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="built_in">av_frame_unref</span>(frame);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">av_packet_unref</span>(packet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="AVPacket"><a href="#AVPacket" class="headerlink" title="AVPacket"></a>AVPacket</h5><p>每个数据包都有下列成员：</p>
<ul>
<li><code>time_base</code> 时间基，时间戳的单位。未来，在解封装或编码时可能会设置该字段，但是在封装或解码时总是忽略该字段。</li>
<li><code>dts</code> 解码时间戳，即解码该帧的时机，以 <code>AVStream::time_base</code> 为单位，下同。</li>
<li><code>pts</code> 显示时间戳，即显示该帧的时机。</li>
<li><code>duration</code> 显示时长，即显示该帧的时长，它等于下一帧的 <code>pts</code> 与该帧的 <code>pts</code> 的差。</li>
</ul>
<h5 id="AVFrame"><a href="#AVFrame" class="headerlink" title="AVFrame"></a>AVFrame</h5><p>每个数据帧都有下列成员：</p>
<ul>
<li><code>time_base</code> 时间基，时间戳的单位。未来，在解码时可能会设置该字段，但是在编码时总是忽略该字段。</li>
<li><code>pts</code> 显示时间戳，即显示该帧的时机，以 <code>AVCodecContext::time_base</code> 为单位，下同。</li>
<li><code>pkt_dts</code> 解码时间戳，从 <code>AVPacket</code> 拷贝而来。</li>
<li><code>key_frames</code> 是否为关键帧。</li>
<li><code>pict_type</code> 帧的类型，<code>0</code>、<code>1</code>、<code>2</code> 分别代表 I 帧、P 帧和 B 帧。</li>
<li><code>format</code> 像素格式，最常用的是 <code>AV_PIX_FMT_YUV420P</code>。</li>
</ul>
<p><code>AVFrame</code> 结构的 <code>data</code> 成员是 8 个图像数据的指针，因此它最多可以保存 8 个图像分量。当图像数据以打包格式存储时，只有 <code>data[0]</code> 有效；以平面格式存储时，只有 <code>data[0]</code> <code>data[1]</code> <code>data[2]</code> 有效，分别对应 <code>Y</code> <code>U</code> <code>V</code> 分量。</p>
<h4 id="定位帧"><a href="#定位帧" class="headerlink" title="定位帧"></a>定位帧</h4><p><code>av_read_frame()</code> 函数总是按照数据帧在文件中的存储顺序读取下一个数据帧。如果要打破这种顺序，就要借助 <code>av_seek_frame()</code> 函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_seek_frame</span><span class="params">(AVFormatContext *s, <span class="type">int</span> stream_index, <span class="type">int64_t</span> timestamp, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>flags</code> 决定跳转的方向和方式，有下列取值可选：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AVSEEK_FLAG_BACKWARD 1 <span class="comment">///&lt; seek backward</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AVSEEK_FLAG_BYTE     2 <span class="comment">///&lt; seeking based on position in bytes</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AVSEEK_FLAG_ANY      4 <span class="comment">///&lt; seek to any frame, even non-keyframes</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AVSEEK_FLAG_FRAME    8 <span class="comment">///&lt; seeking based on frame number</span></span></span><br></pre></td></tr></table></figure>

<p>比如回到视频的开头：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">av_seek_frame</span>(ifmt_ctx, <span class="number">0</span>, <span class="number">0</span>, AVSEEK_FLAG_BACKWARD);</span><br></pre></td></tr></table></figure>

<h4 id="清空解码器"><a href="#清空解码器" class="headerlink" title="清空解码器"></a>清空解码器</h4><p>读取到媒体文件的末尾时，<code>av_read_frame()</code> 函数将返回 <code>AVERROR_EOF</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((ret = <span class="built_in">av_read_frame</span>(ifmt_ctx, packet)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ret != AVERROR_EOF) &#123;</span><br><span class="line">  std::cerr &lt;&lt; <span class="string">&quot;av_read_frame() failed\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时要继续向解码器发送一个空的数据包，以便解码并取回解码器中剩余的所有数据帧。</p>
<h3 id="转封装"><a href="#转封装" class="headerlink" title="转封装"></a>转封装</h3><h4 id="新建媒体"><a href="#新建媒体" class="headerlink" title="新建媒体"></a>新建媒体</h4><p>要将流封装成新的媒体，需要准备一个 <code>AVFormatContext</code> 结构来保存封装操作的上下文。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AVFormatContext* ofmt_ctx = <span class="literal">nullptr</span>;</span><br><span class="line">ret = <span class="built_in">avformat_alloc_output_context2</span>(&amp;ofmt_ctx, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="string">&quot;output.mkv&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  std::cerr &lt;&lt; <span class="string">&quot;avformat_alloc_output_context2() failed\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">avformat_free_context</span>(ofmt_ctx);</span><br></pre></td></tr></table></figure>

<h5 id="AVOutputFormat"><a href="#AVOutputFormat" class="headerlink" title="AVOutputFormat"></a>AVOutputFormat</h5><p><code>AVFormatContext</code> 结构的 <code>oformat</code> 成员是一个 <code>AVOutputFormat</code> 结构，它表示输出媒体的封装格式，其 <code>name</code> 字段是封装格式的名称。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> AVOutputFormat* ofmt = ofmt_ctx-&gt;oformat;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Output format: &quot;</span> &lt;&lt; ofmt-&gt;name;</span><br></pre></td></tr></table></figure>

<p>对于需要进行文件 I&#x2F;O 操作的封装格式来说，还需要用 <code>avio_open()</code> 函数准备好文件 I&#x2F;O 操作的上下文。封装格式是否需要文件 I&#x2F;O 操作可以通过检查 <code>AVOutputFormat</code> 结构的 <code>flags</code> 成员确定。表示无需文件 I&#x2F;O 操作的标志是 <code>AVFMT_NOFILE</code> 宏。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(ofmt-&gt;flags &amp; AVFMT_NOFILE)) &#123;</span><br><span class="line">  <span class="comment">// Format wants file</span></span><br><span class="line">  ret = <span class="built_in">avio_open</span>(&amp;ofmt_ctx-&gt;pb, filename, AVIO_FLAG_WRITE);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;&#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;avio_open() failed\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(ofmt_ctx-&gt;oformat-&gt;flags &amp; AVFMT_NOFILE)) &#123;</span><br><span class="line">  <span class="built_in">avio_closep</span>(&amp;ofmt_ctx-&gt;pb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="新建输出流"><a href="#新建输出流" class="headerlink" title="新建输出流"></a>新建输出流</h4><p>新建流用 <code>avformat_new_stream()</code> 函数。如果没有对流进行转码，输出流的编码参数可以直接用 <code>avcodec_parameters_copy()</code> 函数从输入流复制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AVStream* ostream = <span class="built_in">avformat_new_stream</span>(ofmt_ctx, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (ostream == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  std::cerr &lt;&lt; <span class="string">&quot;avformat_new_stream() failed\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">avcodec_parameters_copy</span>(ostream-&gt;codecpar, istream-&gt;codecpar);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  std::cerr &lt;&lt; <span class="string">&quot;avcodec_parameters_copy() failed\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改变封装格式时，有些编码参数可能不通用，需要重置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ostream-&gt;codecpar-&gt;codec_tag = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>如果不想把输入媒体的每个流都封装到新的媒体中，还需要建立一个流的映射表。映射表把输入流的索引为输出流的索引，可以用一个整型数组实现。比如，只保留视频流和音频流：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *stream_mapping = (<span class="type">int</span> *)<span class="built_in">av_calloc</span>(ifmt_ctx-&gt;nb_streams, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span> (stream_mapping == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  std::cerr &lt;&lt; <span class="string">&quot;av_calloc() failed\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ifmt_ctx-&gt;nb_streams; i++) &#123;</span><br><span class="line">  AVStream* istream = ifmt_ctx-&gt;streams[i];</span><br><span class="line">  AVCodecParameters* decode_para = istream-&gt;codecpar;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    decode_para-&gt;codec_type != AVMEDIA_TYPE_VIDEO &amp;&amp;</span><br><span class="line">    decode_para-&gt;codec_type != AVMEDIA_TYPE_AUDIO</span><br><span class="line">    ) &#123;</span><br><span class="line">    stream_mapping[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  AVStream* ostream = <span class="built_in">avformat_new_stream</span>(ofmt_ctx, <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">avcodec_parameters_copy</span>(ostream-&gt;codecpar, istream-&gt;codecpar);</span><br><span class="line">  ostream-&gt;codecpar-&gt;codec_tag = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  stream_mapping[i] = ostream-&gt;index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">av_freep</span>(&amp;stream_mapping);</span><br></pre></td></tr></table></figure>

<p><code>av_calloc()</code> 函数调用 <code>av_mallocz()</code> 函数来完成实际的内存分配工作。<code>av_mallocz()</code> 函数会将每个字节初始化为 <code>0</code>。</p>
<h4 id="封装为媒体文件"><a href="#封装为媒体文件" class="headerlink" title="封装为媒体文件"></a>封装为媒体文件</h4><p>媒体文件的开头和结尾要用专门的函数负责处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">avformat_write_header</span>(ofmt_ctx, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">av_write_trailer</span>(ofmt_ctx);</span><br></pre></td></tr></table></figure>

<p>封装媒体文件的过程就是从输入的媒体文件读数据包，再向输出的媒体文件写数据包的过程，中间还可以插入转码的过程。如果输入流和输出流的时间基不同，还要先用 <code>av_packet_rescale_ts()</code> 函数重新计算并设置数据包的时间戳。将数据包写入媒体文件要用 <code>av_interleaved_write_frame()</code> 函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">AVPacket* pkt = <span class="built_in">av_packet_alloc</span>();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">av_read_frame</span>(ifmt_ctx, pkt) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> istream_index = pkt-&gt;stream_index;</span><br><span class="line">  <span class="keyword">if</span> (istream_index &lt; ifmt_ctx-&gt;nb_streams) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ostream_index = stream_mapping[pkt-&gt;stream_index];</span><br><span class="line">    <span class="keyword">if</span> (ostream_index != <span class="number">-1</span>) &#123;</span><br><span class="line"></span><br><span class="line">      AVStream* istream = ifmt_ctx-&gt;streams[istream_index];</span><br><span class="line">      AVStream* ostream = ofmt_ctx-&gt;streams[ostream_index];</span><br><span class="line"></span><br><span class="line">      <span class="built_in">av_packet_rescale_ts</span>(pkt, istream-&gt;time_base, ostream-&gt;time_base);</span><br><span class="line">      pkt-&gt;stream_index = ostream_index;</span><br><span class="line">      pkt-&gt;pos = <span class="number">-1</span>;</span><br><span class="line">      </span><br><span class="line">      ret = <span class="built_in">av_interleaved_write_frame</span>(ofmt_ctx, pkt);</span><br><span class="line">      <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;av_interleaved_write_frame() failed\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">av_packet_unref</span>(pkt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">av_packet_free</span>(&amp;pkt);</span><br></pre></td></tr></table></figure>

<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><h4 id="av-dump-format"><a href="#av-dump-format" class="headerlink" title="av_dump_format()"></a>av_dump_format()</h4><p>关于媒体的封装格式的信息，可以用 <code>av_dump_format()</code> 函数打印。它需要一个 <code>AVFormatContext</code> 结构作为第一个参数，其余三个参数用于格式化输出的第一行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_dump_format</span><span class="params">(AVFormatContext *ic, <span class="type">int</span> index, <span class="type">const</span> <span class="type">char</span> *url, <span class="type">int</span> is_output)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当 <code>is_output</code> 为 <code>0</code> 时，第一行为 <code>Input ... from ...</code> 的形式；当 <code>is_output</code> 为 <code>1</code> 时，第一行为 <code>Output ... to ...</code> 的形式。<code>index</code> 是紧随在井号 <code>#</code> 后的数字。<code>url</code> 是引号中的文件名。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">av_dump_format</span>(ifmt_ctx, <span class="number">0</span>, ifmt_ctx-&gt;url, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">av_dump_format</span>(ofmt_ctx, <span class="number">1</span>, ofmt_ctx-&gt;url, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Input #0, mov,mp4,m4a,3gp,3g2,mj2, from &#x27;video.mp4&#x27;:</span></span><br><span class="line"><span class="comment">// Output #1, matroska, to &#x27;output.mkv&#x27;:</span></span><br></pre></td></tr></table></figure>

<h2 id="硬件加速"><a href="#硬件加速" class="headerlink" title="硬件加速"></a>硬件加速</h2><p>依赖硬件的 H.264 编解码器如下：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Codec</th>
<th>Description</th>
<th>Platform</th>
</tr>
</thead>
<tbody><tr>
<td>h264_amf</td>
<td>E</td>
<td><a target="_blank" rel="noopener" href="https://github.com/GPUOpen-LibrariesAndSDKs/AMF">Advanced Media Framework</a></td>
<td>AMD GPU, Windows</td>
</tr>
<tr>
<td>h264_nvenc</td>
<td>E</td>
<td><a target="_blank" rel="noopener" href="https://docs.nvidia.com/video-technologies/video-codec-sdk/index.html#ffmpeg-with-nvidia-gpu">NVIDIA NVENC</a></td>
<td>NVIDIA GPU</td>
</tr>
<tr>
<td>h264_cuvid</td>
<td>D</td>
<td><a target="_blank" rel="noopener" href="https://docs.nvidia.com/video-technologies/video-codec-sdk/index.html#ffmpeg-with-nvidia-gpu">NVIDIA NVDNC&#x2F;CUVID</a></td>
<td>NVIDIA GPU</td>
</tr>
<tr>
<td>h264_qsv</td>
<td>ED</td>
<td><a target="_blank" rel="noopener" href="https://github.com/Intel-Media-SDK/MediaSDK">Intel Media SDK (Quick Sync Video)</a></td>
<td>Intel CPU, Windows</td>
</tr>
<tr>
<td>h264_crystalhd</td>
<td>D</td>
<td>Crystal HD</td>
<td>Broadcom Crystal HD Decoder BCM70015</td>
</tr>
<tr>
<td>h264_mmal</td>
<td>D</td>
<td>Multi-Media Abstraction Layer</td>
<td>Broadcom VideoCore CPU, Raspberry Pi</td>
</tr>
<tr>
<td>h264_rkmpp</td>
<td>D</td>
<td><a target="_blank" rel="noopener" href="https://github.com/rockchip-linux/mpp">Rockchip Media Process Platform</a></td>
<td>RK32xx</td>
</tr>
<tr>
<td>h264_mf</td>
<td>E</td>
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/medfound/microsoft-media-foundation-sdk">Microsoft Media Foundation</a></td>
<td>Windows API</td>
</tr>
<tr>
<td>h264_v4l2m2m</td>
<td>ED</td>
<td>Video for Linux</td>
<td>Linux API</td>
</tr>
<tr>
<td>h264_vaapi</td>
<td>E</td>
<td>Video Acceleration API</td>
<td>Linux API</td>
</tr>
<tr>
<td>h264_videotoolbox</td>
<td>E</td>
<td>Video Toolbox</td>
<td>macOS</td>
</tr>
<tr>
<td>h264_mediacodec</td>
<td>D</td>
<td>MediaCodec</td>
<td>Android</td>
</tr>
<tr>
<td>h264_omx</td>
<td>E</td>
<td>OpenMAX Integration Layer</td>
<td>Embedded device</td>
</tr>
</tbody></table>
<h3 id="AMD-AMF"><a href="#AMD-AMF" class="headerlink" title="AMD AMF"></a>AMD AMF</h3><p>编译 FFmpeg 时需要提供 AMF SDK 的头文件才能启用基于 AMD GPU 的 H.264 硬编码器。</p>
<ol>
<li>将 <a target="_blank" rel="noopener" href="https://github.com/GPUOpen-LibrariesAndSDKs/AMF">AMF SDK</a> 中的文件夹 <code>amf/public/include</code> 复制到系统包含目录并重命名为 <code>AMF</code>。</li>
<li>添加编译选项 <code>--enable-amf</code>。</li>
<li>添加编码器 <code>h264_amf</code>。</li>
</ol>
<h3 id="Intel-QSV"><a href="#Intel-QSV" class="headerlink" title="Intel QSV"></a>Intel QSV</h3><p>FFmpeg 需要链接到库 <a target="_blank" rel="noopener" href="https://github.com/lu-zero/mfx_dispatch">libmfx</a> 才能启用基于 Intel 集成显卡的 H.264 硬编解码器。</p>
<ol>
<li>编译库 <code>libmfx</code>。</li>
<li>添加 <code>--enable-libmfx</code> 和 <code>--enable-filter=scale</code> 编译选项。</li>
<li>添加编解码器 <code>h264_qsv</code>。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://software.intel.com/media-sdk">Intel Media SDK</a> 是 Intel 显卡驱动的一部分。</p>
<h3 id="NVIDIA-CUDA"><a href="#NVIDIA-CUDA" class="headerlink" title="NVIDIA CUDA"></a>NVIDIA CUDA</h3><p>编译 FFmpeg 时需要提供 NVIDIA Codec SDK 的头文件。</p>
<ol>
<li>下载 <a target="_blank" rel="noopener" href="https://github.com/FFmpeg/nv-codec-headers">NVIDIA Codec SDK</a>，用 <code>make install</code> 命令安装。</li>
<li>添加编译选项 <code>--enable-cuvid</code>、<code>--enable-nvenc</code> 和 <code>--enable-nvdec</code>。</li>
<li>添加编码器 <code>h264_nvenc</code> 和解码器 <code>h264_cuvid</code>。</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>totravel
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://totravel.github.io/2022/10/10/2022-10-10-ffmpeg-tutorial/" title="C 库 FFmpeg 入门指南">https://totravel.github.io/2022/10/10/2022-10-10-ffmpeg-tutorial/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-ND</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/C-%E8%AF%AD%E8%A8%80/" rel="tag"><i class="fa fa-tag"></i> C 语言</a>
              <a href="/tags/FFmpeg/" rel="tag"><i class="fa fa-tag"></i> FFmpeg</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/08/19/2022-08-19-charset/" rel="prev" title="字符集、字符编码和编码转换">
                  <i class="fa fa-chevron-left"></i> 字符集、字符编码和编码转换
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/11/04/2022-11-04-bat-tutorial/" rel="next" title="一天学会 Windows 批处理">
                  一天学会 Windows 批处理 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">totravel</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.1/jquery.min.js" integrity="sha256-o88AwQnZB+VDvE9tvIXrMQaPlFFSUTR+nldQm1LuPXQ=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  


  <script src="/js/third-party/fancybox.js"></script>


  





</body>
</html>
