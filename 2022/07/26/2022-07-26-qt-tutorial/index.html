<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"totravel.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.13.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Qt 是一个跨平台的 C++ 桌面应用程序开发框架。">
<meta property="og:type" content="article">
<meta property="og:title" content="Qt 5 入门指南和参考手册">
<meta property="og:url" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/">
<meta property="og:site_name" content="旅行 · 之间">
<meta property="og:description" content="Qt 是一个跨平台的 C++ 桌面应用程序开发框架。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20220727094501150.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20220728110221098.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20220728115210397.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20220728104604561.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20220728105035748.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20220728102510594.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20220802145630450.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20220728104825785.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20220916111609503.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20220916113841110.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20220916113415503.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20220916114213728.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20220916114046483.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20220916155630888.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20220919134331554.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20220916152352895.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20220916151237996.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20220916170703668.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20220919095233699.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20220919095406145.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230221104534422.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230221105603029.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230214173845116.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230223141429993.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230223141514897.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230223141600883.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230223141632103.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230223100346357.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230223131435974.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230224011813149.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230223131746388.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230223140827681.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230224012309532.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230224012636783.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230224091138327.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230228013417275.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230301093025322.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230301104728241.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230301161029547.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230301160954557.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230301160911064.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230301162249727.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230302134533189.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230302134545256.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230302134554703.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230302134600087.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230302135519507.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230302135546858.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230302135736722.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230302135743683.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230302140016905.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230302134633516.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230302135923399.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230302140304156.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230302140310827.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20230302140004661.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20220923165757806.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20220930154946185.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20220930112850845.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20220930165942487.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20220930170406934.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20220921111040438.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20220921173702898.png">
<meta property="og:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20220923151853391.png">
<meta property="article:published_time" content="2022-07-25T17:04:59.000Z">
<meta property="article:modified_time" content="2023-03-04T15:49:42.313Z">
<meta property="article:author" content="totravel">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="Qt">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/image-20220727094501150.png">


<link rel="canonical" href="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":"","permalink":"https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/","path":"2022/07/26/2022-07-26-qt-tutorial/","title":"Qt 5 入门指南和参考手册"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Qt 5 入门指南和参考手册 | 旅行 · 之间</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">旅行 · 之间</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">总是跌跌撞撞，到底是顺其自然还是无头苍蝇？傻傻分不清……</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">47</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">2</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">19</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-Qt"><span class="nav-number">1.</span> <span class="nav-text">获取 Qt</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8-Visual-Studio-%E4%B8%AD%E4%BD%BF%E7%94%A8"><span class="nav-number">1.1.</span> <span class="nav-text">在 Visual Studio 中使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8-Ubuntu-%E4%B8%8A%E4%BD%BF%E7%94%A8"><span class="nav-number">1.2.</span> <span class="nav-text">在 Ubuntu 上使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B"><span class="nav-number">2.</span> <span class="nav-text">快速开始</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%86%9F%E6%82%89-Qt-Creator"><span class="nav-number">2.1.</span> <span class="nav-text">熟悉 Qt Creator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="nav-number">2.2.</span> <span class="nav-text">新建项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%A7%86%E5%8C%96-UI-%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.3.</span> <span class="nav-text">可视化 UI 设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E5%92%8C%E6%A0%87%E9%A2%98"><span class="nav-number">2.3.1.</span> <span class="nav-text">设置窗口大小和标题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD"><span class="nav-number">2.3.2.</span> <span class="nav-text">关联信号和槽</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8C"><span class="nav-number">2.4.</span> <span class="nav-text">构建并运行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E8%A7%86%E5%8C%96-UI-%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">可视化 UI 设计的工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E5%8F%AF%E8%A7%86%E5%8C%96-UI-%E8%AE%BE%E8%AE%A1"><span class="nav-number">3.1.</span> <span class="nav-text">非可视化 UI 设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD-1"><span class="nav-number">3.2.</span> <span class="nav-text">关联信号和槽</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E5%85%B3%E8%81%94"><span class="nav-number">3.2.1.</span> <span class="nav-text">自动关联</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E5%85%B3%E8%81%94"><span class="nav-number">3.2.2.</span> <span class="nav-text">手动关联</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E4%B8%93%E9%A2%98"><span class="nav-number">4.</span> <span class="nav-text">基础专题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6"><span class="nav-number">4.1.</span> <span class="nav-text">常用控件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC%E6%A1%86"><span class="nav-number">4.1.1.</span> <span class="nav-text">多行文本框</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E4%BB%B6%E7%9A%84%E5%AD%97%E4%BD%93"><span class="nav-number">4.1.2.</span> <span class="nav-text">控件的字体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E4%BB%B6%E7%9A%84%E9%A2%9C%E8%89%B2"><span class="nav-number">4.1.3.</span> <span class="nav-text">控件的颜色</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E4%BB%B6%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">4.1.4.</span> <span class="nav-text">控件的状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E8%A1%8C%E6%96%87%E6%9C%AC%E6%A1%86"><span class="nav-number">4.1.5.</span> <span class="nav-text">单行文本框</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%8B%E9%92%AE"><span class="nav-number">4.1.6.</span> <span class="nav-text">旋钮</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E6%9D%A1"><span class="nav-number">4.1.7.</span> <span class="nav-text">滑动条</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F"><span class="nav-number">4.1.8.</span> <span class="nav-text">时间日期</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="nav-number">4.1.8.1.</span> <span class="nav-text">时间日期类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E6%97%B6%E5%99%A8%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">4.1.9.</span> <span class="nav-text">计时器和定时器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8B%E6%8B%89%E5%88%97%E8%A1%A8"><span class="nav-number">4.1.10.</span> <span class="nav-text">下拉列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%E8%A1%A8"><span class="nav-number">4.1.11.</span> <span class="nav-text">列表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E5%A4%84%E7%90%86"><span class="nav-number">4.2.</span> <span class="nav-text">日志处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E7%B1%BB"><span class="nav-number">4.3.</span> <span class="nav-text">容器类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E9%A3%8E%E6%A0%BC%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">4.3.1.</span> <span class="nav-text">Java 风格的迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#STL-%E9%A3%8E%E6%A0%BC%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">4.3.2.</span> <span class="nav-text">STL 风格的迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="nav-number">4.3.3.</span> <span class="nav-text">顺序容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%A0%E5%B0%84"><span class="nav-number">4.3.4.</span> <span class="nav-text">映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">4.3.5.</span> <span class="nav-text">集合</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">4.4.</span> <span class="nav-text">工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#QString"><span class="nav-number">4.4.1.</span> <span class="nav-text">QString</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">4.4.1.1.</span> <span class="nav-text">格式化字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2"><span class="nav-number">4.4.1.2.</span> <span class="nav-text">字符编码转换</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#QStringList"><span class="nav-number">4.4.2.</span> <span class="nav-text">QStringList</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">4.5.</span> <span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B1%BB"><span class="nav-number">4.5.1.</span> <span class="nav-text">文件类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="nav-number">4.5.1.1.</span> <span class="nav-text">文件操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-number">4.5.1.2.</span> <span class="nav-text">读写文件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF%E7%B1%BB"><span class="nav-number">4.5.2.</span> <span class="nav-text">文件信息类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E7%B1%BB"><span class="nav-number">4.5.3.</span> <span class="nav-text">目录类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C"><span class="nav-number">4.5.3.1.</span> <span class="nav-text">目录操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-number">4.5.3.2.</span> <span class="nav-text">目录的路径</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%82%E9%A1%B9"><span class="nav-number">4.6.</span> <span class="nav-text">杂项</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JSON-%E6%96%87%E6%A1%A3"><span class="nav-number">4.6.1.</span> <span class="nav-text">JSON 文档</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E4%BD%9C"><span class="nav-number">4.6.2.</span> <span class="nav-text">动作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E8%AF%AD%E8%A8%80%E5%9B%BD%E9%99%85%E5%8C%96"><span class="nav-number">4.6.3.</span> <span class="nav-text">多语言国际化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-number">4.6.4.</span> <span class="nav-text">可执行文件的路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E6%BA%90"><span class="nav-number">4.6.5.</span> <span class="nav-text">信号源</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E9%98%B6%E4%B8%93%E9%A2%98"><span class="nav-number">5.</span> <span class="nav-text">进阶专题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E5%90%88-CMake"><span class="nav-number">5.1.</span> <span class="nav-text">结合 CMake</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F"><span class="nav-number">5.2.</span> <span class="nav-text">元对象系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7-%E6%A7%BD%E6%9C%BA%E5%88%B6"><span class="nav-number">5.2.1.</span> <span class="nav-text">信号-槽机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%92%8C%E5%8F%91%E5%B0%84%E4%BF%A1%E5%8F%B7"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">声明和发射信号</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E6%A7%BD"><span class="nav-number">5.2.1.2.</span> <span class="nav-text">声明和定义槽</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD-2"><span class="nav-number">5.2.1.3.</span> <span class="nav-text">关联信号和槽</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E7%B3%BB%E7%BB%9F"><span class="nav-number">5.2.2.</span> <span class="nav-text">属性系统</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7"><span class="nav-number">5.2.2.1.</span> <span class="nav-text">定义属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%B1%9E%E6%80%A7"><span class="nav-number">5.2.2.2.</span> <span class="nav-text">声明属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%B1%9E%E6%80%A7"><span class="nav-number">5.2.2.3.</span> <span class="nav-text">动态属性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.2.3.</span> <span class="nav-text">元对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="nav-number">5.2.3.1.</span> <span class="nav-text">属性的信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF"><span class="nav-number">5.2.3.2.</span> <span class="nav-text">类的附加信息</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%A0%91"><span class="nav-number">5.2.4.</span> <span class="nav-text">对象树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F"><span class="nav-number">5.2.4.1.</span> <span class="nav-text">析构顺序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">5.2.5.</span> <span class="nav-text">事件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E5%92%8C%E5%A4%84%E7%90%86%E4%BA%8B%E4%BB%B6"><span class="nav-number">5.2.5.1.</span> <span class="nav-text">接收和处理事件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E5%8F%91%E9%80%81%E4%BA%8B%E4%BB%B6"><span class="nav-number">5.2.5.2.</span> <span class="nav-text">创建和发送事件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">5.2.5.3.</span> <span class="nav-text">事件过滤器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2"><span class="nav-number">5.3.</span> <span class="nav-text">用户界面</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E5%92%8C%E7%AA%97%E5%8F%A3"><span class="nav-number">5.3.1.</span> <span class="nav-text">组件和窗口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%B0%BA%E5%AF%B8"><span class="nav-number">5.3.2.</span> <span class="nav-text">组件位置和尺寸</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E5%B8%83%E5%B1%80"><span class="nav-number">5.3.3.</span> <span class="nav-text">组件布局</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%BA%E5%AF%B8%E4%BF%A1%E6%81%AF"><span class="nav-number">5.3.3.1.</span> <span class="nav-text">尺寸信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%BA%E5%AF%B8%E8%B0%83%E6%95%B4%E7%AD%96%E7%95%A5"><span class="nav-number">5.3.3.2.</span> <span class="nav-text">尺寸调整策略</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%98%E5%9B%BE%E7%B3%BB%E7%BB%9F"><span class="nav-number">5.3.4.</span> <span class="nav-text">绘图系统</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%98%E5%88%B6%E5%9B%BE%E5%BD%A2"><span class="nav-number">5.3.4.1.</span> <span class="nav-text">绘制图形</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%AD%97%E4%BD%93"><span class="nav-number">5.3.4.2.</span> <span class="nav-text">设置字体</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%98%E5%88%B6%E6%96%87%E6%9C%AC"><span class="nav-number">5.3.4.3.</span> <span class="nav-text">绘制文本</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%98%E5%88%B6%E8%B7%AF%E5%BE%84"><span class="nav-number">5.3.4.4.</span> <span class="nav-text">绘制路径</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2"><span class="nav-number">5.3.4.5.</span> <span class="nav-text">坐标变换</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E5%BD%A2%E8%A7%86%E5%9B%BE%E6%A1%86%E6%9E%B6"><span class="nav-number">5.3.5.</span> <span class="nav-text">图形视图框架</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE%E6%8E%A7%E5%88%B6"><span class="nav-number">5.3.5.1.</span> <span class="nav-text">视图控制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2"><span class="nav-number">5.3.5.2.</span> <span class="nav-text">坐标转换</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6"><span class="nav-number">5.3.6.</span> <span class="nav-text">组件事件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%BB%9A%E8%BD%AE%E4%BA%8B%E4%BB%B6"><span class="nav-number">5.3.6.1.</span> <span class="nav-text">滚轮事件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%96%E6%94%BE%E6%9C%BA%E5%88%B6"><span class="nav-number">5.3.7.</span> <span class="nav-text">拖放机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%80%E5%A7%8B%E6%8B%96%E6%8B%BD"><span class="nav-number">5.3.7.1.</span> <span class="nav-text">开始拖拽</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%BC%A0%E6%A0%87%E5%BD%A2%E7%8A%B6"><span class="nav-number">5.3.7.2.</span> <span class="nav-text">鼠标形状</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="nav-number">5.4.</span> <span class="nav-text">对话框</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="nav-number">5.4.1.</span> <span class="nav-text">标准对话框</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="nav-number">5.4.2.</span> <span class="nav-text">自定义对话框</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E6%80%81%E6%A1%86"><span class="nav-number">5.4.2.1.</span> <span class="nav-text">模态框</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%9E%E6%A8%A1%E6%80%81%E6%A1%86"><span class="nav-number">5.4.2.2.</span> <span class="nav-text">非模态框</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6"><span class="nav-number">5.4.3.</span> <span class="nav-text">事件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD"><span class="nav-number">5.4.3.1.</span> <span class="nav-text">信号和槽</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE%E5%92%8C%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.5.</span> <span class="nav-text">视图和模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#QStringListModel"><span class="nav-number">5.5.1.</span> <span class="nav-text">QStringListModel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#QStandardItemModel"><span class="nav-number">5.5.2.</span> <span class="nav-text">QStandardItemModel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#QItemSelectionModel"><span class="nav-number">5.5.3.</span> <span class="nav-text">QItemSelectionModel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BB%A3%E7%90%86%E7%B1%BB"><span class="nav-number">5.5.4.</span> <span class="nav-text">自定义代理类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.6.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E3%80%81%E5%90%AF%E5%8A%A8%E5%92%8C%E7%BB%93%E6%9D%9F%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.6.1.</span> <span class="nav-text">创建、启动和结束线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">5.6.2.</span> <span class="nav-text">线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81-QMutex"><span class="nav-number">5.6.2.1.</span> <span class="nav-text">互斥锁 QMutex</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#QMutexLocker"><span class="nav-number">5.6.2.1.1.</span> <span class="nav-text">QMutexLocker</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81-QReadWriteLock"><span class="nav-number">5.6.2.2.</span> <span class="nav-text">读写锁 QReadWriteLock</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#QReadLocker-amp-QWriteLocker"><span class="nav-number">5.6.2.2.1.</span> <span class="nav-text">QReadLocker &amp; QWriteLocker</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#QWaitCondition"><span class="nav-number">5.6.2.3.</span> <span class="nav-text">QWaitCondition</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F-QSemaphore"><span class="nav-number">5.6.2.4.</span> <span class="nav-text">信号量 QSemaphore</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="totravel"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">totravel</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/totravel" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;totravel" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:totravel@foxmail.com" title="E-Mail → mailto:totravel@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_nd.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="totravel">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="旅行 · 之间">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Qt 5 入门指南和参考手册 | 旅行 · 之间">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Qt 5 入门指南和参考手册
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-26 01:04:59" itemprop="dateCreated datePublished" datetime="2022-07-26T01:04:59+08:00">2022-07-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-04 23:49:42" itemprop="dateModified" datetime="2023-03-04T23:49:42+08:00">2023-03-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="获取-Qt"><a href="#获取-Qt" class="headerlink" title="获取 Qt"></a>获取 Qt</h2><p>Qt 是一个跨平台的 C++ 桌面应用程序开发框架，其源码和安装程序都可以从 <a target="_blank" rel="noopener" href="https://download.qt.io/official_releases/">Qt 官网</a> 下载。其中，源码和离线安装程序位于 <a target="_blank" rel="noopener" href="https://download.qt.io/official_releases/qt">qt</a> 文件夹中；在线安装程序位于 <a target="_blank" rel="noopener" href="https://download.qt.io/official_releases/online_installers/">online_installers</a> 文件夹中。在每个文件的 <a target="_blank" rel="noopener" href="https://download.qt.io/archive/qt/5.14/5.14.2/qt-opensource-windows-x86-5.14.2.exe.mirrorlist">详情页</a> 中还可以找到分布在世界各地的镜像站提供的下载链接。</p>
<p>Qt 可以在商业许可证或开源许可证的授权下使用。从 Qt 5.15 开始，Qt 公司不再为开源许可的 Qt 提供离线安装程序。最后一个离线安装程序是 <a target="_blank" rel="noopener" href="https://download.qt.io/archive/qt/5.14/5.14.2/">Qt 5.14.2</a>。该版本还不支持 Visual Studio 2019。</p>
<p>Qt Creator 是 Qt 提供的跨平台 IDE，也是 Qt 的组件之一，可以用 Qt 的安装程序安装，也可以下载 <a target="_blank" rel="noopener" href="https://download.qt.io/official_releases/qtcreator/">独立的安装包</a> 进行安装。</p>
<p>Qt 的在线安装程序需要从网上下载数据。为了提高下载速度，需要让安装程序从镜像站下载数据。设置方式如下：打开安装程序，点击左下角的设置按钮，再点击底部的「添加」按钮，粘贴如下链接之一：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://mirrors.tuna.tsinghua.edu.cn/qt/online/qtsdkrepository/windows_x86/root/qt/</span><br><span class="line">https://mirrors.ustc.edu.cn/qtproject/online/qtsdkrepository/windows_x86/root/qt/</span><br></pre></td></tr></table></figure>

<h3 id="在-Visual-Studio-中使用"><a href="#在-Visual-Studio-中使用" class="headerlink" title="在 Visual Studio 中使用"></a>在 Visual Studio 中使用</h3><p>在 Visual Studio 2019 中使用 Qt 需要安装插件 <a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=TheQtCompany.QtVisualStudioTools2019">Qt Visual Studio Tools</a>。Visual Studio 的插件是 <code>.vsix</code> 文件，可以用 Visual Studio 打开进行安装。安装完毕后，要在插件的设置（拓展 - Qt VS Tools - Qt Versions）中添加 <code>qmake.exe</code>（在 Qt 的安装目录中可以找到）的路径。</p>
<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20220727094501150.png" alt="image-20220727094501150"></p>
<h3 id="在-Ubuntu-上使用"><a href="#在-Ubuntu-上使用" class="headerlink" title="在 Ubuntu 上使用"></a>在 Ubuntu 上使用</h3><p>在 Ubuntu 上可以通过 <code>apt</code> 命令快速安装 Qt 5.15.3。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y libxcb-xinerama0</span><br><span class="line">sudo apt install -y qtbase5-dev qtchooser qt5-qmake qtbase5-dev-tools</span><br><span class="line">sudo apt install -y qtcreator</span><br></pre></td></tr></table></figure>

<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>在开始菜单中，可以找到 Qt 提供的工具集：</p>
<ul>
<li>Qt Creator 集成开发环境</li>
<li>Assistant 用于查看 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5/">文档</a>，集成在 Qt Creator 中</li>
<li>Designer 用于编辑 UI 资源文件，集成在 Qt Creator 中</li>
<li>Linguist 用于编辑语言资源文件</li>
</ul>
<h3 id="熟悉-Qt-Creator"><a href="#熟悉-Qt-Creator" class="headerlink" title="熟悉 Qt Creator"></a>熟悉 Qt Creator</h3><p>Qt Creator 的界面很简洁。顶部是主菜单栏。左侧是包含两组按钮的工具栏：第一组按钮用于切换到不同的界面（Edit 用于代码编辑，Design 用于 UI 设计，Projects 用于项目设置，Help 用于文档查阅）；第二组按钮是构建、调试和运行按钮。右侧是工作区，工作区显示的内容取决于选择的界面。</p>
<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20220728110221098.png" alt="image-20220728110221098"></p>
<p>切换到 Edit 界面时，工作区的主要内容是一个代码编辑器。点击底部状态栏的第一个按钮可以显示或隐藏工作区的左侧边栏。左侧边栏默认包含 Projects 面板和 Open Documents 面板。Projects 面板用于显示项目的目录结构，Open Documents 面板用于列出已打开的文件。每个面板的标题都是一个下拉列表，用于切换成其他面板。</p>
<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20220728115210397.png" alt="image-20220728115210397"></p>
<h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p>Qt Creator 支持创建 3 种不同的项目（File - New Project…）：</p>
<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20220728104604561.png" alt="image-20220728104604561"></p>
<ul>
<li>Qt Widgets Application 桌面应用程序（窗口程序）</li>
<li>Qt Console Application 控制台应用程序</li>
<li>Qt Quick Application 用于移动设备和嵌入式设备，使用 QML 语言进行 UI 设计的应用程序</li>
</ul>
<p>一个桌面应用程序至少包含一个窗口类。新建桌面应用程序的步骤如下：</p>
<p>第一步是设置项目的名称并选择项目的保存位置。Qt Creator 会在项目的保存位置创建一个与项目同名的文件夹作为项目的根目录。比如在 <code>D:\Code\qt_demo</code> 创建文件夹 <code>hello_world</code>：</p>
<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20220728105035748.png" alt="image-20220728105035748"></p>
<p>第二步是选择项目的构建工具：</p>
<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20220728102510594.png" alt="image-20220728102510594"></p>
<p>最重要的一步是选择窗口类的基类，并设置派生类的类名、派生类的头文件和源文件以及 UI 资源文件（Form file）的文件名。</p>
<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20220802145630450.png" alt="image-20220802145630450"></p>
<p>窗口类的基类决定窗口的类型，有三种基类可以选择：</p>
<ul>
<li><code>QMainWindow</code> 用于创建包含主菜单栏、工具栏和状态栏的窗口</li>
<li><code>QDialog</code> 用于创建对话框</li>
<li><code>QWidget</code> 用于创建包含各种控件的窗口</li>
</ul>
<p>最后一步是根据需要勾选平台工具集（如 MSVC 和 MinGW）和构建配置（如 Debug、Release）。</p>
<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20220728104825785.png" alt="image-20220728104825785"></p>
<p>项目最开始通常包含 5 个文件：包含主函数的源文件 <code>main.cpp</code>，窗口类的头文件 <code>mainwindow.h</code> 和源文件 <code>mainwindow.cpp</code>，UI 资源文件 <code>mainwindow.ui</code> 以及 CMake 的配置文件 <code>CMakeLists.txt</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hello_world $ tree .</span><br><span class="line">.</span><br><span class="line">|-- CMakeLists.txt</span><br><span class="line">|-- main.cpp</span><br><span class="line">|-- mainwindow.cpp</span><br><span class="line">|-- mainwindow.h</span><br><span class="line">`-- mainwindow.ui</span><br><span class="line"></span><br><span class="line">0 directories, 5 files</span><br></pre></td></tr></table></figure>

<h3 id="可视化-UI-设计"><a href="#可视化-UI-设计" class="headerlink" title="可视化 UI 设计"></a>可视化 UI 设计</h3><p>打开 UI 资源文件时会自动切换到 UI 设计界面。</p>
<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20220916111609503.png" alt="image-20220916111609503"></p>
<p>UI 设计界面的左侧是控件的列表。要将控件添加到窗口中，直接将其拖动到中间的窗口中即可。例如，添加一个 <code>Push Button</code> 和一个 <code>Label</code>，并设置它们的 <code>text</code> 属性。</p>
<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20220916113841110.png" alt="image-20220916113841110"></p>
<p>添加到窗口中的控件会在右上角列出。在右上角选中一个控件后，左下角会列出该控件的属性。添加到窗口中的每个控件都有不同的 <code>objectName</code> 属性，它们是控件的变量名。为了便于使用控件，最好自定义控件的变量名，即自定义控件的 <code>objectName</code> 属性，比如将 <code>Close</code> 按钮的 <code>objectName</code> 属性设置为 <code>pBtnClose</code>。</p>
<h4 id="设置窗口大小和标题"><a href="#设置窗口大小和标题" class="headerlink" title="设置窗口大小和标题"></a>设置窗口大小和标题</h4><p>窗口大小由基类 <code>QWidget</code> 的 <code>geometry</code> 属性决定；窗口的标题由基类 <code>QWidget</code> 的 <code>windowTitle</code> 属性决定。</p>
<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20220916113415503.png" alt="image-20220916113415503"></p>
<h4 id="关联信号和槽"><a href="#关联信号和槽" class="headerlink" title="关联信号和槽"></a>关联信号和槽</h4><p>窗口底部是信号和槽的列表。信号和槽都是类的成员方法，用于实现控件间通信。信号表示一个事件，比如 <code>clicked()</code> 表示控件被单击的事件；槽表示可以响应信号的动作，比如 <code>close()</code> 是关闭窗口的动作。</p>
<p>要在点击 <code>Close</code> 按钮后关闭窗口，可以在信号和槽的列表添加如下条目，将按钮控件的 <code>clicked()</code> 信号和窗口的 <code>close()</code> 槽关联起来：</p>
<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20220916114213728.png" alt="image-20220916114213728"></p>
<h3 id="构建并运行"><a href="#构建并运行" class="headerlink" title="构建并运行"></a>构建并运行</h3><p>在完成 UI 设计后，点击左下角绿色的运行按钮即可启用程序。点击 <code>Close</code> 按钮可以关闭窗口。</p>
<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20220916114046483.png" alt="image-20220916114046483"></p>
<h2 id="可视化-UI-设计的工作原理"><a href="#可视化-UI-设计的工作原理" class="headerlink" title="可视化 UI 设计的工作原理"></a>可视化 UI 设计的工作原理</h2><p>在构建目录的 <code>hello_world_autogen/include</code> 子文件夹中可以找到头文件 <code>ui_mainwindow.h</code>。它是由 UIC 根据 UI 资源文件生成的。头文件的文件名比 UI 资源文件多了前缀 <code>ui_</code>，例如 <code>mainwindow.ui</code> 会被编译成 <code>ui_mainwindow.h</code>。头文件中的代码首先被包含在两个宏 <code>QT_BEGIN_NAMESPACE</code> 和 <code>QT_END_NAMESPACE</code> 之间。这两个宏将 UIC 生成的代码置于 Qt 专用的命名空间。</p>
<p><em>ui_mainwindow.h</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ui_MainWindow</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setupUi</span><span class="params">(QMainWindow *MainWindow)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">MainWindow</span>: <span class="keyword">public</span> Ui_MainWindow &#123;&#125;;</span><br><span class="line">&#125; <span class="comment">// namespace Ui</span></span><br><span class="line"></span><br><span class="line">QT_END_NAMESPACE</span><br></pre></td></tr></table></figure>

<p>头文件中的代码主要由两个类定义组成：一个名为 <code>Ui_MainWindow</code>，它有一个名为 <code>setupUi()</code> 的方法，包含 UI 初始化的代码；另一个名为 <code>Ui::MainWindow</code>，它只是简单地继承前者，不包含实质性的代码。要使用可视化 UI 设计，就需要在窗口类的构造函数中调用 <code>setupUi()</code> 方法。</p>
<p>窗口类的头文件只需声明类 <code>Ui::MainWindow</code>，不必包含 UIC 生成的头文件 <code>ui_mainwindow.h</code>。这是因为窗口类头文件只需声明一个 <code>Ui::MainWindow</code> 类的指针。</p>
<p><em>mainwindow.h</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="keyword">class</span> <span class="title class_">MainWindow</span>; &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">  Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">  ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">  Ui::MainWindow *ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em>mainwindow.cpp</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">  : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">  , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">  ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非可视化-UI-设计"><a href="#非可视化-UI-设计" class="headerlink" title="非可视化 UI 设计"></a>非可视化 UI 设计</h3><p>进行一次非可视化 UI 设计可以帮助理解可视化 UI 设计的工作原理。不过，在实际开发中都会采用可视化 UI 设计，因为它不仅能够让 UI 设计工作变得直观，而且能够大大减少编码的工作量。</p>
<p>创建一个新的项目，在选择窗口的基类时，不要勾选 Generate form。这样 Qt Creator 就不会生成 <code>.ui</code> 文件。</p>
<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20220916155630888.png" alt="image-20220916155630888"></p>
<p>不采用可视化 UI 设计时，控件和窗口的初始化都要在窗口类中完成。在窗口类的头文件中需要声明各个控件的指针和负责 UI 初始化的 <code>setupUi()</code> 方法。要使用信号和槽的窗口类还需要包含 <code>Q_OBJECT</code> 宏。</p>
<p><em>mydialog.h</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDialog</span>: <span class="keyword">public</span> QDialog</span><br><span class="line">&#123;</span><br><span class="line">  Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MyDialog</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  QLabel      *labelMsg;</span><br><span class="line">  QPushButton *btnClose;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setupUi</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>窗口类的构造函数首先要调用父类的构造函数完成窗口的初始化，然后调用 <code>setupUi()</code> 完成 UI 的初始化，最后调用静态方法 <code>QObject::connect()</code> 完成信号和槽的关联。</p>
<p><em>mydialog.cpp</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mydialog.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"></span><br><span class="line">MyDialog::<span class="built_in">MyDialog</span>(QWidget *parent)</span><br><span class="line">  : <span class="built_in">QDialog</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;<span class="built_in">setupUi</span>();</span><br><span class="line">  QObject::<span class="built_in">connect</span>(btnClose, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">close</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDialog::setupUi</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  btnClose = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(QObject::<span class="built_in">tr</span>(<span class="string">&quot;Close&quot;</span>));</span><br><span class="line">  labelMsg = <span class="keyword">new</span> <span class="built_in">QLabel</span>(QObject::<span class="built_in">tr</span>(<span class="string">&quot;Hello, World!&quot;</span>));</span><br><span class="line"></span><br><span class="line">  QFont font = labelMsg-&gt;<span class="built_in">font</span>();</span><br><span class="line">  font.<span class="built_in">setPointSize</span>(<span class="number">24</span>);</span><br><span class="line">  labelMsg-&gt;<span class="built_in">setFont</span>(font);</span><br><span class="line"></span><br><span class="line">  QVBoxLayout *VBox = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>();</span><br><span class="line">  VBox-&gt;<span class="built_in">addWidget</span>(labelMsg);</span><br><span class="line">  VBox-&gt;<span class="built_in">addWidget</span>(btnClose);</span><br><span class="line">  <span class="keyword">this</span>-&gt;<span class="built_in">setLayout</span>(VBox);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>setupUi()</code> 方法中，首先创建各个控件的对象，根据需要设置控件的属性，然后创建一个布局容器，将各个控件加入其中，最后，用 <code>setLayout()</code> 方法将布局容器设置为窗口的布局容器。</p>
<h3 id="关联信号和槽-1"><a href="#关联信号和槽-1" class="headerlink" title="关联信号和槽"></a>关联信号和槽</h3><h4 id="自动关联"><a href="#自动关联" class="headerlink" title="自动关联"></a>自动关联</h4><p>在 UI 设计界面右击控件，点击 Go to slot…，可以快速添加一个新的方法作为控件的信号的槽。Designer 会在窗口类的头文件中新增方法的声明，在源文件中新增方法的定义。</p>
<p><em>mywidget.h</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">on_checkBox_clicked</span><span class="params">(<span class="type">bool</span> checked)</span></span>;</span><br></pre></td></tr></table></figure>

<p><em>mywidget.cpp</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyWidget::on_checkBox_clicked</span><span class="params">(<span class="type">bool</span> checked)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UIC 生成的 <code>setupUi()</code> 方法调用了静态方法 <code>QMetaObject::connectSlotsByName()</code>。这个方法可以根据方法名自动关联对象中的信号和槽。比如名为 <code>on_checkBox_clicked</code> 方法就是控件 <code>checkBox</code> 的 <code>clicked()</code> 信号的槽。如果没有调用 <code>connectSlotsByName()</code> 方法，就需要调用静态方法 <code>QObject::connect()</code> 一一关联每一对信号和槽。</p>
<h4 id="手动关联"><a href="#手动关联" class="headerlink" title="手动关联"></a>手动关联</h4><p>信号和槽通常在构造函数中用 <code>QObject::connect()</code> 方法关联。该方法的第一、三个参数分别是信号的发送方和接收方，第二、四个参数分别是发送方的信号和接收方的方法。信号和作为槽的方法分别要用 <code>SIGNAL()</code> 和 <code>SLOT()</code> 宏处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyDialog::<span class="built_in">MyDialog</span>(QWidget *parent)</span><br><span class="line">  : <span class="built_in">QDialog</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">setupUi</span>();</span><br><span class="line">  QObject::<span class="built_in">connect</span>(myButton, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">close</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个信号不仅可以关联到一个槽，还可以关联到另一个信号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(myButton, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SIGNAL</span>(<span class="built_in">buttonClicked</span>()));</span><br></pre></td></tr></table></figure>

<p>一个信号可以关联多个槽和信号。多个信号关联可以同一个槽。重复关联信号和槽会导致槽被调用多次。</p>
<h2 id="基础专题"><a href="#基础专题" class="headerlink" title="基础专题"></a>基础专题</h2><h3 id="常用控件"><a href="#常用控件" class="headerlink" title="常用控件"></a>常用控件</h3><h4 id="多行文本框"><a href="#多行文本框" class="headerlink" title="多行文本框"></a>多行文本框</h4><p>多行文本框用 <code>QPlainTextEdit</code> 对象表示。要向文本框追加文本，可以调用它的 <code>appendPlainText()</code> 方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ui-&gt;plainTextEdit-&gt;<span class="built_in">appendPlainText</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="控件的字体"><a href="#控件的字体" class="headerlink" title="控件的字体"></a>控件的字体</h4><p>调用控件的 <code>font()</code> 方法可以获得一个字体对象，它描述控件文本的字体、字号和字体风格。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QFont font = ui-&gt;plainTextEdit-&gt;<span class="built_in">font</span>();</span><br><span class="line"></span><br><span class="line">font.<span class="built_in">setFamily</span>(<span class="string">&quot;Noto Sans&quot;</span>); <span class="comment">// 思源黑体</span></span><br><span class="line">font.<span class="built_in">setBold</span>(<span class="literal">true</span>);          <span class="comment">// 加粗</span></span><br><span class="line">font.<span class="built_in">setPointSize</span>(<span class="number">14</span>);       <span class="comment">// 字号</span></span><br><span class="line"></span><br><span class="line">ui-&gt;plainTextEdit-&gt;<span class="built_in">setFont</span>(font);</span><br></pre></td></tr></table></figure>

<h4 id="控件的颜色"><a href="#控件的颜色" class="headerlink" title="控件的颜色"></a>控件的颜色</h4><p>调用控件的 <code>palette()</code> 方法可以获得一个调色板对象，它描述控件要使用的各种前颜色和背景色。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QPalette palette = ui-&gt;plainTextEdit-&gt;<span class="built_in">palette</span>();</span><br><span class="line"></span><br><span class="line">QColor color;</span><br><span class="line">color.<span class="built_in">setRgb</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">palette.<span class="built_in">setColor</span>(QPalette::Base, color);   <span class="comment">// 控件背景色</span></span><br><span class="line">palette.<span class="built_in">setColor</span>(QPalette::Text, Qt::red); <span class="comment">// 字体颜色，即前景色</span></span><br><span class="line"></span><br><span class="line">ui-&gt;plainTextEdit-&gt;<span class="built_in">setPalette</span>(palette);</span><br></pre></td></tr></table></figure>

<h4 id="控件的状态"><a href="#控件的状态" class="headerlink" title="控件的状态"></a>控件的状态</h4><p>控件的状态由 <code>enabled</code> 属性决定，可用 <code>setEnabled()</code> 方法设置。</p>
<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20220919134331554.png" alt="image-20220919134331554"></p>
<h4 id="单行文本框"><a href="#单行文本框" class="headerlink" title="单行文本框"></a>单行文本框</h4><p>单行文本框由 <code>QLineEdit</code> 对象表示。当 <code>echoMode</code> 属性为 <code>Password</code> 时，输入框的内容会显示为 <code>*</code> 星号。</p>
<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20220916152352895.png" alt="image-20220916152352895"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QString <span class="title">text</span><span class="params">()</span></span>; <span class="comment">// 获取文本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setText</span><span class="params">(<span class="type">const</span> QString &amp;text)</span></span>; <span class="comment">// 设置文本</span></span><br></pre></td></tr></table></figure>

<h4 id="旋钮"><a href="#旋钮" class="headerlink" title="旋钮"></a>旋钮</h4><p><code>QSpinBox</code> 用于整数的输入，基数由 <code>displayIntegerBase</code> 属性决定，默认使用十进制；<code>QDoubleSpinBox</code> 用于小数的输入，显示多少位小数由 <code>decimals</code> 属性决定，默认显示两位。两者都可以给数字设置前缀、后缀、最小值、最大值和增量。</p>
<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20220916151237996.png" alt="image-20220916151237996"></p>
<p>输入框的内容可以用 <code>text()</code> 方法获取，用 <code>setText()</code> 方法设置。实际表示的数字要用 <code>value()</code> 方法获取，用 <code>setValue()</code> 方法设置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ui-&gt;doubleSpinBox-&gt;<span class="built_in">setValue</span>(<span class="number">1.5</span>);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; ui-&gt;doubleSpinBox-&gt;<span class="built_in">text</span>(); <span class="comment">// &quot;$1.50&quot;</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; ui-&gt;doubleSpinBox-&gt;<span class="built_in">value</span>(); <span class="comment">// 1.5</span></span><br></pre></td></tr></table></figure>

<h4 id="滑动条"><a href="#滑动条" class="headerlink" title="滑动条"></a>滑动条</h4><p><code>QSlider</code> 用于整数的输入。可以给数字设置最小值、最大值和增量。关闭 <code>tracking</code> 属性时，控件仅在松开滑块时才发送 <code>valueChanged()</code> 信号。</p>
<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20220916170703668.png" alt="image-20220916170703668"></p>
<h4 id="时间日期"><a href="#时间日期" class="headerlink" title="时间日期"></a>时间日期</h4><p>Qt 为时间日期的表示和显示提供了 3 种数据类型和 4 个控件。</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Widget</th>
</tr>
</thead>
<tbody><tr>
<td><code>QTime</code></td>
<td><code>QTimeEdit</code></td>
</tr>
<tr>
<td><code>QDate</code></td>
<td><code>QDateEdit</code></td>
</tr>
<tr>
<td><code>QDateTime</code></td>
<td><code>QDateTimeEdit</code></td>
</tr>
<tr>
<td>-</td>
<td><code>QCalendarWidget</code></td>
</tr>
</tbody></table>
<p><code>QTimeEdit</code> 和 <code>QDateEdit</code> 都是 <code>QDateTimeEdit</code> 的派生类。<code>QDateTimeEdit</code> 的常用属性如下：</p>
<ul>
<li><code>dateTime</code>，<code>QDateTime</code> 类型，指示时间日期。</li>
<li><code>date</code>，<code>QDate</code> 类型，指示日期。</li>
<li><code>time</code>，<code>QTime</code> 类型，指示时间。</li>
<li><code>currentSection</code>，枚举类型 <code>QDateTimeEdit::Section</code>，指示用户正在编辑的字段，比如 <code>YearSection</code> 表示用户正在编辑年份。</li>
<li><code>calendarPopup</code>，布尔型，指示是否提供日历选择框，区别见下图。</li>
<li><code>displayFormat</code>，字符串型，指示时间日期的格式，如 <code>yyyy-MM-dd HH:mm::ss</code> 表示 <code>2022-09-19 10:30:00</code>。</li>
</ul>
<p>不提供日历选择框：</p>
<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20220919095233699.png" alt="image-20220919095233699"></p>
<p>提供日历选择框：</p>
<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20220919095406145.png" alt="image-20220919095406145"></p>
<h5 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h5><p>要获取当前时间日期，可以用静态方法 <code>QDateTime::currentDateTime()</code>，它返回一个 <code>QDateTime</code> 对象。调用 <code>QDateTime</code> 对象的 <code>toString()</code> 方法还可以获得时间日期的字符串表示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QDateTime dateTime = QDateTime::<span class="built_in">currentDateTime</span>();</span><br><span class="line">QString string = dateTime.<span class="built_in">toString</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; string;</span><br></pre></td></tr></table></figure>

<p>当前时间或日期也可以单独获取，或者通过 <code>QDateTime</code> 对象获取：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QDate date = QTime::<span class="built_in">currentTime</span>();</span><br><span class="line">QTime time = QData::<span class="built_in">currentDate</span>();</span><br><span class="line"></span><br><span class="line">QDate date = dateTime.<span class="built_in">date</span>();</span><br><span class="line">QTime time = dateTime.<span class="built_in">time</span>();</span><br></pre></td></tr></table></figure>

<p> <code>QDate</code> 和 <code>QTime</code> 对象也都提供 <code>toString()</code> 方法。<code>toString()</code> 方法的参数可以包含下列转义序列：</p>
<ul>
<li>年<ul>
<li><code>yy</code> 用两位数表示年份， 如 22</li>
<li><code>yyyy</code> 用四位数表示年份，如 2022</li>
</ul>
</li>
<li>月<ul>
<li><code>M</code> 1-12</li>
<li><code>MM</code> 01-12</li>
</ul>
</li>
<li>日<ul>
<li><code>d</code> 1-31</li>
<li><code>dd</code> 01-31</li>
</ul>
</li>
<li>时<ul>
<li><code>H</code> 0-23 或 1-12</li>
<li><code>HH</code> 00-23 或 01-12</li>
</ul>
</li>
<li>分<ul>
<li><code>m</code> 0-59</li>
<li><code>mm</code> 00-59</li>
</ul>
</li>
<li>秒<ul>
<li><code>s</code> 0-59</li>
<li><code>ss</code> 00-59</li>
</ul>
</li>
<li>毫秒<ul>
<li><code>z</code> 0-999</li>
<li><code>zzz</code> 000-999</li>
</ul>
</li>
<li><code>AP</code> 或 <code>A</code> 是否采用 12 小时制并在结尾追加 <code>AM</code> 或 <code>PM</code> 的本地译名</li>
<li><code>ap</code> 或 <code>a</code> 是否采用 12 小时制并在结尾追加 <code>am</code> 或 <code>pm</code> 的本地译名</li>
</ul>
<p>要从字符串解析时间日期，可以用静态方法 <code>QDateTime::fromString()</code>。字符串中包含的时间日期的格式要用第二个参数指示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QDateTime dateTime = QDateTime::<span class="built_in">fromString</span>(<span class="string">&quot;2022919&quot;</span>, <span class="string">&quot;yyyyMdd&quot;</span>);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; dateTime.<span class="built_in">toString</span>(<span class="string">&quot;yy-MM-dd&quot;</span>); <span class="comment">// &quot;22-09-19&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="计时器和定时器"><a href="#计时器和定时器" class="headerlink" title="计时器和定时器"></a>计时器和定时器</h4><p>计时器是 <code>QElapsedTimer</code> 对象，它的 <code>start()</code> 方法用于开始计时，<code>elapsed()</code> 方法返回经过的毫秒数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QElapsedTimer counter;</span><br><span class="line">counter.<span class="built_in">start</span>();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">int</span> ms = counter.<span class="built_in">elapsed</span>();</span><br></pre></td></tr></table></figure>

<p>定时器是 <code>QTimer</code> 对象，它的 <code>interval</code> 属性指示定时周期，单位毫秒，每经过一个周期就会发送一次 <code>timeout()</code> 信号。调用定时器的 <code>start()</code> 和 <code>stop()</code> 方法可以启动和关闭定时器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QTimer *timer;</span><br><span class="line">timer = <span class="keyword">new</span> QTimer;</span><br><span class="line">timer-&gt;<span class="built_in">setInterval</span>(<span class="number">3000</span>);</span><br><span class="line">timer-&gt;<span class="built_in">start</span>();</span><br><span class="line">QObject::<span class="built_in">connect</span>(timer, <span class="built_in">SIGNAL</span>(<span class="built_in">timeout</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">on_timeout</span>()));</span><br></pre></td></tr></table></figure>

<h4 id="下拉列表"><a href="#下拉列表" class="headerlink" title="下拉列表"></a>下拉列表</h4><p>下拉列表是 <code>QComboBox</code> 对象。列表的每一项都可以关联一个 <code>QVariant</code> 对象，用于存储自定义数据。常用的方法如下：</p>
<ul>
<li><code>void addItem(const QString &amp;text, const QVariant &amp;userData = QVariant())</code> 新增项</li>
<li><code>int count()</code> 项数</li>
<li><code>QString itemText(int index)</code> 根据索引返回文本</li>
<li><code>QVariant itemData(int index) </code> 根据索引返回自定义数据</li>
<li><code>int currentIndex()</code> 当前项的索引</li>
<li><code>QString currentText()</code> 当前项的文本</li>
<li><code>QVariant currentData()</code> 当前项关联的自定义数据</li>
</ul>
<p>选中项改变时发送的信号：</p>
<ul>
<li><code>currentIndexChanged(int index)</code></li>
<li><code>currentTextChanged(const QString &amp;text)</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ui-&gt;comboBox-&gt;<span class="built_in">addItem</span>(<span class="string">&quot;Beijing&quot;</span>, <span class="number">10</span>);</span><br><span class="line">ui-&gt;comboBox-&gt;<span class="built_in">addItem</span>(<span class="string">&quot;Shanghai&quot;</span>, <span class="number">21</span>);</span><br><span class="line">ui-&gt;comboBox-&gt;<span class="built_in">addItem</span>(<span class="string">&quot;Guangzhou&quot;</span>, <span class="number">20</span>);</span><br><span class="line">ui-&gt;comboBox-&gt;<span class="built_in">addItem</span>(<span class="string">&quot;Shenzhen&quot;</span>, <span class="number">755</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; ui-&gt;comboBox-&gt;<span class="built_in">itemData</span>(<span class="number">3</span>).<span class="built_in">toInt</span>(); <span class="comment">// 755</span></span><br></pre></td></tr></table></figure>

<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>列表是 <code>QListWidget</code> 对象。列表的每一项是一个 <code>QListWidgetItem</code> 对象，移除时，要释放它的内存空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QListWidgetItem *newItem = <span class="keyword">new</span> <span class="built_in">QListWidgetItem</span>(<span class="string">&quot;Beijing&quot;</span>);</span><br><span class="line">ui-&gt;listWidget-&gt;<span class="built_in">addItem</span>(newItem);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> row = ui-&gt;listWidget-&gt;<span class="built_in">currentRow</span>();</span><br><span class="line">QListWidgetItem *removedItem = ui-&gt;listWidget-&gt;<span class="built_in">takeItem</span>(row);</span><br><span class="line"><span class="keyword">delete</span> removedItem;</span><br></pre></td></tr></table></figure>

<p>常用方法如下：</p>
<ul>
<li><code>int count()</code> 项数</li>
<li><code>QListWidgetItem *item(int row)</code> 根据行号返回项</li>
<li><code>int row(const QListWidgetItem *item)</code> 返回项的行号</li>
<li><code>QListWidgetItem *currentItem()</code> 当前项</li>
<li><code>int currentRow()</code> 当前项的行号</li>
<li><code>QList&lt;QListWidgetItem *&gt; selectedItems()</code> 选中项的列表</li>
<li><code>clear()</code> 清空</li>
<li><code>QListWidgetItem *takeItem(int row)</code> 根据行号从列表移除项并返回被移除的项</li>
</ul>
<h3 id="日志处理"><a href="#日志处理" class="headerlink" title="日志处理"></a>日志处理</h3><p>可以用 <code>qDebug()</code> 宏输出字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">qDebug</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>同类的宏还有 <code>qInfo()</code>、<code>qWarning()</code>、<code>qCritical()</code> 和 <code>qFatal()</code>。只有 <code>qFatal()</code> 会终止程序。</p>
<p>所有日志最终都由一个日志处理程序处理。默认的日志处理程序不会添加文件名、行号和函数名等信息作为前缀。要自定义日志的格式，可以用全局函数 <code>qInstallMessageHandler()</code> 设置自定义的日志处理程序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myMessageHandler</span><span class="params">(QtMsgType type, <span class="type">const</span> QMessageLogContext &amp;ctx, <span class="type">const</span> QString &amp;msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">qInstallMessageHandler</span>(myMessageHandler);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数 <code>type</code> 是枚举类型，指示日志的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">QtMsgType</span> &#123; QtDebugMsg, QtWarningMsg, QtCriticalMsg, QtFatalMsg, QtInfoMsg &#125;;</span><br></pre></td></tr></table></figure>

<p>参数 <code>ctx</code> 指示日志的上下文，包含日志的文件名、行号和函数名，仅在调试模式有效。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *file = ctx.file ? ctx.file : <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> line = ctx.line;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *function = ctx.function ? ctx.function : <span class="string">&quot;unknown&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h3><p><code>QList</code> 是最常用的容器。在列表两端添加新元素可以用 <code>append()</code> 和 <code>prepend()</code> 方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QList&gt;</span></span></span><br><span class="line"></span><br><span class="line">QList&lt;QString&gt; list = &#123; <span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span> &#125;;</span><br><span class="line">list.<span class="built_in">prepend</span>(<span class="string">&quot;zero&quot;</span>);</span><br><span class="line">list.<span class="built_in">append</span>(<span class="string">&quot;four&quot;</span>);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; list;</span><br><span class="line"><span class="comment">// (&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;)</span></span><br></pre></td></tr></table></figure>

<p>在末端追加新元素还可以用 <code>&lt;&lt;</code> 运算符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list &lt;&lt; <span class="string">&quot;five&quot;</span> &lt;&lt; <span class="string">&quot;six&quot;</span>;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; list;</span><br><span class="line"><span class="comment">// (&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;)</span></span><br></pre></td></tr></table></figure>

<p><code>QList</code> 可以像数组那样使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; list[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; list[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; list.<span class="built_in">at</span>(<span class="number">2</span>);</span><br><span class="line"><span class="string">&quot;zero&quot;</span></span><br><span class="line"><span class="string">&quot;one&quot;</span></span><br><span class="line"><span class="string">&quot;two&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="Java-风格的迭代器"><a href="#Java-风格的迭代器" class="headerlink" title="Java 风格的迭代器"></a>Java 风格的迭代器</h4><p>用 Java 风格的迭代器遍历列表时，主要依靠 <code>hasNext()</code> 和 <code>next()</code> 两个方法。<code>hasNext()</code> 方法用于检查下一个位置是否存在元素；<code>next()</code> 方法用于将迭代器移到下一个位置并返回该位置上的元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; list = &#123; <span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">QListIterator&lt;QString&gt; <span class="title">listIterator</span><span class="params">(list)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (listIterator.<span class="built_in">hasNext</span>()) &#123;</span><br><span class="line">  <span class="built_in">qDebug</span>() &lt;&lt; listIterator.<span class="built_in">next</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>toFront()</code> 将迭代器移到第一个元素之前</li>
<li><code>toBack()</code> 将迭代器移到最后一个元素之后</li>
<li><code>hasPrevious()</code> 检查上一个位置是否存在元素</li>
<li><code>previous()</code> 将迭代器移到上一个位置并返回该位置上的元素</li>
</ul>
<p><code>QListIterator</code> 是只读迭代器。要改写元素，需要用 <code>QMutableListIterator</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;<span class="type">int</span>&gt; list = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">QMutableListIterator&lt;<span class="type">int</span>&gt; <span class="title">mutableListIterator</span><span class="params">(list)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (mutableListIterator.<span class="built_in">hasNext</span>()) &#123;</span><br><span class="line">  <span class="type">int</span> n = mutableListIterator.<span class="built_in">next</span>();</span><br><span class="line">  <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    mutableListIterator.<span class="built_in">remove</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; list; <span class="comment">// (1, 3)</span></span><br></pre></td></tr></table></figure>

<p>可写迭代器比只读迭代器多出以下三个方法：</p>
<ul>
<li><code>remove()</code> 移除当前位置的元素。</li>
<li><code>setValue()</code> 修改当前位置的元素</li>
<li><code>insert()</code> 在当前位置插入新元素</li>
</ul>
<h4 id="STL-风格的迭代器"><a href="#STL-风格的迭代器" class="headerlink" title="STL 风格的迭代器"></a>STL 风格的迭代器</h4><p>用 STL 风格的迭代器遍历列表时，主要依靠 <code>++</code> 和 <code>*</code> 两个运算符。<code>++</code> 运算符将迭代器移到下一个位置；<code>*</code> 运算符返回当前位置上的元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; list = &#123; <span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">QList&lt;QString&gt;::iterator p;</span><br><span class="line"><span class="keyword">for</span> (p = list.<span class="built_in">begin</span>(); p != list.<span class="built_in">end</span>(); p++) &#123;</span><br><span class="line">  <span class="built_in">qDebug</span>() &lt;&lt; *p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;one&quot;</span></span><br><span class="line"><span class="comment">// &quot;two&quot;</span></span><br><span class="line"><span class="comment">// &quot;three&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h4><p>顺序容器，也就是列表，有以下 5 种：</p>
<ul>
<li><code>QList</code> 基于堆内存的列表</li>
<li><code>QLinkedList</code> 基于链表的列表</li>
<li><code>QVector</code> 基于数组的列表</li>
<li><code>QStack</code> 栈</li>
<li><code>QQueue</code> 队列</li>
</ul>
<p>前 3 种列表的内部实现不同，但它们提供的 API 基本相同。</p>
<h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><p>映射是特殊的列表，它们的元素是一个个键值对。</p>
<ul>
<li><code>QMap</code> 映射</li>
<li><code>QHash</code> 基于散列表的映射</li>
</ul>
<p><code>QMap</code> 会根据键名顺序存储每个键值，而 <code>QHash</code> 则不会。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMap&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHash&gt;</span></span></span><br><span class="line"></span><br><span class="line">QMap&lt;<span class="type">char</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">map[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="string">&#x27;b&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">map[<span class="string">&#x27;c&#x27;</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; map;</span><br><span class="line"><span class="comment">// QMap((a, 1)(b, 2)(c, 3))</span></span><br><span class="line"></span><br><span class="line">QHash&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">hash[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">hash[<span class="string">&#x27;b&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">hash[<span class="string">&#x27;c&#x27;</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; hash;</span><br><span class="line"><span class="comment">// QHash((c, 3)(b, 2)(a, 1))</span></span><br></pre></td></tr></table></figure>

<p>在遍历映射时，迭代器的 <code>key()</code> 方法返回键名，<code>value()</code> 方法返回键值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;<span class="type">char</span>, <span class="type">int</span>&gt;::iterator p;</span><br><span class="line"><span class="keyword">for</span> (p = map.<span class="built_in">begin</span>(); p != map.<span class="built_in">end</span>(); p++) &#123;</span><br><span class="line">  <span class="built_in">qDebug</span>() &lt;&lt; p.<span class="built_in">key</span>() &lt;&lt; p.<span class="built_in">value</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a 1</span></span><br><span class="line"><span class="comment">// b 2</span></span><br><span class="line"><span class="comment">// c 3</span></span><br></pre></td></tr></table></figure>

<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p><code>QSet</code> 是基于 <code>QHash</code> 的集合。集合是特殊的列表，它的元素不能重复。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSet&gt;</span></span></span><br><span class="line"></span><br><span class="line">QSet&lt;<span class="type">char</span>&gt; set = &#123; <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; set;</span><br><span class="line"><span class="comment">// QSet(c, b, a, d)</span></span><br></pre></td></tr></table></figure>

<h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><h4 id="QString"><a href="#QString" class="headerlink" title="QString"></a><code>QString</code></h4><p><code>QString</code> 类用于处理字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QString s = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; s.<span class="built_in">isEmpty</span>(); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; s.<span class="built_in">toUpper</span>(); <span class="comment">// &quot;HELLO, WORLD!&quot;</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; s.<span class="built_in">toLower</span>(); <span class="comment">// &quot;hello, world!&quot;</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; s.<span class="built_in">size</span>();    <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>

<p><code>count()</code>、<code>length()</code> 和 <code>size()</code> 都返回字符个数。</p>
<p><code>append()</code> 和 <code>prepend()</code> 用于在首尾追加字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QString s = <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">s.<span class="built_in">prepend</span>(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">s.<span class="built_in">append</span>(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; s; <span class="comment">// &quot;aabbbcc&quot;</span></span><br></pre></td></tr></table></figure>

<p>检查首尾：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QString s = <span class="string">&quot;ui_mainwindow.h&quot;</span>;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; s.<span class="built_in">startsWith</span>(<span class="string">&quot;ui_&quot;</span>, Qt::CaseInsensitive); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; s.<span class="built_in">endsWith</span>(<span class="string">&quot;.h&quot;</span>, Qt::CaseInsensitive);    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>trimmed()</code> 去掉首尾的空格。<code>simplified()</code> 不仅去掉首尾的空格，还会将中间的连续空格替换成一个。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QString s = <span class="string">&quot;  Hello,  World!   &quot;</span>;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; s.<span class="built_in">trimmed</span>();    <span class="comment">// &quot;Hello,  World!&quot;</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; s.<span class="built_in">simplified</span>(); <span class="comment">// &quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure>

<p>在字符串中检索：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QString s = <span class="string">&quot;Made in China&quot;</span>;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; s.<span class="built_in">indexOf</span>(<span class="string">&quot;in&quot;</span>);     <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; s.<span class="built_in">lastIndexOf</span>(<span class="string">&quot;in&quot;</span>); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; s.<span class="built_in">contains</span>(<span class="string">&quot;china&quot;</span>, Qt::CaseInsensitive); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>截取：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QString s = <span class="string">&quot;root:x:0:0:root:/root:/bin/bash&quot;</span>;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; s.<span class="built_in">left</span>(s.<span class="built_in">indexOf</span>(<span class="string">&quot;:&quot;</span>)); <span class="comment">// &quot;root&quot;</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; s.<span class="built_in">right</span>(s.<span class="built_in">size</span>() - s.<span class="built_in">lastIndexOf</span>(<span class="string">&quot;:&quot;</span>) - <span class="number">1</span>); <span class="comment">// &quot;/bin/bash&quot;</span></span><br></pre></td></tr></table></figure>

<p>在字符串和数字之间转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">QString</span>(<span class="string">&quot;12&quot;</span>).<span class="built_in">toInt</span>();     <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">QString</span>(<span class="string">&quot;10.5&quot;</span>).<span class="built_in">toFloat</span>(); <span class="comment">// 10.5</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; QString::<span class="built_in">number</span>(<span class="number">3</span>);        <span class="comment">// &quot;3&quot;</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; QString::<span class="built_in">number</span>(<span class="number">3</span>, <span class="number">2</span>);     <span class="comment">// &quot;11&quot;</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; QString::<span class="built_in">number</span>(<span class="number">2.5</span>);      <span class="comment">// &quot;2.5&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h5><p>格式化字符串可以用 <code>arg()</code> 方法，它将字符串中的 <code>%n</code> 替换为给定参数，其中 <code>n</code> 是从 <code>1</code> 开始的整数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">1</span>;                 <span class="comment">// current file&#x27;s number</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> total = <span class="number">2</span>;             <span class="comment">// number of files to process</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> fileName[] = <span class="string">&quot;a.txt&quot;</span>; <span class="comment">// current file&#x27;s name</span></span><br><span class="line"></span><br><span class="line">QString status = <span class="built_in">QString</span>(<span class="string">&quot;Processing file %1 of %2: %3&quot;</span>)</span><br><span class="line">                .<span class="built_in">arg</span>(i).<span class="built_in">arg</span>(total).<span class="built_in">arg</span>(fileName);</span><br><span class="line"></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; status; <span class="comment">// &quot;Processing file 1 of 2: a.txt&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="字符编码转换"><a href="#字符编码转换" class="headerlink" title="字符编码转换"></a>字符编码转换</h5><p><code>QString</code> 内部使用 UTF-16 编码。在创建 <code>QString</code> 对象时，如果提供的字符串使用本机编码，就需要用静态方法 <code>QString::fromLocal8Bit()</code> 来创建 <code>QString</code> 对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> src[] = <span class="string">&quot;好&quot;</span>; <span class="comment">// 0xba 0xc3 0x00 (GBK)</span></span><br><span class="line">QString str = QString::<span class="built_in">fromLocal8Bit</span>(src); <span class="comment">// 0x597d (UTF-16)</span></span><br></pre></td></tr></table></figure>

<p>需要 <code>QString</code> 对象提供本机编码的字符串时，可以借助 <code>toLocal8Bit()</code> 方法，它用一个 <code>QByteArray</code> 对象保存转换后的字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QByteArray bytes = str.<span class="built_in">toLocal8Bit</span>(); <span class="comment">// 0xba 0xc3 (GBK)</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *dst = bytes.<span class="built_in">constData</span>();</span><br></pre></td></tr></table></figure>

<p>还可以用 <code>toUtf8()</code> 方法获取 UTF-8 编码的字符串：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytes = str.<span class="built_in">toUtf8</span>(); <span class="comment">// 0xe5 0xa5 0xbd (UTF-8)</span></span><br></pre></td></tr></table></figure>

<p>在 Windows 上，本机编码默认为 GBK 编码。如果不是，应该用静态方法 <code>QTextCodec::setCodecForLocale()</code> 设置正确的本机编码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTextCodec&gt;</span></span></span><br><span class="line"></span><br><span class="line">QTextCodec::<span class="built_in">setCodecForLocale</span>(QTextCodec::<span class="built_in">codecForName</span>(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> src[] = <span class="string">u8&quot;好&quot;</span>; <span class="comment">// 0xe5 0xa5 0xbd (UTF-8)</span></span><br><span class="line">QString str = QString::<span class="built_in">fromLocal8Bit</span>(src); <span class="comment">// 0x597d (UTF-16)</span></span><br><span class="line">QByteArray bytes = str.<span class="built_in">toLocal8Bit</span>(); <span class="comment">// 0xe5 0xa5 0xbd (UTF-8)</span></span><br></pre></td></tr></table></figure>

<h4 id="QStringList"><a href="#QStringList" class="headerlink" title="QStringList"></a><code>QStringList</code></h4><p><code>QStringList</code> 是字符串列表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QStringList stringList;</span><br><span class="line">stringList &lt;&lt; <span class="string">&quot;Beijing&quot;</span> &lt;&lt; <span class="string">&quot;Shanghai&quot;</span> &lt;&lt; <span class="string">&quot;Guangzhou&quot;</span> &lt;&lt; <span class="string">&quot;Shenzhen&quot;</span>;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; stringList; <span class="comment">// (&quot;Beijing&quot;, &quot;Shanghai&quot;, &quot;Guangzhou&quot;, &quot;Shenzhen&quot;)</span></span><br></pre></td></tr></table></figure>

<p>在 <code>QStringList</code> 和 <code>QString</code> 之间转换很容易：<code>QString</code> 的 <code>split()</code> 方法用分隔符将一个字符串分割成若干子串；<code>QStringList</code> 的 <code>join()</code> 方法用分隔符将若干子串拼接成一个字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QString s1 = <span class="string">&quot;John,David,Mike&quot;</span>;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; s1.<span class="built_in">split</span>(<span class="string">&#x27;,&#x27;</span>); <span class="comment">// (&quot;John&quot;, &quot;David&quot;, &quot;Mike&quot;)</span></span><br><span class="line"></span><br><span class="line">QStringList s2 = &#123; <span class="string">&quot;John&quot;</span>, <span class="string">&quot;David&quot;</span>, <span class="string">&quot;Mike&quot;</span> &#125;;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; s2.<span class="built_in">join</span>(<span class="string">&#x27;;&#x27;</span>); <span class="comment">// &quot;John;David;Mike&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><h4 id="文件类"><a href="#文件类" class="headerlink" title="文件类"></a>文件类</h4><p>文件用 <code>QFile</code> 对象表示。创建 <code>QFile</code> 对象时需要指定一个文件作为当前文件（可以是不存在的文件）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QFile <span class="title">f</span><span class="params">(<span class="string">&quot;a.txt&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在打开文件之前可以用 <code>setFileName()</code> 方法重新设置当前文件。</p>
<h5 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h5><p><code>QFile</code> 类提供下列操作文件的方法：</p>
<ul>
<li><code>exists()</code> 检查当前文件是否存在</li>
<li><code>rename(const QString &amp;newName)</code> 移动当前文件</li>
<li><code>copy(const QString &amp;newName)</code> 复制当前文件</li>
<li><code>remove()</code> 删除当前文件</li>
<li><code>moveToTrash()</code> 移动当前文件到回收站</li>
</ul>
<h5 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h5><p>读写文件前要先用 <code>open()</code> 方法打开文件。打开文件时需要选择打开模式。文件打开后要用 <code>close()</code> 方法关闭。读写模式由枚举类型 <code>IODevice</code> 表示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!f.<span class="built_in">open</span>(QIODevice::ReadOnly | QIODevice::Text)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">f.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>

<p>有以下打开模式：</p>
<ul>
<li><code>NotOpen</code>，文件未打开</li>
<li><code>ReadOnly</code>，只读</li>
<li><code>WriteOnly</code>，只写，隐含 <code>Truncate</code></li>
<li><code>ReadWrite</code>，读写</li>
<li><code>Append</code>，追加</li>
<li><code>Truncate</code>，先清空再打开</li>
<li><code>Text</code>，读文件时，统一将行结束符替换成 <code>\n</code>；写文件时，统一将行结束符替换成平台相关的行结束符。</li>
<li><code>Unbuffered</code>，不要缓存</li>
<li><code>NewOnly</code>，新建文件（若文件已存在，则打开失败）</li>
<li><code>ExistingOnly</code>，打开已存在的文件（若文件不存在，则打开失败）</li>
</ul>
<p>调用 <code>readAll()</code> 方法可以一次性将文件的内容全部读取出来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QByteArray bytes = f.<span class="built_in">readAll</span>();</span><br><span class="line"><span class="keyword">if</span> (bytes.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以用 <code>readLine()</code> 方法按行读取文件的内容。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">qint64 <span class="title">QIODevice::readLine</span><span class="params">(<span class="type">char</span> *data, qint64 maxSize)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>readLine()</code> 方法每次最多从文件读取 <code>maxSize-1</code> 个字节并返回实际读取的字节数。如果遇到行结束符，或者到达文件末尾，则提前返回。注意，<code>readLine()</code> 方法最后还会向 <code>data</code> 写入一个字符串结束符 <code>\0</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.txt</span></span><br><span class="line"><span class="comment">// 123\r\n</span></span><br><span class="line"><span class="comment">// 456</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">10</span>]; <span class="comment">// 123\n\0</span></span><br><span class="line"><span class="type">int</span> lineLength = f.<span class="built_in">readLine</span>(buf, <span class="built_in">sizeof</span>(buf)); <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">if</span> (lineLength &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>readLine()</code> 方法有一个返回 <code>QByteArray</code> 对象的重载，它返回的 <code>QByteArray</code> 对象剔除了 <code>\0</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QByteArray bytes = f.<span class="built_in">readLine</span>(<span class="number">10</span>); <span class="comment">// 123\n</span></span><br></pre></td></tr></table></figure>

<p>在读文件的过程中可以用 <code>atEnd()</code> 方法检查是否到达文件末尾。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!f.<span class="built_in">atEnd</span>()) &#123;</span><br><span class="line">  QByteArray line = f.<span class="built_in">readLine</span>();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向文件写入数据可以用 <code>write()</code> 方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">qint64 <span class="title">QIODevice::write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *data, qint64 maxSize)</span></span></span><br><span class="line"><span class="function">qint64 <span class="title">QIODevice::write</span><span class="params">(<span class="type">const</span> QByteArray &amp;byteArray)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>write()</code> 方法的返回值都是实际写入的字节数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QByteArray bytes = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="type">int</span> ret = f.<span class="built_in">write</span>(bytes);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="文件信息类"><a href="#文件信息类" class="headerlink" title="文件信息类"></a>文件信息类</h4><p>要提取文件或目录的信息，可以借助 <code>QFileInfo</code> 类。</p>
<ul>
<li><code>exists()</code> 是否存在</li>
<li><code>isDir()</code> 是否为目录</li>
<li><code>isFile()</code> 是否为文件</li>
<li><code>isSymLink()</code> 是否为符号链接或快捷方式</li>
<li><code>path()</code> 文件所在目录的路径</li>
<li><code>absolutePath()</code> 文件所在目录的绝对路径</li>
<li><code>absoluteFilePath()</code> 文件的绝对路径</li>
<li><code>fileName()</code> 文件名（含扩展名）</li>
<li><code>baseName()</code> 文件名（不含扩展名）</li>
<li><code>suffix()</code> 扩展名</li>
</ul>
<h4 id="目录类"><a href="#目录类" class="headerlink" title="目录类"></a>目录类</h4><p>下列是常用的 <code>QDir</code> 类的静态方法：</p>
<ul>
<li><code>QDir::homePath()</code> 获取用户文件夹的路径</li>
<li><code>QDir::tempPath()</code> 获取系统临时目录的路径</li>
<li><code>QDir::currentPath()</code> 获取工作目录的路径</li>
<li><code>QDir::isAbsolutePath(const QString &amp;path)</code> 是否为绝对路径</li>
<li><code>QDir::isRelativePath(const QString &amp;path)</code> 是否为相对路径</li>
<li><code>QDir::cleanPath(const QString &amp;path)</code> 统一目录分隔符、移除多余的目录分隔符、消去 <code>.</code> 和 <code>..</code></li>
</ul>
<h5 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h5><p>创建 <code>QDir</code> 对象时，需要指定一个目录作为当前目录（可以是不存在的目录）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QDir <span class="title">dir</span><span class="params">(<span class="string">&quot;D:/a/b/c&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当前目录可以用 <code>path()</code> 方法获取，用  <code>setPath()</code> 方法重新设置。</p>
<ul>
<li><code>exists()</code> 检查当前目录是否存在</li>
<li><code>removeRecursively()</code> 删除当前目录（递归处理子目录）</li>
<li><code>mkdir(const QString &amp;dirName)</code> 创建目录</li>
<li><code>rmdir(const QString &amp;dirName)</code> 删除目录</li>
<li><code>mkpath(const QString &amp;dirPath)</code> 创建目录（递归处理父级目录）</li>
<li><code>rmpath(const QString &amp;dirPath)</code> 删除目录（递归处理父级目录）</li>
<li><code>rename(const QString &amp;oldName, const QString &amp;newName)</code> 移动目录（递归处理子目录）</li>
</ul>
<h5 id="目录的路径"><a href="#目录的路径" class="headerlink" title="目录的路径"></a>目录的路径</h5><p>可以用下列方法对路径进行转换或分解：</p>
<ul>
<li><code>makeAbsolute()</code> 将当前目录的路径转换为绝对路径</li>
<li><code>absolutePath()</code> 获取当前目录的绝对路径（可能是符号链接）</li>
<li><code>canonicalPath()</code> 获取当前目录的绝对路径（自动解析符号链接）</li>
<li><code>dirName()</code> 获取当前目录的目录名</li>
</ul>
<h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><h4 id="JSON-文档"><a href="#JSON-文档" class="headerlink" title="JSON 文档"></a>JSON 文档</h4><p>JSON 文档是文本文档，用于存储结构化数据，支持下列 6 种数据类型：</p>
<ul>
<li>用双引号 <code>&quot;&quot;</code> 括起来的字符串</li>
<li>整数或浮点数</li>
<li>布尔值 <code>true</code> 或 <code>false</code></li>
<li>空值 <code>null</code></li>
<li>数组</li>
<li>对象</li>
</ul>
<p>数组是元素的集合，元素要放在中括号 <code>[]</code> 中并用逗号 <code>,</code> 隔开，元素支持 6 种数据类型，例如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;Phone numbers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="string">&quot;+44 1234567&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;+44 2345678&quot;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>对象是属性的集合，属性要放在大括号 <code>&#123;&#125;</code> 中并用逗号 <code>,</code> 隔开，属性是一个键值对，键名和键值之间用冒号 <code>:</code> 隔开，键名都是字符串，键值支持 6 种数据类型，例如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;FirstName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;LastName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Doe&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Age&quot;</span><span class="punctuation">:</span> <span class="number">43</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Address&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Street&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Downing Street 10&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;City&quot;</span><span class="punctuation">:</span> <span class="string">&quot;London&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Country&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Great Britain&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Phone numbers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;+44 1234567&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;+44 2345678&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>JSON 文档的内容就是一个字符串，它要么是一个对象，要么是一个数组。</p>
<p>在 Qt 中，JSON 文档用 <code>QJsonDocument</code> 对象表示；JSON 数组用 <code>QJsonArray</code> 对象表示；JSON 对象用 <code>QJsonObject</code> 对象表示。JSON 对象的属性和 JSON 数组的元素都用 <code>QJsonValue</code> 对象表示。使用这些类需要包含下列头文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonDocument&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonArray&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonValue&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>JSON 文档对象可以用 <code>QJsonDocument::fromJson()</code> 函数根据 JSON 文档的内容创建。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QJsonDocument doc = QJsonDocument::<span class="built_in">fromJson</span>(<span class="string">R&quot;(&#123; &quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 18 &#125;)&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>JSON 文档对象的 <code>toJson()</code> 方法的作用与之相反：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString str = doc.<span class="built_in">toJson</span>(QJsonDocument::Compact); <span class="comment">// &quot;&#123;\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;John\&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以用 JSON 文档对象的 <code>isNull()</code> 方法检查它是否为空，即不包含任何数组或对象；用 <code>isArray()</code> 或 <code>isObject()</code> 方法检查它是否包含一个数组或对象；用 <code>array()</code> 或 <code>object()</code> 方法获取它包含的数组或对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!doc.<span class="built_in">isNull</span>()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (doc.<span class="built_in">isObject</span>()) &#123;</span><br><span class="line">    QJsonObject obj = doc.<span class="built_in">object</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>QJsonObject</code> 对象的 <code>keys()</code> 方法返回一个字符串列表，其中包含各个属性的键名。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QStringList keyNames = obj.<span class="built_in">keys</span>(); <span class="comment">// (&quot;age&quot;, &quot;name&quot;)</span></span><br></pre></td></tr></table></figure>

<p>访问某个属性或元素的值，首先要用 <code>value()</code> 方法或中括号运算符，获取代表该属性或元素的 <code>QJsonValue</code> 对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QJsonValue val = obj[<span class="string">&quot;name&quot;</span>];</span><br><span class="line"><span class="keyword">if</span> (val != QJsonValue::Undefined) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两种方式可以检查 <code>QJsonValue</code> 对象是否代表一个不存在属性或元素：</p>
<ul>
<li>将对象与 <code>QJsonValue::Undefined</code> 比较</li>
<li>调用对象的 <code>isUndefined()</code> 方法</li>
</ul>
<p>然后用 <code>is*()</code> 系列方法检查 <code>QJsonValue</code> 对象包含的数据的类型：</p>
<ul>
<li><code>isString()</code> 是否为字符串</li>
<li><code>isDouble()</code> 是否为整数或浮点数</li>
<li><code>isBool()</code> 是否为布尔值 <code>true</code> 或 <code>false</code></li>
<li><code>isNull()</code> 是否为空值 <code>null</code></li>
<li><code>isArray()</code> 是否为数组</li>
<li><code>isObject()</code> 是否为对象</li>
</ul>
<p>最后用 <code>to*()</code> 系列方法获取 <code>QJsonValue</code> 对象包含的数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (val.<span class="built_in">isString</span>()) &#123;</span><br><span class="line">  QString str = val.<span class="built_in">toString</span>(); <span class="comment">// &quot;John&quot;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h4><p>动作是菜单项、工具栏按钮或快捷键对应的命令，被调用时会发出 <code>triggered()</code> 信号。动作是独立对象，可以为之设置图标、文本、提示和快捷键等。一个动作可以同时被添加到菜单和工具栏中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QAction *openAction = <span class="keyword">new</span> <span class="built_in">QAction</span>();</span><br><span class="line">openAction-&gt;<span class="built_in">setShortcut</span>(<span class="built_in">QKeySequence</span>(Qt::CTRL + Qt::Key_O));</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">addAction</span>(openAction);</span><br><span class="line"></span><br><span class="line"><span class="built_in">connect</span>(openAction, <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>(<span class="type">bool</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">on_actionOpen_triggered</span>(<span class="type">bool</span>)));</span><br></pre></td></tr></table></figure>

<h4 id="多语言国际化"><a href="#多语言国际化" class="headerlink" title="多语言国际化"></a>多语言国际化</h4><p>在开发多语言应用时，显示在 UI 中的字符串要用静态方法 <code>QObject::tr()</code> 或 <code>QObject::trUtf8()</code> 处理，它负责把字符串替换成目标语言的版本。</p>
<h4 id="可执行文件的路径"><a href="#可执行文件的路径" class="headerlink" title="可执行文件的路径"></a>可执行文件的路径</h4><p>用 <code>QCoreApplication</code> 类的静态方法可以获取可执行文件的路径。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QCoreApplication::<span class="built_in">applicationFilePath</span>(); <span class="comment">// 可执行文件的路径</span></span><br><span class="line">QCoreApplication::<span class="built_in">applicationDirPath</span>();  <span class="comment">// 可执行文件所在目录的路径</span></span><br><span class="line">QCoreApplication::<span class="built_in">applicationName</span>();     <span class="comment">// 可执行文件的文件名（不含扩展名）</span></span><br></pre></td></tr></table></figure>

<h4 id="信号源"><a href="#信号源" class="headerlink" title="信号源"></a>信号源</h4><p>在作为槽的方法中，可以用静态方法 <code>QObject::sender()</code> 获取发送信号的对象。它的返回值要用 <code>qobject_cast&lt;&gt;()</code> 做强制类型转换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QSpinBox *pSpinBox = <span class="built_in">qobject_cast</span>&lt;QSpinBox *&gt;( QObject::<span class="built_in">sender</span>() );</span><br></pre></td></tr></table></figure>

<h2 id="进阶专题"><a href="#进阶专题" class="headerlink" title="进阶专题"></a>进阶专题</h2><h3 id="结合-CMake"><a href="#结合-CMake" class="headerlink" title="结合 CMake"></a>结合 CMake</h3><p>用 <code>find_package()</code> 命令就可以将 Qt 整合到项目中。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_AUTOMOC <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTORCC <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTOUIC <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_INCLUDE_CURRENT_DIR <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(Qt5 REQUIRED Widgets)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(helloworld</span><br><span class="line">  main.cpp</span><br><span class="line">  mydialog.h</span><br><span class="line">  mydialog.cpp</span><br><span class="line">  mydialog.ui</span><br><span class="line">)</span><br><span class="line"><span class="keyword">set_target_properties</span>(helloworld PROPERTIES WIN32_EXECUTABLE <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(helloworld Qt::Widgets)</span><br></pre></td></tr></table></figure>

<p>前三个变量指示 CMake 自动寻找 Qt 的 MOC、RCC 和 UIC 并分别用它们处理 <code>.cpp</code> 文件、<code>.qrc</code> 文件和 <code>.ui</code> 文件。<code>CMAKE_INCLUDE_CURRENT_DIR</code> 变量指示 CMake 将源目录和构建目录都添加到附加包含目录，这样才能使用 UIC 生成的头文件。目标的 <code>WIN32_EXECUTABLE</code> 属性指示目标的产物是一个桌面应用程序而不是控制台程序。</p>
<p>在生成构建系统时需要设置 <code>CMAKE_PREFIX_PATH</code> 变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake -S . -B build -DCMAKE_PREFIX_PATH=<span class="string">&quot;D:/Qt/5.15.2/msvc2019_64&quot;</span></span><br><span class="line">cmake --build build --config Release -j</span><br></pre></td></tr></table></figure>

<h3 id="元对象系统"><a href="#元对象系统" class="headerlink" title="元对象系统"></a>元对象系统</h3><p>元对象系统（Meta-Object System）的主要作用是提供了一种对象间通信机制。要使用元对象系统的类必须满足下列三个条件：</p>
<ul>
<li>继承 <code>QObject</code> 类；</li>
<li>在类的声明的 <code>private</code> 部分包含 <code>Q_OBJECT</code> 宏；</li>
<li>用元对象编译器（MOC，Meta-Object Compiler）处理。</li>
</ul>
<p>元对象编译器只是一个预处理器，并非真正的编译器。它会为每个声明中包含 <code>Q_OBJECT</code> 宏的类生成一个源文件。这些源文件包含实现元对象系统所需的代码，在构建时与类的源文件一起编译和链接。</p>
<p><code>QObject</code> 类还实现了一个简易的定时器。</p>
<h4 id="信号-槽机制"><a href="#信号-槽机制" class="headerlink" title="信号-槽机制"></a>信号-槽机制</h4><p>信号-槽机制是由元对象系统提供的一种对象间通信机制。信号是用来代表一个事件的方法；槽是用作事件处理器的方法。当事件发生时，只需发射信号，与之关联的槽就会被调用。</p>
<h5 id="声明和发射信号"><a href="#声明和发射信号" class="headerlink" title="声明和发射信号"></a>声明和发射信号</h5><p>信号是特殊的方法，只需声明，无需定义。在类的声明中，信号的声明要放在 <code>signals</code> 部分。发射信号的方法与调用函数的方法相同，只是发射信号的语句前要包含 <code>emit</code> 关键字。例如，在 <code>Sender</code> 类的声明中添加信号 <code>messageGenerated()</code> 的声明，并 <code>generateMessage()</code> 方法中发射 <code>messageGenerated()</code> 信号：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sender</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">  Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">generateMessage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">emit <span class="title">messageGenerated</span><span class="params">(<span class="string">&quot;Hello, World!&quot;</span>)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">messageGenerated</span><span class="params">(QString message)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="声明和定义槽"><a href="#声明和定义槽" class="headerlink" title="声明和定义槽"></a>声明和定义槽</h5><p>槽跟普通的方法一样，既要声明，也要定义，可以当作普通的方法直接调用。在类的声明中，槽的声明要放在 <code>* slots</code> 部分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Receiver</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">  Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">(QString message)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; message;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="关联信号和槽-2"><a href="#关联信号和槽-2" class="headerlink" title="关联信号和槽"></a>关联信号和槽</h5><p>信号发射后，只有与之关联的槽会被调用。一个信号可以关联多个槽；一个槽也可以被多个信号关联。关联信号和槽的方法是：调用 <code>QObject::connect()</code> 方法，用信号和槽所在对象的地址作为第一和第三个参数，用 <code>SIGNAL()</code> 和 <code>SLOT()</code> 宏作为第二和第四个参数，<code>SIGNAL()</code> 和 <code>SLOT()</code> 宏的参数分别是信号和槽的签名。例如，将 <code>Sender</code> 对象的 <code>messageGenerated()</code> 信号与 <code>Receiver</code> 对象的 <code>printMessage()</code> 槽关联：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Sender sender;</span><br><span class="line">  Receiver receiver;</span><br><span class="line"></span><br><span class="line">  QObject::<span class="built_in">connect</span>(&amp;sender, <span class="built_in">SIGNAL</span>(<span class="built_in">messageGenerated</span>(QString)), </span><br><span class="line">                   &amp;receiver, <span class="built_in">SLOT</span>(<span class="built_in">printMessage</span>(QString)));</span><br><span class="line"></span><br><span class="line">  sender.<span class="built_in">generateMessage</span>(); <span class="comment">// &quot;Hello, World!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="属性系统"><a href="#属性系统" class="headerlink" title="属性系统"></a>属性系统</h4><p>属性是逻辑上的公开成员变量。每个属性对应一个私有成员变量和两个专门用于读写该私有成员变量的公开成员函数。这两个公开成员函数分别称为属性的获取器（Getter）和设置器（Setter）。只有获取器的属性称为只读属性。每个属性还可以对应一个表示它的值发生变化的信号。属性的获取器和设置器以及它对应的信号的声明要仿照以下形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Getter</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setProp</span><span class="params">(T value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setter</span></span><br><span class="line"><span class="function">T <span class="title">prop</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Signal</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">propChanged</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">propChanged</span><span class="params">(<span class="type">const</span> T newValue)</span></span>;</span><br></pre></td></tr></table></figure>

<p>属性的作用之一是方便组件样式的定义。</p>
<h5 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h5><p>例如，要定义属性 <code>age</code>，需要声明一个私有成员变量 <code>age_</code> 和一个表示 <code>age_</code> 的值发生变化的信号 <code>ageChanged()</code>，再声明两个专门用于读写 <code>age_</code> 的公开成员函数 <code>age()</code> 和 <code>setAge()</code>，让 <code>setAge()</code> 在适当的时机发射信号 <code>ageChanged()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">  Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">User</span>() : <span class="built_in">age_</span>(<span class="number">0</span>)</span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    age_ = age;</span><br><span class="line">    <span class="function">emit <span class="title">ageChanged</span><span class="params">(age_)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">age</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ageChanged</span><span class="params">(<span class="type">const</span> <span class="type">int</span> newAge)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> age_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有了上述声明和定义，<code>User</code> 对象就好像拥有了一个名为 <code>age</code> 的公开成员变量，可以在其他函数中读写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User user;</span><br><span class="line">user.<span class="built_in">setAge</span>(<span class="number">18</span>);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; user.<span class="built_in">age</span>(); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>

<h5 id="声明属性"><a href="#声明属性" class="headerlink" title="声明属性"></a>声明属性</h5><p>属性系统提供了统一的读写属性的方法 <code>setProperty()</code> 和 <code>property()</code>。使用两个方法的前提是在类的声明中用 <code>Q_PROPERTY()</code> 宏声明属性。<code>Q_PROPERTY()</code> 宏支持两种声明属性的方式：一种是指定属性的获取器（和设置器），而无需指定属性对应的私有成员变量；另一种是指定属性对应的私有成员变量，而无需定义属性的获取器和设置器。例如，通过指定获取器和设置器的方式声明属性 <code>age</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">Q_OBJECT</span></span><br><span class="line"><span class="function">  <span class="title">Q_PROPERTY</span><span class="params">(<span class="type">int</span> age READ age WRITE setAge NOTIFY ageChanged)</span></span></span><br></pre></td></tr></table></figure>

<p><code>int age</code> 表示该属性是 <code>int</code> 型变量，属性名为 <code>age</code>。属性名无需和它对应的私有成员变量名保持一致。<code>READ age</code> 表示该属性的获取器为 <code>age()</code>。<code>WRITE setAge</code> 表示该属性可写，设置器为 <code>setAge()</code>；<code>NOTIFY ageChanged</code> 表示该属性发生变化时会发射的信号为 <code>ageChanged()</code>。</p>
<p>声明过的属性可以用 <code>setProperty()</code> 和 <code>property()</code> 两个方法读写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user.<span class="built_in">setProperty</span>(<span class="string">&quot;age&quot;</span>, <span class="number">19</span>);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; user.<span class="built_in">property</span>(<span class="string">&quot;age&quot;</span>).<span class="built_in">toInt</span>(); <span class="comment">// 19</span></span><br></pre></td></tr></table></figure>

<p><code>property()</code> 方法总是返回一个 <code>QVariant</code> 对象。它有一系列 <code>to*()</code> 方法用于将属性的值转换为需要的类型。</p>
<p>用第二种方式声明属性时，无需定义属性的获取器和设置器。例如，要定义一个名为 <code>email</code> 的属性并用第二种方式声明，只需修改类的头文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">Q_OBJECT</span></span><br><span class="line"><span class="function">  <span class="title">Q_PROPERTY</span><span class="params">(QString email MEMBER email_ NOTIFY emailChanged)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">signals:</span></span><br><span class="line"><span class="function">  void emailChanged(const QString &amp;newEmail);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  QString email_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>MEMBER email_</code> 表示该属性对应的私有成员变量是 <code>email_</code>。</p>
<p>没有获取器和设置器的属性同样可以用 <code>setProperty()</code> 和 <code>property()</code> 两个方法读写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user.<span class="built_in">setProperty</span>(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;your@example.com&quot;</span>);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; user.<span class="built_in">property</span>(<span class="string">&quot;email&quot;</span>).<span class="built_in">toString</span>(); <span class="comment">// &quot;your@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h5><p>动态属性是在运行时才定义的属性。在用 <code>setProperty()</code> 方法设置属性时，如果要设置的属性不存在，它就会立即定义一个动态属性。例如，定义一个名为 <code>name</code> 的动态属性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user.<span class="built_in">setProperty</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;John&quot;</span>);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; user.<span class="built_in">property</span>(<span class="string">&quot;name&quot;</span>).<span class="built_in">toString</span>(); <span class="comment">// &quot;John&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="元对象"><a href="#元对象" class="headerlink" title="元对象"></a>元对象</h4><p><code>QObject</code> 类及其派生类都对应一个 <code>QMetaObject</code> 对象。<code>QObject</code> 类及其派生类的元对象可以通过它们的 <code>metaObject()</code> 方法获取。元对象包含派生类的元数据，比如派生类包含的成员函数、构造函数和枚举成员的信息以及派生类的类名等。例如，派生类的类名可以通过调用元对象的 <code>className()</code> 方法获得：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> QMetaObject* userMetaObject = user.<span class="built_in">metaObject</span>();</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; userMetaObject-&gt;<span class="built_in">className</span>(); <span class="comment">// User</span></span><br></pre></td></tr></table></figure>

<p>每个 <code>QObject</code> 派生类对应一个元对象，不同的 <code>QObject</code> 派生类对应不同的元对象。同一个 <code>QObject</code> 派生类的不同对象的 <code>metaObject()</code> 方法返回的元对象都是同一个。</p>
<p>为了便于叙述，下文将 <code>QObject</code> 类及其派生类的对象都称为 <code>QObject</code> 对象。</p>
<h5 id="属性的信息"><a href="#属性的信息" class="headerlink" title="属性的信息"></a>属性的信息</h5><p>在类的声明中用 <code>Q_PROPERTY()</code> 宏声明的各个属性的信息，可以通过元对象获取。元对象的 <code>propertyCount()</code> 方法返回属性的个数；<code>property()</code> 方法返回包含指定属性元数据的 <code>QMetaProperty</code> 对象。<code>QMetaProperty</code> 对象的 <code>name()</code> 和 <code>typeName()</code> 方法分别返回属性的属性名和类型名。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMetaProperty&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> count = userMetaObject-&gt;<span class="built_in">propertyCount</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">  QMetaProperty metaProperty = userMetaObject-&gt;<span class="built_in">property</span>(i);</span><br><span class="line">  <span class="built_in">qDebug</span>() &lt;&lt; metaProperty.<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; metaProperty.<span class="built_in">typeName</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// objectName: QString</span></span><br><span class="line"><span class="comment">// age : int</span></span><br><span class="line"><span class="comment">// email : QString</span></span><br></pre></td></tr></table></figure>

<p>有了属性名，就可以访问属性的值。此时有两种方式可以访问属性的值：一种是像上文那样调用 <code>QObject</code> 对象的 <code>property()</code> 方法，用属性名作为参数；另一种是调用 <code>QMetaProperty</code> 对象的 <code>read()</code> 方法，用 <code>QObject</code> 对象的地址作为参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QMetaProperty metaProperty = userMetaObject-&gt;<span class="built_in">property</span>(<span class="number">1</span>);</span><br><span class="line">user.<span class="built_in">setProperty</span>(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; user.<span class="built_in">property</span>(metaProperty.<span class="built_in">name</span>()); <span class="comment">// QVariant(int, 18)</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; metaProperty.<span class="built_in">read</span>(&amp;user);           <span class="comment">// QVariant(int, 18)</span></span><br></pre></td></tr></table></figure>

<h5 id="类的附加信息"><a href="#类的附加信息" class="headerlink" title="类的附加信息"></a>类的附加信息</h5><p>类的附加信息是一组键名和键值都是字符串的键值对，要用 <code>Q_CLASSINFO()</code> 宏声明，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">Q_OBJECT</span></span><br><span class="line"><span class="function">  <span class="title">Q_CLASSINFO</span><span class="params">(<span class="string">&quot;Author&quot;</span>, <span class="string">&quot;John&quot;</span>)</span></span></span><br><span class="line"><span class="function">  <span class="title">Q_CLASSINFO</span><span class="params">(<span class="string">&quot;Version&quot;</span>, <span class="string">&quot;1.0.0&quot;</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>派生类及其基类的附加信息都可以通过派生类的元对象访问。元对象的 <code>classInfoOffset()</code> 方法返回派生类第一项附加信息的索引；<code>classInfoCount()</code> 方法返回派生类的附加信息数；<code>classInfo()</code> 方法根据附加信息的索引返回一个用于表示一项附加信息的 <code>QMetaClassInfo</code> 对象，其 <code>name()</code> 和 <code>value()</code> 方法分别返回附加信息的键名和键值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMetaClassInfo&gt;</span></span></span><br><span class="line"><span class="type">int</span> offset = userMetaObject-&gt;<span class="built_in">classInfoOffset</span>();</span><br><span class="line"><span class="type">int</span> count = userMetaObject-&gt;<span class="built_in">classInfoCount</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">  QMetaClassInfo classInfo = userMetaObject-&gt;<span class="built_in">classInfo</span>(i + offset);</span><br><span class="line">  <span class="built_in">qDebug</span>() &lt;&lt; classInfo.<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; classInfo.<span class="built_in">value</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Author : John</span></span><br><span class="line"><span class="comment">// Version : 1.0.0</span></span><br></pre></td></tr></table></figure>

<h4 id="对象树"><a href="#对象树" class="headerlink" title="对象树"></a>对象树</h4><p><code>QObject</code> 类及其派生类的对象可以组成一棵树。每个 <code>QObject</code> 对象可以有一个父对象和多个子对象。父对象可以用 <code>setParent()</code> 方法设置，用 <code>parent()</code> 方法获取。例如，创建三个 <code>QObject</code> 对象，将其中一个对象设置为另外两个对象的父对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QObject* parent = <span class="keyword">new</span> QObject;</span><br><span class="line">QObject* child1 = <span class="keyword">new</span> QObject;</span><br><span class="line">QObject* child2 = <span class="keyword">new</span> QObject;</span><br><span class="line"></span><br><span class="line">child1-&gt;<span class="built_in">setParent</span>(parent);</span><br><span class="line">child2-&gt;<span class="built_in">setParent</span>(parent);</span><br></pre></td></tr></table></figure>

<p>为 <code>QObject</code> 对象设置父对象后，该对象就自动成为父对象的子对象，因此没有专门用于添加子对象的方法。子对象的列表可以用 <code>children()</code> 方法获取。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QObject*&gt; children = parent-&gt;<span class="built_in">children</span>();</span><br></pre></td></tr></table></figure>

<p><code>QObject</code> 对象的析构函数会将它从父对象的子对象列表中移除，从而解除它和父对象之间的父子关系。</p>
<p>为了区分不同的 <code>QObject</code> 对象，可以利用它们的 <code>objectName</code> 属性。<code>QObject</code> 对象的 <code>objectName</code> 属性是它的名称，可以用 <code>setObjectName()</code> 方法设置，用 <code>objectName()</code> 方法获取，默认值为空字符串。例如，为上述三个 <code>QObject</code> 对象设置不同的名称：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent-&gt;<span class="built_in">setObjectName</span>(<span class="string">&quot;Parent&quot;</span>);</span><br><span class="line">child1-&gt;<span class="built_in">setObjectName</span>(<span class="string">&quot;Child 1&quot;</span>);</span><br><span class="line">child2-&gt;<span class="built_in">setObjectName</span>(<span class="string">&quot;Child 2&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>QObject</code> 对象的 <code>dumpObjectTree()</code> 方法可以将它和它的子对象形成的树状结构用文字直观地表示出来并输出到调试输出窗口中，方便调试。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">parent-&gt;<span class="built_in">dumpObjectTree</span>();</span><br><span class="line"><span class="comment">// QObject::Parent</span></span><br><span class="line"><span class="comment">//     QObject::Child 1</span></span><br><span class="line"><span class="comment">//     QObject::Child 2</span></span><br></pre></td></tr></table></figure>

<h5 id="析构顺序"><a href="#析构顺序" class="headerlink" title="析构顺序"></a>析构顺序</h5><p>父对象的析构函数会调用子对象的析构函数。如果树中的对象是局部变量，为了避免子对象的析构函数被调用两次，要确保子对象的析构函数先于父对象的析构函数被调用，从而解除它们之间的父子关系。换言之，子对象要在父对象之后定义，因为 C++ 标准规定，局部对象的析构函数的调用顺序与它们的构造函数的相反。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// correct</span></span><br><span class="line">QObject parent;</span><br><span class="line">QObject child;</span><br><span class="line">child.<span class="built_in">setParent</span>(&amp;parent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// incorrect</span></span><br><span class="line">QObject child;</span><br><span class="line">QObject parent;</span><br><span class="line">child.<span class="built_in">setParent</span>(&amp;parent);</span><br></pre></td></tr></table></figure>

<h4 id="事件系统"><a href="#事件系统" class="headerlink" title="事件系统"></a>事件系统</h4><p>事件系统是元对象系统提供的另一种对象间通信机制。事件用抽象类 <code>QEvent</code> 的派生类表示。事件发生时，特定 <code>QObject</code> 对象可以接收到一个事件对象。<code>QObject</code> 对象中负责接收事件对象的方法是虚函数 <code>event()</code>。它负责检查事件的类型，并将事件对象传递给事件处理器。事件类型可以通过事件对象的 <code>type()</code> 方法查询。事件类型用 <code>QEvent::Type</code> 的枚举成员表示。常见的事件类型有：</p>
<ul>
<li>键盘事件<ul>
<li><code>QEvent::KeyPress</code> 按键按下</li>
<li><code>QEvent::KeyRelease</code> 按键松开</li>
</ul>
</li>
<li>鼠标事件<ul>
<li><code>QEvent::MouseMove</code> 鼠标移动</li>
<li><code>QEvent::MouseButtonPress</code> 鼠标按下</li>
<li><code>QEvent::MouseButtonRelease</code> 鼠标松开</li>
<li><code>QEvent::MouseButtonDblClick</code> 鼠标双击</li>
<li><code>QEvent::Enter</code> 鼠标进入</li>
<li><code>QEvent::Leave</code> 鼠标离开</li>
</ul>
</li>
</ul>
<h5 id="接收和处理事件"><a href="#接收和处理事件" class="headerlink" title="接收和处理事件"></a>接收和处理事件</h5><p><code>QObject</code> 类的派生类可以通过重写虚函数 <code>event()</code> 来自定义事件对象的处理过程，以便使用自定义的事件类型和事件处理器。例如，在 <code>event()</code> 方法中将代表按键按下事件的事件对象传递给自定义的事件处理器 <code>keyPressEvent()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">  Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">event</span><span class="params">(QEvent* e)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;<span class="built_in">type</span>() == QEvent::KeyPress) &#123;</span><br><span class="line">      <span class="built_in">keyPressEvent</span>(<span class="built_in">static_cast</span>&lt;QKeyEvent*&gt;(e));</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QObject::<span class="built_in">event</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">keyPressEvent</span><span class="params">(QKeyEvent* e)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;key pressed&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>若当前对象中有合适的事件处理器可以接收和处理事件对象，则 <code>event()</code> 方法返回 <code>true</code>，否则返回 <code>false</code>。派生类的 <code>event()</code> 方法应该调用基类的 <code>event()</code> 方法来处理它无法处理的事件。在 <code>QWidget</code> 类及其派生类的对象的 <code>event()</code> 方法中返回 <code>false</code> 会导致事件对象被发送给当前对象的父对象。</p>
<h5 id="创建和发送事件"><a href="#创建和发送事件" class="headerlink" title="创建和发送事件"></a>创建和发送事件</h5><p>事件对象可以用 <code>QApplication::sendEvent()</code> 方法立即发送给指定 <code>QObject</code> 对象。例如，将一个代表回车键按下事件的事件对象 <code>event</code> 发送给对象 <code>myObject</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyObject myObject;</span><br><span class="line"></span><br><span class="line"><span class="function">QKeyEvent <span class="title">event</span><span class="params">(QEvent::KeyPress, Qt::Key_Enter, Qt::NoModifier)</span></span>;</span><br><span class="line">QApplication::<span class="built_in">sendEvent</span>(&amp;myObject, &amp;event); <span class="comment">// key pressed</span></span><br></pre></td></tr></table></figure>

<h5 id="事件过滤器"><a href="#事件过滤器" class="headerlink" title="事件过滤器"></a>事件过滤器</h5><p>可以在一个 <code>QObject</code> 对象上安装一个或多个事件过滤器，用来过滤要发送给这个 <code>QObject</code> 对象的事件对象。事件过滤器也是 <code>QObject</code> 类的派生类，它的 <code>eventFilter()</code> 方法可以在它所在 <code>QObject</code> 对象之前接收到事件对象并决定它所在 <code>QObject</code> 对象能否接收到事件对象。如果 <code>eventFilter()</code> 方法返回 <code>true</code>，事件对象就会被丢弃。例如，定义一个将所有按键按下事件丢弃的事件过滤器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KeyPressFilter</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">  Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">eventFilter</span><span class="params">(QObject* obj, QEvent* event)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event-&gt;<span class="built_in">type</span>() == QEvent::KeyPress) &#123;</span><br><span class="line">      <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;key event filtered&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QObject::<span class="built_in">eventFilter</span>(obj, event);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>要给一个 <code>QObject</code> 对象安装事件过滤器，只需调用它的 <code>installEventFilter()</code> 方法，用事件过滤器作为参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KeyPressFilter keyPressFilter;</span><br><span class="line">myObject.<span class="built_in">installEventFilter</span>(&amp;keyPressFilter);</span><br></pre></td></tr></table></figure>

<h3 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h3><p><code>QWidget</code> 类是 <code>QObject</code> 的子类。<code>QWidget</code> 类及其派生类的对象表示一个组件，它是组成图形用户界面的基本元素。界面上的元素，小到按钮，大到窗口，都是由组件形成的。例如，要创建并显示一个窗口，只需创建一个 <code>QWidget</code> 对象并调用它的 <code>show()</code> 方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">QApplication <span class="title">application</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">  QWidget window;</span><br><span class="line">  window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;My app&quot;</span>);</span><br><span class="line">  window.<span class="built_in">resize</span>(<span class="number">320</span>, <span class="number">240</span>);</span><br><span class="line">  window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> application.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用它的 <code>show()</code> 方法将窗口显示出来之前，还可以调用它的 <code>setWindowTitle()</code> 方法设置窗口的标题，调用它的 <code>resize()</code> 方法设置窗口的大小。</p>
<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230221104534422.png" alt="image-20230221104534422"></p>
<p>为了便于叙述，下文将 <code>QWidget</code> 类及其派生类的对象统称为 <code>QWidget</code> 对象。</p>
<h4 id="组件和窗口"><a href="#组件和窗口" class="headerlink" title="组件和窗口"></a>组件和窗口</h4><p>窗口是特殊的组件，通常带有标题栏和边框。窗口可以分为主窗口（Primary window）和副窗口（Secondary window）两种。它们的区别在于有无对应的任务栏按钮（Task bar entry）。对话框就是最典型的副窗口。主窗口是由没有父组件的组件形成的；副窗口是由有父组件且带有 <code>Qt::Window</code> 标志的组件形成的。这两种组件称为窗口组件或顶级组件（Top-level widgets），其他组件都称为非窗口组件（Non-window widgets）。非窗口组件是镶嵌在父组件中的组件。</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Parent</th>
<th>Flag</th>
</tr>
</thead>
<tbody><tr>
<td>Primary window</td>
<td>N</td>
<td></td>
</tr>
<tr>
<td>Secondary window</td>
<td>Y</td>
<td>Qt::Window</td>
</tr>
<tr>
<td>Non-window widgets</td>
<td>Y</td>
<td></td>
</tr>
</tbody></table>
<p><code>QWidget</code> 类的派生类 <code>QMainWindow</code> 和 <code>QDialog</code> 是上述两种窗口的封装。<code>QMainWindow</code> 对象表示一个带有标题栏、工具栏、中心组件和状态栏的主窗口。中心组件可以是任意非窗口组件。<code>QDialog</code> 对象表示一个带有一组按钮的对话框，属于副窗口。</p>
<h4 id="组件位置和尺寸"><a href="#组件位置和尺寸" class="headerlink" title="组件位置和尺寸"></a>组件位置和尺寸</h4><p>组件由客户区（Client Area）和四周的非客户区两部分组成。非客户区也称窗口框架（Window frame），包括窗口的标题栏和边框两部分。具有非客户区的窗口组件也称有装饰（Decorated）的顶级组件。非窗口组件默认不具非客户区。每个组件都有两个指示其位置和尺寸的属性：</p>
<ul>
<li><code>geometry</code> 属性是一个 <code>QRect</code> 对象，指示客户区的尺寸（宽和高）及其相对父组件（或桌面）的位置（左上角的坐标），可以用 <code>resize()</code> 方法设置，用下列方法读取：<ul>
<li><code>geometry()</code> 返回一个 <code>QRect</code> 对象，指示客户区的尺寸和位置。</li>
<li><code>size()</code> 返回一个 <code>QSize</code> 对象，指示客户区的尺寸，相当于 <code>geometry().size()</code>。</li>
<li><code>width()</code> 返回客户区的宽度，相当于 <code>geometry().width()</code>。</li>
<li><code>height()</code> 返回客户区的高度，相当于 <code>geometry().height()</code>。</li>
<li><code>rect()</code> 返回一个 <code>QSize</code> 对象，指示客户区的尺寸，相当于 <code>QRect(0, 0, width(), height())</code>。</li>
</ul>
</li>
<li><code>frameGeometry</code> 属性是一个 <code>QRect</code> 对象，指示非客户区的尺寸及其相对父窗口（或桌面）的位置，可以用 <code>move()</code> 方法设置，用下列方法读取：<ul>
<li><code>frameGeometry()</code> 返回一个 <code>QRect</code> 对象，指示非客户区的尺寸和位置。</li>
<li><code>frameSize()</code> 返回一个 <code>QSize</code> 对象，指示非客户区的尺寸，相当于 <code>frameGeometry().size()</code>。</li>
<li><code>pos()</code> 返回非客户区左上角的坐标，相当于 <code>frameGeometry().topLeft()</code>。</li>
<li><code>x()</code> 返回非客户区的横坐标，相当于 <code>frameGeometry().x()</code>。</li>
<li><code>y()</code> 返回非客户区的纵坐标，相当于 <code>frameGeometry().y()</code>。</li>
</ul>
</li>
</ul>
<p>对于非窗口组件或无装饰的窗口组件，这两个属性的值相同。对于有装饰的窗口组件，窗口的标题和图标可以用 <code>setWindowTitle()</code> 和 <code>setWindowIcon()</code> 方法分别设置。</p>
<p>让一个组件成为非窗口组件的方法是调用它的 <code>setParent()</code> 方法，为它设置一个父对象。例如，创建一个按钮组件，并将它设置为窗口的子组件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QPushButton *button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Press me&quot;</span>);</span><br><span class="line">button-&gt;<span class="built_in">setParent</span>(&amp;window);</span><br><span class="line">button-&gt;<span class="built_in">move</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">button-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<p>坐标原点为客户区左上角，x 和 y 轴正方向分别为向右和向下方向。</p>
<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230221105603029.png" alt="image-20230221105603029"></p>
<h4 id="组件布局"><a href="#组件布局" class="headerlink" title="组件布局"></a>组件布局</h4><p>布局容器能够为其中的每个组件设置合适的位置和尺寸，使这些组件按一定规则排列。虽然一个组件只能安装一个布局容器，但是布局容器可以嵌套，从而组成各种复杂布局。</p>
<p>下面的程序首先创建两个组件，然后创建一个水平布局容器，接着将两个组件添加到水平布局容器中，最后将水平布局容器设置为主窗口的布局容器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">QLabel* label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;Password&quot;</span>);</span><br><span class="line">QLineEdit* lineEdit = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>();</span><br><span class="line"></span><br><span class="line">QHBoxLayout* layout = <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>();</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(lineEdit);</span><br><span class="line"></span><br><span class="line">QWidget window;</span><br><span class="line">window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;My app&quot;</span>);</span><br><span class="line">window.<span class="built_in">setMinimumWidth</span>(<span class="number">240</span>);</span><br><span class="line">window.<span class="built_in">setLayout</span>(layout);</span><br><span class="line">window.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230214173845116.png" alt="image-20230214173845116"></p>
<p>在上面的例子中， 非窗口组件 <code>label</code> 和 <code>lineEdit</code> 会成为窗口组件 <code>window</code> 的子组件，而不是布局容器 <code>layout</code> 的子组件。换言之，添加到布局容器中的组件会成为布局容器所在组件的子组件，而不是布局容器本身的子组件。</p>
<p>常用的布局容器有水平布局容器、垂直布局容器、网格布局容器和表单布局容器四种：</p>
<ul>
<li><code>QHBoxLayout</code> 使子组件排成一行</li>
<li><code>QVBoxLayout</code> 使子组件排成一列</li>
<li><code>QGridLayout</code> 将子组件放置在网格中</li>
<li><code>QFormLayout</code> 使子组件两两一行排列</li>
</ul>
<p>将组件添加到网格布局容器时，需要以行和列为单位设置组件的位置和尺寸。<code>QGridLayout</code> 对象的 <code>addWidget()</code> 方法有五个参数，原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QGridLayout::<span class="built_in">addWidget</span>(widget, fromRow, fromColumn, rowSpan, columnSpan);</span><br></pre></td></tr></table></figure>

<p>它表示将组件 <code>widget</code> 放置到第 <code>fromRow</code> 行、第 <code>fromColumn</code> 列，跨越 <code>rowSpan</code> 行、<code>rowSpan</code> 列。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QGridLayout* layout = <span class="keyword">new</span> <span class="built_in">QGridLayout</span>();</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(button1, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(button2, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(button3, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230223141429993.png" alt="image-20230223141429993"></p>
<p>要向表单布局容器添加组件，应该使用它的 <code>addRow()</code> 方法，一次添加两个组件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QLabel* label1 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;Email&quot;</span>);</span><br><span class="line">QLabel* label2 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;Password&quot;</span>);</span><br><span class="line"></span><br><span class="line">QLineEdit* lineEdit1 = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>();</span><br><span class="line">QLineEdit* lineEdit2 = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>();</span><br><span class="line"></span><br><span class="line">QFormLayout* layout = <span class="keyword">new</span> <span class="built_in">QFormLayout</span>();</span><br><span class="line">layout-&gt;<span class="built_in">addRow</span>(label1, lineEdit1);</span><br><span class="line">layout-&gt;<span class="built_in">addRow</span>(label2, lineEdit2);</span><br></pre></td></tr></table></figure>

<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230223141514897.png" alt="image-20230223141514897"></p>
<h5 id="尺寸信息"><a href="#尺寸信息" class="headerlink" title="尺寸信息"></a>尺寸信息</h5><p>组件的实际尺寸受下列四个属性的影响：</p>
<ul>
<li><code>sizeHint</code> 默认尺寸</li>
<li><code>minimumSizeHint</code> 最小尺寸</li>
<li><code>minimumSize</code> 最小尺寸</li>
<li><code>maximumSize</code> 最大尺寸</li>
</ul>
<p>只读属性 <code>sizeHint</code> 和 <code>minimumSizeHint</code> 都只是建议性尺寸。组件的实际尺寸既可以大于 <code>sizeHint</code>，也可以小于 <code>minimumSizeHint</code>，但不能小于 <code>minimumSize</code>，也不能大于 <code>maximumSize</code>。</p>
<p>组件的默认尺寸可以用 <code>sizeHint()</code> 方法查询，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QPushButton* button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Press me&quot;</span>);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; button-&gt;<span class="built_in">sizeHint</span>(); <span class="comment">// QSize(75, 23)</span></span><br></pre></td></tr></table></figure>

<p>要规定自定义组件的默认尺寸，只需重写 <code>sizeHint()</code> 方法。</p>
<h5 id="尺寸调整策略"><a href="#尺寸调整策略" class="headerlink" title="尺寸调整策略"></a>尺寸调整策略</h5><p>组件的 <code>sizePolicy</code> 属性是一个 <code>QSizePolicy</code> 对象，它描述了组件的尺寸调整策略，可以用 <code>sizePolicy()</code> 方法获取，用 <code>setSizePolicy()</code> 方法设置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QPushButton* button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Press me&quot;</span>);</span><br><span class="line">QSizePolicy sizePolicy = button-&gt;<span class="built_in">sizePolicy</span>();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">button-&gt;<span class="built_in">setSizePolicy</span>(sizePolicy);</span><br></pre></td></tr></table></figure>

<p>一个 <code>QSizePolicy</code> 对象包含两个 <code>QSizePolicy::Policy</code> 类型的枚举成员和两个伸缩因子。两个枚举成员分别规定组件在水平和垂直两个方向是否可以被拉伸或压缩。<code>QSizePolicy::Policy</code> 类型有下列成员：</p>
<table>
<thead>
<tr>
<th>枚举成员</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>QSizePolicy::Fixed</code></td>
<td>组件的尺寸固定为默认尺寸，不可伸缩。</td>
</tr>
<tr>
<td><code>QSizePolicy::Minimum</code></td>
<td>默认尺寸是最小尺寸。组件只能被拉伸。</td>
</tr>
<tr>
<td><code>QSizePolicy::Maximum</code></td>
<td>默认尺寸是最大尺寸。组件只能被压缩。</td>
</tr>
<tr>
<td><code>QSizePolicy::Preferred</code></td>
<td>默认尺寸是最佳尺寸。组件既能被拉伸，也能被压缩。</td>
</tr>
<tr>
<td><code>QSizePolicy::Expanding</code></td>
<td>默认尺寸是合理尺寸。组件既能被拉伸，也能被压缩，并且将优先占据更多空间。</td>
</tr>
<tr>
<td><code>QSizePolicy::MinimumExpanding</code></td>
<td>默认尺寸是最小尺寸。组件只能被拉伸，并且将优先占据更多空间。</td>
</tr>
<tr>
<td><code>QSizePolicy::Ignored</code></td>
<td>默认尺寸不重要。组件需要占据尽可能多的空间。</td>
</tr>
</tbody></table>
<p>例如，准备一个可以垂直拉伸，但不可以水平伸缩的按钮：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QPushButton* button1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Button 1&quot;</span>);</span><br><span class="line">QSizePolicy sizePolicy1 = button1-&gt;<span class="built_in">sizePolicy</span>();</span><br><span class="line"></span><br><span class="line">sizePolicy1.<span class="built_in">setHorizontalPolicy</span>(QSizePolicy::Fixed);</span><br><span class="line">sizePolicy1.<span class="built_in">setVerticalPolicy</span>(QSizePolicy::Minimum);</span><br><span class="line"></span><br><span class="line">button1-&gt;<span class="built_in">setSizePolicy</span>(sizePolicy1);</span><br></pre></td></tr></table></figure>

<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230223141600883.png" alt="image-20230223141600883"></p>
<p>伸缩因子的取值范围是 0 - 255。各组件的伸缩因子之比就是它们的伸缩量之比。例如，将两个按钮的水平伸缩因子分别设置为 1 和 2：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">QPushButton* button1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Button 1&quot;</span>);</span><br><span class="line">QPushButton* button2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Button 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">QSizePolicy sizePolicy1 = button1-&gt;<span class="built_in">sizePolicy</span>();</span><br><span class="line">QSizePolicy sizePolicy2 = button2-&gt;<span class="built_in">sizePolicy</span>();</span><br><span class="line"></span><br><span class="line">sizePolicy1.<span class="built_in">setHorizontalStretch</span>(<span class="number">1</span>);</span><br><span class="line">sizePolicy2.<span class="built_in">setHorizontalStretch</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">button1-&gt;<span class="built_in">setSizePolicy</span>(sizePolicy1);</span><br><span class="line">button2-&gt;<span class="built_in">setSizePolicy</span>(sizePolicy2);</span><br></pre></td></tr></table></figure>

<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230223141632103.png" alt="image-20230223141632103"></p>
<h4 id="绘图系统"><a href="#绘图系统" class="headerlink" title="绘图系统"></a>绘图系统</h4><p><code>QWidget</code>、<code>QPixmap</code> 和 <code>QImage</code> 都是 <code>QPaintDevice</code> 的派生类。<code>QPaintDevice</code> 对象表示一个绘图设备。用绘图工具可以在绘图设备的客户区中绘制图形和文字。绘图工具用 <code>QPainter</code> 对象表示。</p>
<p>当一个组件的部分或全部客户区需要被绘制或重新绘制时，组件会收到 <code>QPaintEvent</code> 事件对象，此时组件的事件处理器 <code>paintEvent()</code> 需要完成必要的绘图工作。比如在 (100, 50) 处绘制一个 200×100 的矩形：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent* e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  painter.<span class="built_in">drawRect</span>(<span class="built_in">QRect</span>(<span class="number">100</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">100</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>坐标原点为客户区左上角，x 和 y 轴正方向分别为向右和向下方向。</p>
<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230223100346357.png" alt="image-20230223100346357"></p>
<p>图形的轮廓和填充图案分别由绘图工具使用的画笔和画刷决定。在开始绘图前，应该设置画笔和画刷。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">QPen pen;</span><br><span class="line">pen.<span class="built_in">setColor</span>(Qt::red);           <span class="comment">// 颜色</span></span><br><span class="line">pen.<span class="built_in">setWidth</span>(<span class="number">3</span>);                 <span class="comment">// 线型</span></span><br><span class="line">pen.<span class="built_in">setStyle</span>(Qt::DashLine);      <span class="comment">// 线宽</span></span><br><span class="line">pen.<span class="built_in">setCapStyle</span>(Qt::FlatCap);    <span class="comment">// 端点样式</span></span><br><span class="line">pen.<span class="built_in">setJoinStyle</span>(Qt::MiterJoin); <span class="comment">// 连接点样式</span></span><br><span class="line">painter.<span class="built_in">setPen</span>(pen);</span><br><span class="line"></span><br><span class="line">QBrush brush;</span><br><span class="line">brush.<span class="built_in">setColor</span>(Qt::blue);          <span class="comment">// 颜色</span></span><br><span class="line">brush.<span class="built_in">setStyle</span>(Qt::Dense1Pattern); <span class="comment">// 样式</span></span><br><span class="line">painter.<span class="built_in">setBrush</span>(brush);</span><br></pre></td></tr></table></figure>

<h5 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h5><p>线段可以用 <code>drawLine()</code> 方法绘制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">painter.<span class="built_in">drawLine</span>(<span class="built_in">QLine</span>(<span class="number">10</span>, <span class="number">80</span>, <span class="number">90</span>, <span class="number">20</span>));</span><br></pre></td></tr></table></figure>

<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230223131435974.png" alt="image-20230223131435974"></p>
<p>默认情况下，<code>QPainter</code> 绘制的图形的边缘存在锯齿。要消除图形边缘的锯齿，只需调用 <code>setRenderHints()</code> 方法，添加抗锯齿标志。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">painter.<span class="built_in">setRenderHints</span>(QPainter::Antialiasing | QPainter::TextAntialiasing);</span><br></pre></td></tr></table></figure>

<p>四边形和多段线分别可以用 <code>drawPolygon()</code> 和 <code>drawPolyline()</code> 方法绘制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> QPointF points[<span class="number">4</span>] = &#123;</span><br><span class="line">  <span class="built_in">QPointF</span>(<span class="number">60.0</span>, <span class="number">130.0</span>),</span><br><span class="line">  <span class="built_in">QPointF</span>(<span class="number">70.0</span>, <span class="number">60.0</span>),</span><br><span class="line">  <span class="built_in">QPointF</span>(<span class="number">130.0</span>, <span class="number">90.0</span>),</span><br><span class="line">  <span class="built_in">QPointF</span>(<span class="number">140.0</span>, <span class="number">120.0</span>)</span><br><span class="line">&#125;;</span><br><span class="line">painter.<span class="built_in">drawPolygon</span>(points, <span class="number">4</span>);</span><br><span class="line">painter.<span class="built_in">drawPolyline</span>(points, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230224011813149.png" alt="image-20230224011813149"></p>
<p>弧弧、弦和扇形分别可以用 <code>drawArc()</code>、<code>drawChord()</code> 和 <code>drawPie()</code> 方法绘制。例如，绘制以矩形中心为圆点，从 0° 开始，转过 270° 的弧、弦和扇形：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QRect rect = <span class="built_in">QRect</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="type">int</span> startAngle = <span class="number">0</span>, spanAngle = <span class="number">270</span>;</span><br><span class="line">painter.<span class="built_in">drawArc</span>(rect, startAngle * <span class="number">16</span>, spanAngle * <span class="number">16</span>);</span><br><span class="line">painter.<span class="built_in">drawChord</span>(rect, startAngle * <span class="number">16</span>, spanAngle * <span class="number">16</span>);</span><br><span class="line">painter.<span class="built_in">drawPie</span>(rect, startAngle * <span class="number">16</span>, spanAngle * <span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230223131746388.png" alt="image-20230223131746388"></p>
<p>矩形、圆角矩形和椭圆分别可以用 <code>drawRect()</code>、<code>drawRoundedRect()</code> 和 <code>drawEllipse()</code> 方法绘制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QRect rect = <span class="built_in">QRect</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">painter.<span class="built_in">drawRect</span>(rect);</span><br><span class="line">painter.<span class="built_in">drawRoundedRect</span>(rect, <span class="number">15</span>, <span class="number">15</span>);</span><br><span class="line">painter.<span class="built_in">drawEllipse</span>(rect);</span><br></pre></td></tr></table></figure>

<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230223140827681.png" alt="image-20230223140827681"></p>
<p>填充矩形可以用 <code>fillRect()</code> 方法绘制。图片可以用 <code>drawImage()</code> 或 <code>drawPixmap()</code> 方法绘制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">painter.<span class="built_in">fillRect</span>(rect, Qt::blue);</span><br><span class="line"></span><br><span class="line">painter.<span class="built_in">drawImage</span>(<span class="built_in">QPoint</span>(<span class="number">50</span>, <span class="number">50</span>), <span class="built_in">QImage</span>(<span class="string">&quot;:/images/icon_Qt_78x78px.png&quot;</span>));</span><br><span class="line">painter.<span class="built_in">drawPixmap</span>(<span class="built_in">QPoint</span>(<span class="number">50</span>, <span class="number">50</span>), <span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/icon_Qt_78x78px.png&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230224012309532.png" alt="image-20230224012309532"></p>
<h5 id="设置字体"><a href="#设置字体" class="headerlink" title="设置字体"></a>设置字体</h5><p>在绘制文本之前，需要设置一种字体。首先要通过 <code>QFontDatabase</code>  对象确定可用字体的字型、风格和字号，然后创建一个 <code>QFont</code> 对象传递给 <code>QPainter</code> 对象。</p>
<p><code>QFontDatabase</code> 对象的 <code>families()</code> 方法可以列出系统中所有适用于某种书写系统的字型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QFontDatabase fontDatabase;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; fontDatabase.<span class="built_in">families</span>(QFontDatabase::SimplifiedChinese);</span><br><span class="line"><span class="comment">// (&quot;仿宋&quot;, &quot;宋体&quot;, &quot;新宋体&quot;, ..., &quot;黑体&quot;)</span></span><br></pre></td></tr></table></figure>

<p>某个字型支持的所有风格可以用 <code>styles()</code> 方法列出。某个字型的某种风格支持的所有字号可以用 <code>pointSizes()</code> 方法列出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; fontDatabase.<span class="built_in">styles</span>(<span class="string">&quot;Microsoft YaHei UI&quot;</span>);</span><br><span class="line"><span class="comment">// (&quot;Regular&quot;, &quot;Bold&quot;, &quot;Light&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; fontDatabase.<span class="built_in">pointSizes</span>(<span class="string">&quot;Microsoft YaHei UI&quot;</span>, <span class="string">&quot;Light&quot;</span>);</span><br><span class="line"><span class="comment">// (6, 7, 8, ..., 72)</span></span><br></pre></td></tr></table></figure>

<p>可以用静态方法 <code>addApplicationFont()</code> 从字体文件加载更多的字体。它返回一个整数作为字体 ID。若字体加载失败，则方法返回 <code>-1</code>。已加载的字体需要用 <code>removeApplicationFont()</code> 方法移除。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fontId = QFontDatabase::<span class="built_in">addApplicationFont</span>(<span class="string">&quot;./simsun.ttc&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fontId == <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;font could not be loaded&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">QFontDatabase::<span class="built_in">removeApplicationFont</span>(fontId);</span><br></pre></td></tr></table></figure>

<p>静态方法 <code>applicationFontFamilies</code> 方法可以列出从字体文件加载的字体中包含的所有字型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; QFontDatabase::<span class="built_in">applicationFontFamilies</span>(fontId);</span><br><span class="line"><span class="comment">// (&quot;SimSun&quot;, &quot;NSimSun&quot;)</span></span><br></pre></td></tr></table></figure>

<p><code>QFont</code> 对象可以直接用 <code>font()</code> 方法创建：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QFont font = fontDatabase.<span class="built_in">font</span>(<span class="string">&quot;Microsoft YaHei UI&quot;</span>, <span class="string">&quot;Light&quot;</span>, <span class="number">14</span>);</span><br><span class="line">painter.<span class="built_in">setFont</span>(font);</span><br></pre></td></tr></table></figure>

<h5 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h5><p>字体的尺寸信息可以通过 <code>QFontMetrics</code> 对象获取。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QFontMetrics <span class="title">fontMetrics</span><span class="params">(font)</span></span>;</span><br><span class="line"><span class="type">int</span> leading = fontMetrics.<span class="built_in">leading</span>();</span><br><span class="line"><span class="type">int</span> ascent  = fontMetrics.<span class="built_in">ascent</span>();</span><br><span class="line"><span class="type">int</span> descent = fontMetrics.<span class="built_in">descent</span>();</span><br><span class="line"><span class="type">int</span> height  = fontMetrics.<span class="built_in">height</span>();</span><br><span class="line"><span class="type">int</span> lineSpacing = fontMetrics.<span class="built_in">lineSpacing</span>();</span><br></pre></td></tr></table></figure>

<p>其中，<code>ascent</code> 是字符升部的高度；<code>descent</code> 是字符降部的高度；<code>height</code> 是字符的高度，等于 <code>ascent</code> 与 <code>descent</code> 之和；<code>lineSpacing</code> 是行高，等于 <code>leading</code> 与 <code>height</code> 之和。</p>
<p>用 <code>drawText()</code> 方法绘制文本时，需要指定基线左端的坐标。文本的宽度可以用 <code>boundingRect()</code> 方法获取。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QString text = QString::<span class="built_in">fromLocal8Bit</span>(<span class="string">&quot;你好，世界！&quot;</span>);</span><br><span class="line">painter.<span class="built_in">drawText</span>(<span class="built_in">QPoint</span>(<span class="number">50</span>, <span class="number">50</span> + leading + ascent), text);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> width = fontMetrics.<span class="built_in">boundingRect</span>(text).<span class="built_in">width</span>();</span><br><span class="line">painter.<span class="built_in">drawRect</span>(<span class="built_in">QRect</span>(<span class="number">50</span>, <span class="number">50</span>, width, height));</span><br></pre></td></tr></table></figure>

<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230224012636783.png" alt="image-20230224012636783"></p>
<h5 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h5><p>路径用一个 <code>QPainterPath</code> 对象表示，它可以保存一组图形、记录一组操作，常用于创建需要重复使用的复杂图形。例如，要反复绘制一个包含对角线的矩形，就可以借助路径来简化操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QPainterPath path;</span><br><span class="line">path.<span class="built_in">addRect</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">path.<span class="built_in">moveTo</span>(<span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">path.<span class="built_in">lineTo</span>(<span class="number">150</span>, <span class="number">150</span>);</span><br><span class="line">path.<span class="built_in">moveTo</span>(<span class="number">150</span>, <span class="number">50</span>);</span><br><span class="line">path.<span class="built_in">lineTo</span>(<span class="number">50</span>, <span class="number">150</span>);</span><br><span class="line">painter.<span class="built_in">drawPath</span>(path);</span><br></pre></td></tr></table></figure>

<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230224091138327.png" alt="image-20230224091138327"></p>
<h5 id="坐标变换"><a href="#坐标变换" class="headerlink" title="坐标变换"></a>坐标变换</h5><p>在用绘图工具绘制图形和文字时，图形和文字先后被映射到三个不同的坐标平面：首先，绘图工具将图形和文字绘制到「逻辑坐标平面」上；然后，绘图工具用一个坐标变换矩阵将图形和文字的逻辑坐标转换成窗口坐标，从而将图形和文字映射到「窗口坐标平面」上；最后，绘图工具再通过窗口-视口机制将图形和文字映射到「物理坐标平面」上。物理坐标平面就是绘图设备的客户区所在平面，其原点固定在客户区左上角。默认情况下，这三个坐标平面重合。</p>
<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230228013417275.png" alt="image-20230228013417275"></p>
<p>视口是物理坐标平面中的一块矩形区域；窗口是窗口坐标平面中的一块要和视口对应起来的矩形区域。简单来说，绘制在窗口中的图形将出现在视口中。例如，将物理坐标平面中左上角为原点的 200×200 矩形区域和窗口坐标平面中左上角为原点的 100×100 矩形区域对应起来：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">painter.<span class="built_in">setViewport</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">painter.<span class="built_in">setWindow</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>通过修改坐标变换矩阵，可以实现逻辑坐标平面的平移、旋转、缩放和剪切。例如，在上例的基础上，将逻辑坐标系的原点由窗口的左上角平移到中心，再将逻辑坐标平面顺时针旋转 90°：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">painter.<span class="built_in">translate</span>(<span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">painter.<span class="built_in">rotate</span>(<span class="number">90</span>);</span><br></pre></td></tr></table></figure>

<p>此时在原点处绘制一个 100×100 矩形和一段文本就可以得到上图的效果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">painter.<span class="built_in">fillRect</span>(<span class="built_in">QRect</span>(<span class="number">-50</span>, <span class="number">-50</span>, <span class="number">100</span>, <span class="number">100</span>), Qt::gray);</span><br><span class="line">painter.<span class="built_in">drawText</span>(<span class="built_in">QPoint</span>(<span class="number">0</span>, <span class="number">0</span>), QString::<span class="built_in">fromLocal8Bit</span>(<span class="string">&quot;ABC&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>坐标变换矩阵也可以直接用 <code>setWorldTransform()</code> 方法设置，用 <code>worldTransform()</code> 方法读取，用 <code>resetTransform()</code> 方法重置。因此调用 <code>resetTransform()</code> 方法就可以让逻辑坐标平面和窗口坐标平面恢复到重合状态。</p>
<h4 id="图形视图框架"><a href="#图形视图框架" class="headerlink" title="图形视图框架"></a>图形视图框架</h4><p>图形视图框架提供绘制可交互图形和文字的能力。</p>
<p><code>QGraphicsItem</code> 类的派生类的对象表示一个图形或一段文本，比如：</p>
<ul>
<li><code>QGraphicsLineItem</code> 对象表示一段线；</li>
<li><code>QGraphicsRectItem</code> 对象表示一个矩形；</li>
<li><code>QGraphicsEllipseItem</code> 对象表示一个椭圆；</li>
<li><code>QGraphicsPolygonItem</code> 对象表示一个多边形；</li>
<li><code>QGraphicsPixmapItem</code> 对象表示一幅位图；</li>
<li><code>QGraphicsTextItem</code> 对象表示一段文本。</li>
</ul>
<p>为了便于叙述，下文将这些派生类的对象统称为图元。</p>
<p><code>QGraphicsScene</code> 对象表示一个场景。场景是图元的容器，相当于一块画布。每个场景对应一个坐标平面，称为「场景坐标平面」。场景的位置和尺寸用一个矩形表示，称为「场景矩形」。例如，创建一个场景矩形为 <code>(0, 0, 160×100)</code> 的场景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QGraphicsScene* scene = <span class="keyword">new</span> <span class="built_in">QGraphicsScene</span>(<span class="built_in">QRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">160</span>, <span class="number">100</span>));</span><br></pre></td></tr></table></figure>

<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230301093025322.png" alt="image-20230301093025322"></p>
<p>场景中的图元可以落在场景矩形之外。添加图元时，要用一个矩形指示图元的位置和最大尺寸，称为「边界矩形」。例如，添加一个边界矩形为 <code>(0, 0, 100×50)</code> 的矩形到场景中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rect = <span class="keyword">new</span> <span class="built_in">QGraphicsRectItem</span>(<span class="built_in">QRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">50</span>));</span><br><span class="line">rect-&gt;<span class="built_in">setPen</span>(pen);</span><br><span class="line">rect-&gt;<span class="built_in">setBrush</span>(brush);</span><br><span class="line">scene-&gt;<span class="built_in">addItem</span>(rect);</span><br></pre></td></tr></table></figure>

<p>图元的轮廓和填充图案由它们使用的画笔和画刷决定。</p>
<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230301104728241.png" alt="image-20230301104728241"></p>
<p>添加到场景中的图元都是从各自的「图元坐标平面」映射到场景坐标平面的。一个图元坐标平面相当于 Photoshop 中的一个图层。图元坐标系默认与场景坐标系重合，可以用 <code>setPos()</code> 方法让图元坐标系的原点与场景坐标平面上的另一点重合。例如，绘制一个边界矩形为 <code>(0, 0, 50×50)</code> 的圆，再将圆坐标系的原点平移到 <code>(-25, 25)</code> 点，这样圆心就会与场景坐标系的原点重合：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ellipse = <span class="keyword">new</span> <span class="built_in">QGraphicsEllipseItem</span>(<span class="built_in">QRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">50</span>));</span><br><span class="line">ellipse-&gt;<span class="built_in">setPos</span>(<span class="number">-25</span>, <span class="number">-25</span>);</span><br><span class="line">scene-&gt;<span class="built_in">addItem</span>(ellipse);</span><br></pre></td></tr></table></figure>

<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230301161029547.png" alt="image-20230301161029547"></p>
<p>通过平移、旋转和缩放图元坐标平面，就可以独立地控制每个图元的位置、朝向和尺寸。例如，让上例中的矩形图元坐标平面以 <code>(0, 50)</code> 为基点顺时针旋转 90°：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rect-&gt;<span class="built_in">setTransformOriginPoint</span>(<span class="built_in">QPoint</span>(<span class="number">0</span>, <span class="number">50</span>));</span><br><span class="line">rect-&gt;<span class="built_in">setRotation</span>(<span class="number">90</span>);</span><br></pre></td></tr></table></figure>

<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230301160954557.png" alt="image-20230301160954557"></p>
<p><code>QGraphicsView</code> 对象表示一个视图。视图是一种能够按需提供滚动条的组件，用于可视化场景。例如，创建一个 <code>300×220</code> 的视图，用它显示上述场景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">view = <span class="keyword">new</span> <span class="built_in">QGraphicsView</span>();</span><br><span class="line">view-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line">view-&gt;<span class="built_in">resize</span>(<span class="number">300</span>, <span class="number">220</span>);</span><br><span class="line">view-&gt;<span class="built_in">setScene</span>(scene);</span><br><span class="line">view-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<p>默认情况下，当场景的尺寸小于视图时，即滚动条未出现时，视图会根据场景矩形自动居中显示场景。</p>
<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230301160911064.png" alt="image-20230301160911064"></p>
<p>场景在视图中的对齐方式是由视图的 <code>alignment</code> 属性决定的，可以用 <code>setAlignment()</code> 方法改变。例如，让场景停靠在视图左上角：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view-&gt;<span class="built_in">setAlignment</span>(Qt::AlignLeft | Qt::AlignTop);</span><br></pre></td></tr></table></figure>

<p>视图的客户区对应的坐标平面称为「视图坐标平面」，其原点固定在客户区左上角。视图用一个坐标变换矩阵将场景坐标平面映射到视图坐标平面，因此它可以显示经过平移、旋转和缩放的场景。例如，将上述场景坐标平面顺时针旋转 90°，基点是场景坐标平面上与视图中心重合的那一点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view-&gt;<span class="built_in">rotate</span>(<span class="number">90</span>);</span><br></pre></td></tr></table></figure>

<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230301162249727.png" alt="image-20230301162249727"></p>
<p>场景缩放和旋转的基点由 <code>transformationAnchor</code> 属性决定的，可以用 <code>setTransformationAnchor()</code> 方法改变，有三种基点可以选择：</p>
<ul>
<li><code>QGraphicsView::NoAnchor</code> 场景坐标系的原点；</li>
<li><code>QGraphicsView::AnchorViewCenter</code> 与视图中心重合的点（场景绕视图中心旋转）；</li>
<li><code>QGraphicsView::AnchorUnderMouse</code> 当鼠标在视图中时，以鼠标的位置为基点（场景绕鼠标旋转）；否则以视图中心为基点。</li>
</ul>
<h5 id="视图控制"><a href="#视图控制" class="headerlink" title="视图控制"></a>视图控制</h5><p>默认情况下，图元既不能获得焦点，也不能被选中，更不能被拖动。要调整图元的行为，只需调用它的 <code>setFlags()</code> 方法给它设置不同的标志。例如，给图元设置 <code>QGraphicsItem::ItemIsMovable</code> 标志，让它可以被拖动：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rect-&gt;<span class="built_in">setFlags</span>(QGraphicsItem::ItemIsMovable);</span><br></pre></td></tr></table></figure>

<p>其他标志的含义如下：</p>
<ul>
<li><code>QGraphicsItem::ItemIsSelectable</code> 让图元可以被选中；</li>
<li><code>QGraphicsItem::ItemIsFocusable</code> 让图元可以获得焦点；</li>
<li><code>QGraphicsItem::ItemClipsToShape</code> 让图元以它的外轮廓为边界矩形。图元不能接收到发生在边界矩形之外的键盘事件和鼠标事件。</li>
</ul>
<p>视图的拖拽模式决定用户在场景的空白处按下并拖拽鼠标时会发生什么。视图的拖拽模式可以用 <code>setDragMode()</code> 方法设置：当拖拽模式为 <code>QGraphicsView::ScrollHandDrag</code> 时，用户可以用鼠标拖动场景；当拖拽模式为 <code>QGraphicsView::RubberBandDrag</code> 时，用户可以用鼠标框选场景中的图元。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view-&gt;<span class="built_in">setDragMode</span>(QGraphicsView::ScrollHandDrag);</span><br></pre></td></tr></table></figure>

<p>缩放和旋转场景需要调用视图的 <code>scale()</code> 和 <code>rotate()</code> 方法。例如，在自定义的视图类中，可以定义下列负责缩放和旋转场景的槽：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyGraphicsView</span> : <span class="keyword">public</span> QGraphicsView</span><br><span class="line">&#123;</span><br><span class="line">  Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">zoomIn</span><span class="params">()</span> </span>&#123; <span class="built_in">scale</span>(<span class="number">1.2</span>, <span class="number">1.2</span>); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">zoomOut</span><span class="params">()</span> </span>&#123; <span class="built_in">scale</span>(<span class="number">1</span> / <span class="number">1.2</span>, <span class="number">1</span> / <span class="number">1.2</span>); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">rotateLeft</span><span class="params">()</span> </span>&#123; <span class="built_in">rotate</span>(<span class="number">-90</span>); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">rotateRight</span><span class="params">()</span> </span>&#123; <span class="built_in">rotate</span>(<span class="number">90</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="坐标转换"><a href="#坐标转换" class="headerlink" title="坐标转换"></a>坐标转换</h5><p>在自定义视图的鼠标事件处理器中，鼠标单击位置是用视图坐标表示的。要将视图坐标转换成场景坐标，可以用 <code>mapToScene()</code>；反之用 <code>mapFromScene()</code> 方法。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyGraphicsView</span> : <span class="keyword">public</span> QGraphicsView</span><br><span class="line">&#123;</span><br><span class="line">  Q_OBJECT</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent* event)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    QPoint viewPos = event-&gt;<span class="built_in">pos</span>();</span><br><span class="line">    QPointF scenePos = <span class="keyword">this</span>-&gt;<span class="built_in">mapToScene</span>(viewPos);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    QGraphicsView::<span class="built_in">mousePressEvent</span>(event);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在得到场景坐标后，就可以调用场景的 <code>itemAt()</code> 方法获取位于该点且处于最顶层的图元。图元的 <code>mapFromScene()</code> 方法可以把场景坐标进一步转换成图元坐标。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QGraphicsItem* item = <span class="keyword">this</span>-&gt;<span class="built_in">scene</span>()-&gt;<span class="built_in">itemAt</span>(scenePos, <span class="keyword">this</span>-&gt;<span class="built_in">transform</span>());</span><br><span class="line"><span class="keyword">if</span> (item == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="built_in">qDebug</span>() &lt;&lt; viewPos &lt;&lt; <span class="string">&quot;=&gt;&quot;</span> &lt;&lt; scenePos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  QPointF itemPos = item-&gt;<span class="built_in">mapFromScene</span>(scenePos);</span><br><span class="line">  <span class="built_in">qDebug</span>() &lt;&lt; viewPos &lt;&lt; <span class="string">&quot;=&gt;&quot;</span> &lt;&lt; scenePos &lt;&lt; <span class="string">&quot;=&gt;&quot;</span> &lt;&lt; itemPos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，单击场景坐标平面中的点 <code>(50, 50)</code>，相当于单击矩形所在图元坐标平面的原点。</p>
<p>图元的边界矩形可以用它的 <code>boundingRect()</code> 或 <code>sceneBoundingRect()</code> 方法获取，前者返回的矩形是用图元坐标表示的；后者返回的矩形是用场景坐标表示的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QRectF boundingRect = item-&gt;<span class="built_in">boundingRect</span>();</span><br><span class="line">QRectF sceneBoundingRect = item-&gt;<span class="built_in">sceneBoundingRect</span>();</span><br></pre></td></tr></table></figure>

<h4 id="组件事件"><a href="#组件事件" class="headerlink" title="组件事件"></a>组件事件</h4><h5 id="滚轮事件"><a href="#滚轮事件" class="headerlink" title="滚轮事件"></a>滚轮事件</h5><p>滚轮事件在用户滚动鼠标滚轮时发生。滚轮事件对象的 <code>angleDelta()</code> 方法可以返回滚轮转过的角度，以八分之一度为单位。角度的符号指示滚轮滚动的方向：正数表示滚轮朝着远离用户的方向向前滚动，通常代表向上翻（或向左翻）或放大操作；负数表示滚轮朝着靠近用户的方向向后滚动，通常代表向下翻（或向右翻）或缩小操作。根据用户在滚动鼠标滚轮时是否有按下 Shift 键，可以把用户滚动鼠标滚轮的目的分为横向滚动和纵向滚动。这两种情况下滚轮转过的角度分别由 <code>angleDelta().y()</code> 和 <code>angleDelta().x()</code> 指示。用户滚动鼠标滚轮时，鼠标指针的位置可以用 <code>position()</code> 方法获取。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">wheelEvent</span><span class="params">(QWheelEvent* event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  QPointF pos = event-&gt;<span class="built_in">position</span>();</span><br><span class="line">  QPointF degree = event-&gt;<span class="built_in">angleDelta</span>() / <span class="number">8</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!degree.<span class="built_in">isNull</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> horDegree = degree.<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">if</span> (horDegree &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;pos&quot;</span> &lt;&lt; pos &lt;&lt; <span class="string">&quot;, horDegree&quot;</span> &lt;&lt; horDegree;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  event-&gt;<span class="built_in">accept</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="拖放机制"><a href="#拖放机制" class="headerlink" title="拖放机制"></a>拖放机制</h4><p>拖放即拖拽（Drag）和放置（Drop），是一种可视化的组件间和应用间数据传输机制。拖放操作的过程是用户按下鼠标左键并移动鼠标一段距离后再松开鼠标左键的过程。可见，拖放操作包含拖拽和放置两个动作，其结果是源组件向目标组件传输了一份数据。源组件和目标组件可以是同一个。如果拖放操作的放置动作只是移动数据而不是复制数据，源组件还要负责删除原始数据。</p>
<h5 id="开始拖拽"><a href="#开始拖拽" class="headerlink" title="开始拖拽"></a>开始拖拽</h5><p>拖放操作通常要在用户按下鼠标左键并移动鼠标一段距离后才能触发。为此，在 <code>mousePressEvent()</code> 方法中记录鼠标的位置，在 <code>mouseMoveEvent()</code> 方法中检查鼠标移动过的距离并决定是否要开始一次拖放操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">QPoint dragStartPos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent* event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event-&gt;<span class="built_in">button</span>() == Qt::LeftButton)</span><br><span class="line">    dragStartPos = event-&gt;<span class="built_in">pos</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent* event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(event-&gt;<span class="built_in">buttons</span>() &amp; Qt::LeftButton))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> dis = (event-&gt;<span class="built_in">pos</span>() - dragStartPos).<span class="built_in">manhattanLength</span>();</span><br><span class="line">  <span class="keyword">if</span> (dis &lt; QApplication::<span class="built_in">startDragDistance</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  QLabel* label = <span class="built_in">static_cast</span>&lt;QLabel*&gt;(<span class="keyword">this</span>-&gt;<span class="built_in">childAt</span>(event-&gt;<span class="built_in">pos</span>()));</span><br><span class="line">  <span class="keyword">if</span> (label == <span class="literal">nullptr</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开始一次拖放操作的方法是在 <code>mouseMoveEvent()</code> 方法中创建一个 <code>QDrag</code> 对象并调用它的 <code>exec()</code> 方法。需要传输的数据要用一个 <code>QMimeData</code> 对象描述和保存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent* event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  QPixmap pixmap = label-&gt;<span class="built_in">pixmap</span>(Qt::ReturnByValue);</span><br><span class="line">  QPoint pixmapPos = event-&gt;<span class="built_in">pos</span>() - label-&gt;<span class="built_in">pos</span>();</span><br><span class="line"></span><br><span class="line">  QByteArray itemData;</span><br><span class="line">  <span class="function">QDataStream <span class="title">dataStream</span><span class="params">(&amp;itemData, QIODevice::WriteOnly)</span></span>;</span><br><span class="line">  dataStream &lt;&lt; pixmap &lt;&lt; pixmapPos;</span><br><span class="line"></span><br><span class="line">  QMimeData* mimeData = <span class="keyword">new</span> QMimeData;</span><br><span class="line">  mimeData-&gt;<span class="built_in">setData</span>(<span class="string">&quot;application/octet-stream&quot;</span>, itemData);</span><br><span class="line"></span><br><span class="line">  QDrag* drag = <span class="keyword">new</span> <span class="built_in">QDrag</span>(<span class="keyword">this</span>);</span><br><span class="line">  drag-&gt;<span class="built_in">setPixmap</span>(pixmap);</span><br><span class="line">  drag-&gt;<span class="built_in">setHotSpot</span>(pixmapPos);</span><br><span class="line">  drag-&gt;<span class="built_in">setMimeData</span>(mimeData);</span><br><span class="line"></span><br><span class="line">  Qt::DropAction dropAction = drag-&gt;<span class="built_in">exec</span>(Qt::CopyAction | Qt::MoveAction, </span><br><span class="line">                                         Qt::MoveAction);</span><br><span class="line">  <span class="keyword">if</span> (dropAction == Qt::MoveAction) &#123;</span><br><span class="line">    <span class="keyword">delete</span> label;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>QDrag</code> 和 <code>QMimeData</code> 对象均无需手动销毁。</p>
<p><code>QDrag</code> 对象的 <code>setPixmap()</code> 方法用于设置在拖放过程中跟随鼠标移动的位图；<code>setHotSpot()</code> 方法用于设置鼠标相对位图左上角的位置；<code>setMimeData()</code> 方法用于设置需要传输的数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QDrag* drag = <span class="keyword">new</span> <span class="built_in">QDrag</span>(<span class="keyword">this</span>);</span><br><span class="line">drag-&gt;<span class="built_in">setPixmap</span>(pixmap);</span><br><span class="line">drag-&gt;<span class="built_in">setHotSpot</span>(pixmapPos);</span><br><span class="line">drag-&gt;<span class="built_in">setMimeData</span>(mimeData);</span><br></pre></td></tr></table></figure>

<p><code>QMimeData</code> 对象使用媒体类型（MIME type）来描述数据的性质和格式，既可以携带常规的文本和图像数据，也可以携带二进制数据，因此，<code>QString</code> 对象、<code>QPoint</code> 对象和 <code>QPixmap</code> 对象等数据结构在用 <code>QDataStream</code> 对象序列化成二进制数据后都可以通过拖放机制进行传输。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QPixmap pixmap = label-&gt;<span class="built_in">pixmap</span>(Qt::ReturnByValue);</span><br><span class="line">QPoint pixmapPos = event-&gt;<span class="built_in">pos</span>() - label-&gt;<span class="built_in">pos</span>();</span><br><span class="line"></span><br><span class="line">QByteArray itemData;</span><br><span class="line"><span class="function">QDataStream <span class="title">dataStream</span><span class="params">(&amp;itemData, QIODevice::WriteOnly)</span></span>;</span><br><span class="line">dataStream &lt;&lt; pixmap &lt;&lt; pixmapPos;</span><br><span class="line"></span><br><span class="line">QMimeData* mimeData = <span class="keyword">new</span> QMimeData;</span><br><span class="line">mimeData-&gt;<span class="built_in">setData</span>(<span class="string">&quot;application/octet-stream&quot;</span>, itemData);</span><br></pre></td></tr></table></figure>

<p>不同的放置动作（Drop actions）用 <code>Qt::DropAction</code> 类型的枚举成员表示：</p>
<ul>
<li><code>Qt::CopyAction</code> 复制数据（按住 Ctrl）</li>
<li><code>Qt::MoveAction</code> 移动数据（按住 Shift）</li>
<li><code>Qt::LinkAction</code> 创建快捷方式</li>
<li><code>Qt::IgnoreAction</code> 取消操作（按下 ESC）</li>
</ul>
<p><code>QDrag</code> 对象 <code>exec()</code> 方法会阻塞当前事件处理器但不影响事件循环，它的第一个参数用于列出可供选择的放置动作，第二个参数用于指示默认放置动作，返回值指示实际选择的放置动作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Qt::DropAction dropAction = drag-&gt;<span class="built_in">exec</span>(Qt::CopyAction | Qt::MoveAction, </span><br><span class="line">                                       Qt::MoveAction);</span><br><span class="line"><span class="keyword">if</span> (dropAction == Qt::MoveAction) &#123;</span><br><span class="line">  <span class="keyword">delete</span> label;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="鼠标形状"><a href="#鼠标形状" class="headerlink" title="鼠标形状"></a>鼠标形状</h5><p>鼠标划过组件时的形状由组件的 <code>cursor</code> 属性决定，可以用 <code>setCursor()</code> 方法设置，用 <code>cursor()</code> 方法读取。鼠标形状用枚举成员表示。常用的鼠标形状有：</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Shape</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>Qt::ArrowCursor</code></td>
<td><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230302134533189.png"></td>
<td>标准箭头</td>
</tr>
<tr>
<td><code>Qt::CrossCursor</code></td>
<td><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230302134545256.png"></td>
<td>十字准星</td>
</tr>
<tr>
<td><code>Qt::WaitCursor</code></td>
<td><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230302134554703.png"></td>
<td>需等待</td>
</tr>
<tr>
<td><code>Qt::IBeamCursor</code></td>
<td><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230302134600087.png"></td>
<td>可输入横排文本</td>
</tr>
<tr>
<td><code>Qt::SizeVerCursor</code></td>
<td><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230302135519507.png"></td>
<td>可拉动上、下边框</td>
</tr>
<tr>
<td><code>Qt::SizeHorCursor</code></td>
<td><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230302135546858.png"></td>
<td>可拉动左、右边框</td>
</tr>
<tr>
<td><code>Qt::SizeBDiagCursor</code></td>
<td><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230302135736722.png"></td>
<td>可拉动左下角、右上角</td>
</tr>
<tr>
<td><code>Qt::SizeFDiagCursor</code></td>
<td><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230302135743683.png"></td>
<td>可拉动左上角、右下角</td>
</tr>
<tr>
<td><code>Qt::SizeAllCursor</code></td>
<td><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230302140016905.png"></td>
<td>可移动</td>
</tr>
<tr>
<td><code>Qt::BlankCursor</code></td>
<td></td>
<td>透明</td>
</tr>
<tr>
<td><code>Qt::PointingHandCursor</code></td>
<td><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230302134633516.png"></td>
<td>手指</td>
</tr>
<tr>
<td><code>Qt::ForbiddenCursor</code></td>
<td><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230302135923399.png"></td>
<td>禁止</td>
</tr>
<tr>
<td><code>Qt::OpenHandCursor</code></td>
<td><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230302140304156.png"></td>
<td>可抓取</td>
</tr>
<tr>
<td><code>Qt::ClosedHandCursor</code></td>
<td><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230302140310827.png"></td>
<td>已抓取</td>
</tr>
<tr>
<td><code>Qt::BusyCursor</code></td>
<td><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20230302140004661.png"></td>
<td>忙</td>
</tr>
</tbody></table>
<h3 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h3><h4 id="标准对话框"><a href="#标准对话框" class="headerlink" title="标准对话框"></a>标准对话框</h4><ul>
<li><p>文件对话框</p>
<ul>
<li><p><code>QString QFileDialog::getOpenFileName()</code> 打开一个文件</p>
</li>
<li><p><code>QStringList QFileDialog::getOpenFileNames()</code> 打开多个文件</p>
</li>
<li><p><code>QString QFileDialog::getSaveFileName()</code> 保存一个文件</p>
</li>
<li><p><code>QString QFileDialog::getExistingDirectory()</code> 打开现有目录</p>
</li>
</ul>
</li>
<li><p><code>QColor QColorDialog::getColor()</code> 选择颜色</p>
</li>
<li><p><code>QFont QFontDialog::getFont()</code> 选择字体</p>
</li>
<li><p>输入对话框</p>
<ul>
<li><code>QString QInputDialog::getText()</code> 输入单行文本</li>
<li><code>QString QInputDialog::getMultiLineText()</code> 输入多行文本</li>
<li><code>int QInputDialog::getInt()</code> 输入整数</li>
<li><code>double QInputDialog::getDouble()</code> 输入浮点数</li>
<li><code>QString QInputDialog::getItem()</code> 用下拉列表做出选择</li>
</ul>
</li>
<li><p>消息框</p>
<ul>
<li><code>StandardButton QMessageBox::information()</code> 提示</li>
<li><code>StandardButton QMessageBox::critical()</code> 错误</li>
<li><code>StandardButton QMessageBox::question()</code> 询问</li>
</ul>
</li>
</ul>
<p>打开文件时，可以设置过滤器。只有匹配过滤器的文件才会显示出来。不同的过滤器用两个分号 <code>;;</code> 隔开。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QString title  = <span class="string">&quot;Open File&quot;</span>;</span><br><span class="line">QString dir    = QDir::<span class="built_in">homePath</span>();</span><br><span class="line">QString filter = <span class="string">&quot;Images (*.png *.xpm *.jpg);;Text files (*.txt);;XML files (*.xml)&quot;</span>;</span><br><span class="line">QString path = QFileDialog::<span class="built_in">getOpenFileName</span>(<span class="keyword">this</span>, title, dir, filter);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; path;</span><br></pre></td></tr></table></figure>

<p>输入文本时，可以设置默认值，还可以设置单行文本输入框的响应模式。输入密码时，可以将响应模式设置为 <code>QLineEdit::Password</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QString title = <span class="string">&quot;Input&quot;</span>;</span><br><span class="line">QString label = <span class="string">&quot;User name:&quot;</span>;</span><br><span class="line">QLineEdit::EchoMode echoMode = QLineEdit::Normal;</span><br><span class="line">QString defaultUsername = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"><span class="type">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">QString username = QInputDialog::<span class="built_in">getText</span>(<span class="keyword">this</span>, title, label,</span><br><span class="line">                                         echoMode, defaultUsername, &amp;ok);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; username; <span class="comment">// &quot;John&quot;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20220923165757806.png" alt="image-20220923165757806"></p>
<p>输入数字时，可以设置默认值、最小值、最大值和步进量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QString title = <span class="string">&quot;Input&quot;</span>;</span><br><span class="line">QString label = <span class="string">&quot;User credit:&quot;</span>;</span><br><span class="line"><span class="type">int</span> defaultValue = <span class="number">5</span>, minValue = <span class="number">0</span>, maxValue = <span class="number">10</span>, stepValue = <span class="number">1</span>;</span><br><span class="line"><span class="type">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> inputValue = QInputDialog::<span class="built_in">getInt</span>(<span class="keyword">this</span>, title, label,</span><br><span class="line">                                      defaultValue, minValue, maxValue, stepValue, </span><br><span class="line">                                      &amp;ok);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; inputValue;</span><br></pre></td></tr></table></figure>

<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20220930154946185.png" alt="image-20220930154946185"></p>
<p>下拉列表的选项用 <code>QStringList</code> 对象指示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QString title = <span class="string">&quot;Input&quot;</span>;</span><br><span class="line">QString label = <span class="string">&quot;User role:&quot;</span>;</span><br><span class="line">QStringList items = &#123; <span class="string">&quot;Administrator&quot;</span>, <span class="string">&quot;User&quot;</span> &#125;;</span><br><span class="line"><span class="type">int</span> currentIndex = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> editable = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">QString item = QInputDialog::<span class="built_in">getItem</span>(<span class="keyword">this</span>, title, label, </span><br><span class="line">                                     items, currentIndex, editable, &amp;ok);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; item; <span class="comment">// &quot;Administrator&quot;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20220930112850845.png" alt="image-20220930112850845"></p>
<p>提示、警告消息框通常只有一个确定按钮。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QString title = <span class="string">&quot;Information&quot;</span>;</span><br><span class="line">QString text = <span class="string">&quot;Saved successfully!&quot;</span>;</span><br><span class="line">btn = QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, title, text);</span><br></pre></td></tr></table></figure>

<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20220930165942487.png" alt="image-20220930165942487"></p>
<p>消息框的按钮用枚举类型 <code>StandardButton</code> 表示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QString title = <span class="string">&quot;Question&quot;</span>;</span><br><span class="line">QString text = <span class="string">&quot;Are you sure?&quot;</span>;</span><br><span class="line">QMessageBox::StandardButtons btns = QMessageBox::Yes | QMessageBox::No;</span><br><span class="line">QMessageBox::StandardButton defaultBtn = QMessageBox::NoButton;</span><br><span class="line">QMessageBox::StandardButton btn;</span><br><span class="line">btn = QMessageBox::<span class="built_in">question</span>(<span class="keyword">this</span>, title, text, btns, defaultBtn);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; (btn == QMessageBox::Yes ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20220930170406934.png" alt="image-20220930170406934"></p>
<h4 id="自定义对话框"><a href="#自定义对话框" class="headerlink" title="自定义对话框"></a>自定义对话框</h4><p>创建对话框的头文件、源文件和 UI 资源文件（File - New File… - Qt - Qt Designer Form Class）。</p>
<h5 id="模态框"><a href="#模态框" class="headerlink" title="模态框"></a>模态框</h5><p>用 <code>exec()</code> 方法创建。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyDialog *myDialog = <span class="keyword">new</span> <span class="built_in">MyDialog</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ret = myDialog-&gt;<span class="built_in">exec</span>();</span><br><span class="line"><span class="keyword">if</span> (ret == QDialog::Accepted) &#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Cancel&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> myDialog;</span><br></pre></td></tr></table></figure>

<h5 id="非模态框"><a href="#非模态框" class="headerlink" title="非模态框"></a>非模态框</h5><p>用 <code>show()</code> 方法创建。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyDialog *myDialog = <span class="keyword">new</span> <span class="built_in">MyDialog</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">myDialog-&gt;<span class="built_in">setAttribute</span>(Qt::WA_DeleteOnClose); <span class="comment">// 关闭后自动析构</span></span><br><span class="line"></span><br><span class="line">Qt::WindowFlags flags = myDialog-&gt;<span class="built_in">windowFlags</span>();</span><br><span class="line">myDialog-&gt;<span class="built_in">setWindowFlags</span>(flags | Qt::WindowStaysOnTopHint); <span class="comment">// 置顶窗口</span></span><br><span class="line"></span><br><span class="line">myDialog-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>要自定义非模态框关闭时的动作，可以重写对话框的 <code>close</code> 事件处理程序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDialog::closeEvent</span><span class="params">(QCloseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;closed&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="信号和槽"><a href="#信号和槽" class="headerlink" title="信号和槽"></a>信号和槽</h5><p>对话框之间的通信也可以借助信号和槽进行：在一个对话框中定义信号，在另一个对话框定义信号的槽。例如，父窗口中有一个按钮，用于创建一个子对话框，创建子对话框时要禁用该按钮，关闭子对话框时再启用该按钮。</p>
<p><em>dialog.h</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">on_pushButton_clicked</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setButtonEnabled</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><em>dialog.cpp</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dialog::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 禁用按钮</span></span><br><span class="line">    ui-&gt;pushButton-&gt;<span class="built_in">setEnabled</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子对话框</span></span><br><span class="line">    MyDialog *myDialog = <span class="keyword">new</span> <span class="built_in">MyDialog</span>(<span class="keyword">this</span>);</span><br><span class="line">    myDialog-&gt;<span class="built_in">setAttribute</span>(Qt::WA_DeleteOnClose);</span><br><span class="line">    Qt::WindowFlags flags = myDialog-&gt;<span class="built_in">windowFlags</span>();</span><br><span class="line">    myDialog-&gt;<span class="built_in">setWindowFlags</span>(flags | Qt::WindowStaysOnTopHint);</span><br><span class="line">    myDialog-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关联信号和槽</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(myDialog, <span class="built_in">SIGNAL</span>(<span class="built_in">myDialogClosed</span>()),</span><br><span class="line">                     <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">setButtonEnabled</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dialog::setButtonEnabled</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 启用按钮</span></span><br><span class="line">    ui-&gt;pushButton-&gt;<span class="built_in">setEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>mydialog.h</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">closeEvent</span><span class="params">(QCloseEvent *event)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myDialogClosed</span><span class="params">()</span></span>; <span class="comment">// 表示对话框关闭的信号</span></span><br></pre></td></tr></table></figure>

<p><em>mydialog.cpp</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDialog::closeEvent</span><span class="params">(QCloseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 发送信号</span></span><br><span class="line">    <span class="function">emit <span class="title">myDialogClosed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="视图和模型"><a href="#视图和模型" class="headerlink" title="视图和模型"></a>视图和模型</h3><p>视图是一类组件，模型是数据的抽象，同一个模型可以用不同的视图呈现。例如，<code>QFileSystemModel</code> 是文件系统的模型，可以用树视图 <code>QTreeView</code> 和列表视图 <code>QListView</code> 两种组件呈现：</p>
<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20220921111040438.png" alt="image-20220921111040438"></p>
<p>在左边的 <code>QTreeView</code> 中点击一个目录时，右边的 <code>QListView</code> 将列出该目录下的所有文件和目录。</p>
<p>文件系统模型创建后，要用 <code>setRootPath()</code> 方法设置模型关联的目录。视图关联的模型都可以用 <code>setModel()</code> 方法设置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MyWidget::<span class="built_in">MyWidget</span>(QWidget *parent)</span><br><span class="line">  : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">  , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MyWidget)</span><br><span class="line">&#123;</span><br><span class="line">  ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  QFileSystemModel *fileSystemModel = <span class="keyword">new</span> QFileSystemModel;</span><br><span class="line">  fileSystemModel-&gt;<span class="built_in">setRootPath</span>(QDir::<span class="built_in">currentPath</span>());</span><br><span class="line"></span><br><span class="line">  ui-&gt;treeView-&gt;<span class="built_in">setModel</span>(fileSystemModel);</span><br><span class="line">  ui-&gt;listView-&gt;<span class="built_in">setModel</span>(fileSystemModel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问模型中的条目（Item）要通过 <code>QModelIndex</code> 对象，它是条目的索引。在 <code>QTreeView</code> 中点击一个目录时，它的 <code>clicked(QModelIndex)</code> 槽将得到被点击目录的索引，此时调用 <code>QListView</code> 的 <code>setRootIndex()</code> 方法，将其设置为列表的根目录，就可以让 <code>QListView</code> 列出该目录下的所有文件和目录。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyWidget::on_treeView_clicked</span><span class="params">(<span class="type">const</span> QModelIndex &amp;index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ui-&gt;listView-&gt;<span class="built_in">setRootIndex</span>(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="QStringListModel"><a href="#QStringListModel" class="headerlink" title="QStringListModel"></a>QStringListModel</h4><p><code>QStringListModel</code> 是字符串列表的模型，它的 <code>setStringList()</code> 和 <code>stringList()</code> 方法分别用于设置和获取模型关联的字符串列表：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MyWidget::<span class="built_in">MyWidget</span>(QWidget *parent)</span><br><span class="line">  : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">  , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MyWidget)</span><br><span class="line">&#123;</span><br><span class="line">  ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  QStringList cities = &#123; <span class="string">&quot;Beijing&quot;</span>, <span class="string">&quot;Shanghai&quot;</span>, <span class="string">&quot;Guangzhou&quot;</span>, <span class="string">&quot;Shenzhen&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">  QStringListModel *model = <span class="keyword">new</span> QStringListModel;</span><br><span class="line">  model-&gt;<span class="built_in">setStringList</span>(cities);</span><br><span class="line"></span><br><span class="line">  ui-&gt;listView-&gt;<span class="built_in">setModel</span>(model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>条目的索引由行号、列号和父级索引组成，它的 <code>row()</code> 和 <code>column()</code> 方法分别用于获取行号、列号。模型的条目总数可以用 <code>rowCount()</code> 方法获取。模型可以通过 <code>model()</code> 方法获取。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyWidget::on_listView_clicked</span><span class="params">(<span class="type">const</span> QModelIndex &amp;index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> row    = index.<span class="built_in">row</span>();</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> column = index.<span class="built_in">column</span>();</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> total  = index-&gt;<span class="built_in">model</span>()-&gt;<span class="built_in">rowCount</span>();</span><br><span class="line">  QString status = <span class="built_in">QString</span>(<span class="string">&quot;Row %1, Column %2, Total %3&quot;</span>)</span><br><span class="line">                  .<span class="built_in">arg</span>(row).<span class="built_in">arg</span>(column).<span class="built_in">arg</span>(total);</span><br><span class="line">  ui-&gt;label-&gt;<span class="built_in">setText</span>(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模型可以分成列表模型、列表模型和表格模型。对于列表模型来说，所有条目的列号都是 0；对于列表模型和表格模型来说，所有条目都有相同的父级索引。</p>
<p>条目包含的数据都用 <code>QVariant</code> 对象表示，可以用 <code>setData()</code> 和 <code>Data()</code> 方法设置和获取。条目的索引都可以用模型的 <code>index()</code> 方法获取。例如，获取最后一个条目的索引，再将它的数据设置为 <code>Xiamen</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QStringListModel *model = index-&gt;<span class="built_in">model</span>();</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> total = model-&gt;<span class="built_in">rowCount</span>();</span><br><span class="line">QModelIndex lastIndex = model-&gt;<span class="built_in">index</span>(total - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; model-&gt;<span class="built_in">data</span>(lastIndex).<span class="built_in">toString</span>(); <span class="comment">// &quot;Shenzhen&quot;</span></span><br><span class="line">model-&gt;<span class="built_in">setData</span>(lastIndex, <span class="string">&quot;Xiamen&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>一个条目可以包含多项数据，不同的数据有不同的用途。设置多项数据时，要给不同的数据分配不同的角色。数据的默认角色是 <code>Qt::EditRole</code> 或 <code>Qt::DisplayRole</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model-&gt;<span class="built_in">setData</span>(lastIndex, </span><br><span class="line">               <span class="string">&quot;Located on the southern coast of the Fujian Province&quot;</span>, </span><br><span class="line">               Qt::ToolTipRole);</span><br></pre></td></tr></table></figure>

<h4 id="QStandardItemModel"><a href="#QStandardItemModel" class="headerlink" title="QStandardItemModel"></a>QStandardItemModel</h4><p><code>QStandardItemModel</code> 可以作为表格视图 <code>QTableView</code> 的模型。模型的每一个条目对应一个单元格。</p>
<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20220921173702898.png" alt="image-20220921173702898"></p>
<p>在创建模型时可以指定行数、列数。表头可以用 <code>setHorizontalHeaderLabels()</code> 方法设置。在指定位置上添加条目可以用 <code>setItem()</code> 方法。条目要用 <code>QStandardItem</code> 对象表示，条目的文本可以用 <code>setText()</code> 和 <code>text()</code> 方法设置和获取。条目对应的单元格可以包含一个复选框，复选框的状态可以用 <code>setCheckState()</code> 方法设置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">QStandardItemModel *theModel;</span><br><span class="line"></span><br><span class="line">MyWidget::<span class="built_in">MyWidget</span>(QWidget *parent)</span><br><span class="line">  : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">  , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MyWidget)</span><br><span class="line">&#123;</span><br><span class="line">  ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">  theModel = <span class="keyword">new</span> <span class="built_in">QStandardItemModel</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  theModel-&gt;<span class="built_in">setHorizontalHeaderLabels</span>(&#123; <span class="string">&quot;username&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;status&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">  QList&lt;QStringList&gt; users = &#123;</span><br><span class="line">    &#123; <span class="string">&quot;root&quot;</span>, <span class="string">&quot;secret&quot;</span>, <span class="string">&quot;enabled&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;John&quot;</span>, <span class="string">&quot;123456&quot;</span>, <span class="string">&quot;disabled&quot;</span> &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; users.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    QStringList user = users[i];</span><br><span class="line">    QStandardItem *username = <span class="keyword">new</span> QStandardItem;</span><br><span class="line">    QStandardItem *password = <span class="keyword">new</span> QStandardItem;</span><br><span class="line">    QStandardItem *status   = <span class="keyword">new</span> QStandardItem;</span><br><span class="line">    username-&gt;<span class="built_in">setText</span>(user[<span class="number">0</span>]);</span><br><span class="line">    password-&gt;<span class="built_in">setText</span>(user[<span class="number">1</span>]);</span><br><span class="line">    status-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);</span><br><span class="line">    status-&gt;<span class="built_in">setCheckState</span>(user[<span class="number">2</span>] == <span class="string">&quot;enabled&quot;</span> ? Qt::Checked : Qt::Unchecked);</span><br><span class="line">    theModel-&gt;<span class="built_in">setItem</span>(i, <span class="number">0</span>, username);</span><br><span class="line">    theModel-&gt;<span class="built_in">setItem</span>(i, <span class="number">1</span>, password);</span><br><span class="line">    theModel-&gt;<span class="built_in">setItem</span>(i, <span class="number">2</span>, status);</span><br><span class="line">  &#125;</span><br><span class="line">  ui-&gt;tableView-&gt;<span class="built_in">setModel</span>(theModel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>条目的文本实际上就是角色为 <code>Qt::DisplayRole</code> 或 <code>Qt::EditRole</code> 的数据，因此下面两条语句等价：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">username-&gt;<span class="built_in">setText</span>(user[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">username-&gt;<span class="built_in">setData</span>(user[<span class="number">0</span>], Qt::EditRole);</span><br></pre></td></tr></table></figure>

<h4 id="QItemSelectionModel"><a href="#QItemSelectionModel" class="headerlink" title="QItemSelectionModel"></a>QItemSelectionModel</h4><p><code>QItemSelectionModel</code> 是选择模型，用于跟踪在视图中被选中的条目。创建选择模型时要用数据模型作为参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">QStandardItemModel *theModel;</span><br><span class="line">QItemSelectionModel *theSelectionModel;</span><br><span class="line"></span><br><span class="line">MyWidget::<span class="built_in">MyWidget</span>(QWidget *parent)</span><br><span class="line">  : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">  , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MyWidget)</span><br><span class="line">&#123;</span><br><span class="line">  ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  theModel = <span class="keyword">new</span> <span class="built_in">QStandardItemModel</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  theSelectionModel = <span class="keyword">new</span> <span class="built_in">QItemSelectionModel</span>(theModel);</span><br><span class="line"></span><br><span class="line">  ui-&gt;tableView-&gt;<span class="built_in">setModel</span>(theModel);</span><br><span class="line">  ui-&gt;tableView-&gt;<span class="built_in">setSelectionModel</span>(theSelectionModel);</span><br><span class="line"></span><br><span class="line">  QObject::<span class="built_in">connect</span>(theSelectionModel, <span class="built_in">SIGNAL</span>(<span class="built_in">currentChanged</span>(QModelIndex,QModelIndex)),</span><br><span class="line">                   <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">on_currentChanged</span>(QModelIndex,QModelIndex)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户在视图中点击不同的条目时，选择模型会发送 <code>on_currentChanged()</code> 信号，两个参数分别当前被点击的条目和上一次被点击的条目的索引。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyWidget::on_currentChanged</span><span class="params">(<span class="type">const</span> QModelIndex &amp;current, </span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> QModelIndex &amp;previous)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (current.<span class="built_in">isValid</span>()) &#123;</span><br><span class="line">    QString status = <span class="built_in">QString</span>(<span class="string">&quot;Row %1, Column %2&quot;</span>)</span><br><span class="line">                    .<span class="built_in">arg</span>(current.<span class="built_in">row</span>()).<span class="built_in">arg</span>(current.<span class="built_in">column</span>());</span><br><span class="line">    ui-&gt;label-&gt;<span class="built_in">setText</span>(status);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有选中条目的索引可以用选择模型的 <code>selectedIndexes()</code> 方法获取。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!theSelectionModel-&gt;<span class="built_in">hasSelection</span>()) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">QModelIndexList indexes = theSelectionModel-&gt;<span class="built_in">selectedIndexes</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; indexes.<span class="built_in">count</span>(); i++) &#123;</span><br><span class="line">  QStandardItem *item = theModel-&gt;<span class="built_in">itemFromIndex</span>(indexes[i]);</span><br><span class="line">  <span class="built_in">qDebug</span>() &lt;&lt; item-&gt;<span class="built_in">text</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义代理类"><a href="#自定义代理类" class="headerlink" title="自定义代理类"></a>自定义代理类</h4><p>代理类让用户可以在视图中编辑条目。</p>
<p><img data-src="/2022/07/26/2022-07-26-qt-tutorial/image-20220923151853391.png" alt="image-20220923151853391"></p>
<p>用户在视图中双击某个条目时，需要创建合适的控件用于编辑条目，此时会调用代理类的下列三个方法：</p>
<ul>
<li><code>createEditor()</code> 创建合适的控件作为编辑器</li>
<li><code>updateEditorGeometry()</code> 将编辑器的尺寸调整为合适的大小</li>
<li><code>setEditorData()</code> 用条目的数据设置编辑器的内容</li>
</ul>
<p>用户结束编辑时，需要将编辑器的内容同步到模型中，此时会调用代理类的 <code>setModelData()</code> 方法。</p>
<p>默认的代理类使用单行文本框作为编辑器。如果要使用其他控件，就需要自定义代理类。自定义代理类通常继承 <code>QStyledItemDelegate</code> 类：</p>
<p><em>.h</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStyledItemDelegate&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDelegate</span> : <span class="keyword">public</span> QStyledItemDelegate</span><br><span class="line">&#123;</span><br><span class="line">  Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MyDelegate</span>(QObject *parent = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> QWidget *<span class="title">createEditor</span><span class="params">(QWidget *parent,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">const</span> QStyleOptionViewItem &amp;option,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setEditorData</span><span class="params">(QWidget *editor,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setModelData</span><span class="params">(QWidget *editor,</span></span></span><br><span class="line"><span class="params"><span class="function">                            QAbstractItemModel *model,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">updateEditorGeometry</span><span class="params">(QWidget *editor,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">const</span> QStyleOptionViewItem &amp;option,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em>.cpp</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mydelegate.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QComboBox&gt;</span></span></span><br><span class="line"></span><br><span class="line">MyDelegate::<span class="built_in">MyDelegate</span>(QObject *parent)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QWidget *<span class="title">MyDelegate::createEditor</span><span class="params">(QWidget *parent,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">const</span> QStyleOptionViewItem &amp;option,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  QComboBox *comboBox = <span class="keyword">new</span> QComboBox;</span><br><span class="line">  comboBox-&gt;<span class="built_in">setParent</span>(parent);</span><br><span class="line">  comboBox-&gt;<span class="built_in">setFrame</span>(<span class="literal">false</span>);</span><br><span class="line">  comboBox-&gt;<span class="built_in">addItem</span>(<span class="string">&quot;enabled&quot;</span>);</span><br><span class="line">  comboBox-&gt;<span class="built_in">addItem</span>(<span class="string">&quot;disabled&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> comboBox;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDelegate::setEditorData</span><span class="params">(QWidget *editor,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  QComboBox *comboBox = <span class="built_in">static_cast</span>&lt;QComboBox *&gt;(editor);</span><br><span class="line">  comboBox-&gt;<span class="built_in">setCurrentText</span>(index.<span class="built_in">data</span>().<span class="built_in">toString</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDelegate::setModelData</span><span class="params">(QWidget *editor,</span></span></span><br><span class="line"><span class="params"><span class="function">                              QAbstractItemModel *model,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  QComboBox *comboBox = <span class="built_in">static_cast</span>&lt;QComboBox *&gt;(editor);</span><br><span class="line">  model-&gt;<span class="built_in">setData</span>(index, comboBox-&gt;<span class="built_in">currentText</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDelegate::updateEditorGeometry</span><span class="params">(QWidget *editor,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="type">const</span> QStyleOptionViewItem &amp;option,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  editor-&gt;<span class="built_in">setGeometry</span>(option.rect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要让视图使用自定义的代理类，可以用 <code>setItemDelegateForColumn()</code> 方法设置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ui-&gt;tableView-&gt;<span class="built_in">setItemDelegateForColumn</span>(<span class="number">2</span>, <span class="keyword">new</span> MyDelegate);</span><br></pre></td></tr></table></figure>

<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="创建、启动和结束线程"><a href="#创建、启动和结束线程" class="headerlink" title="创建、启动和结束线程"></a>创建、启动和结束线程</h4><p>线程要用线程类表示。线程类要继承 <code>QThread</code> 类并重写 <code>void run()</code> 方法。线程要完成的任务就在 <code>run()</code> 方法里实现。<code>run()</code> 方法返回前需要调用 <code>exit()</code> 方法。调用 <code>exit()</code> 方法时，可以提供一个退出码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTimer</span>: <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">  Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MyTimer</span>(<span class="type">int</span> msec);</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> Q_DECL_OVERRIDE</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">bool</span> isRunning_;</span><br><span class="line">  <span class="type">int</span> interval_;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">timeout</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyTimer::<span class="built_in">MyTimer</span>(<span class="type">int</span> msec)</span><br><span class="line">&#123;</span><br><span class="line">  interval_ = msec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyTimer::stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  isRunning_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyTimer::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;pid :&quot;</span> &lt;&lt; QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">  isRunning_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (isRunning_) &#123;</span><br><span class="line">    <span class="built_in">msleep</span>(interval_);</span><br><span class="line">    <span class="function">emit <span class="title">timeout</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sleep()</code>、<code>msleep()</code> 和 <code>usleep()</code> 都是 <code>QThread</code> 类的静态方法，它们可以让当前线程休眠一段时间。</p>
<p>启动线程的方法是调用 <code>start()</code> 方法。<code>start()</code> 方法会调用 <code>run()</code> 方法。<code>run()</code> 方法返回时，线程结束。父线程可以调用 <code>isRunning()</code> 或 <code>isFinished()</code> 方法检查子线程的状态，调用 <code>terminate()</code> 方法强制结束子线程。<code>terminate()</code> 方法会立即打断 <code>run()</code> 方法。无论子线程是因为 <code>run()</code> 方法返回而结束，还是因为父线程调用了 <code>terminate()</code> 方法而结束，父线程都要在希望子线程结束的时候调用 <code>wait()</code> 方法等待子线程结束。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MyTimer *myTimer;</span><br><span class="line"></span><br><span class="line">myTimer = <span class="keyword">new</span> <span class="built_in">MyTimer</span>(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;ppid :&quot;</span> &lt;&lt; QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line"><span class="keyword">if</span> (myTimer-&gt;<span class="built_in">isRunning</span>()) &#123;</span><br><span class="line">  myTimer-&gt;<span class="built_in">stop</span>(); <span class="comment">// myTimer-&gt;terminate();</span></span><br><span class="line">  myTimer-&gt;<span class="built_in">wait</span>();</span><br><span class="line">  <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;finished&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  myTimer-&gt;<span class="built_in">start</span>();</span><br><span class="line">  <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;started&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程启动时会发送 <code>started()</code> 信号；结束时会发送 <code>finished()</code> 信号。</p>
<h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><h5 id="互斥锁-QMutex"><a href="#互斥锁-QMutex" class="headerlink" title="互斥锁 QMutex"></a>互斥锁 QMutex</h5><p>当两个线程在读写同一个变量时，相互打断有可能导致错误的结果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyElapsedTimer</span>: <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">  Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MyElapsedTimer</span>();</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">elapsed</span><span class="params">(<span class="type">int</span> &amp;hour, <span class="type">int</span> &amp;minute, <span class="type">int</span> &amp;second)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> Q_DECL_OVERRIDE</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> hour_;</span><br><span class="line">  <span class="type">int</span> minute_;</span><br><span class="line">  <span class="type">int</span> second_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyElapsedTimer::<span class="built_in">MyElapsedTimer</span>()</span><br><span class="line">&#123;</span><br><span class="line">  hour_ = minute_ = second_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyElapsedTimer::elapsed</span><span class="params">(<span class="type">int</span> &amp;hour, <span class="type">int</span> &amp;minute, <span class="type">int</span> &amp;second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  hour = hour_;</span><br><span class="line">  minute = minute_;</span><br><span class="line">  second = second_;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyElapsedTimer::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">msleep</span>(<span class="number">1000</span>);</span><br><span class="line">    second_++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (second_ &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">      second_ = <span class="number">0</span>;</span><br><span class="line">      minute_++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (minute_ &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">        minute_ = <span class="number">0</span>;</span><br><span class="line">        hour_++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hour_ &gt;= <span class="number">24</span>) &#123;</span><br><span class="line">          hour_ = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当父线程调用 <code>elapsed()</code> 方法读取变量时，子线程的 <code>run()</code> 方法有可能正在更新这些变量，此时父线程就有可能得到 <code>hour</code> 为 <code>24</code>、<code>minute</code> 为 <code>60</code> 或 <code>second</code> 为 <code>60</code> 的错误结果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myElapsedTimer-&gt;<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> hour, minute, second;</span><br><span class="line">myElapsedTimer-&gt;<span class="built_in">elapsed</span>(hour, minute, second);</span><br><span class="line"><span class="built_in">qDebug</span>(<span class="string">&quot;%02d:%02d:%02d&quot;</span>, hour, minute, second);</span><br></pre></td></tr></table></figure>

<p>如果两段代码不能相互打断，就需要用一个 <code>QMutex</code> 对象来管理它们：在它们的开头调用 <code>lock()</code> 或 <code>tryLock()</code> 方法；在它们的结尾调用 <code>unlock()</code> 方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyElapsedTimer::elapsed</span><span class="params">(<span class="type">int</span> &amp;hour, <span class="type">int</span> &amp;minute, <span class="type">int</span> &amp;second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mutex.<span class="built_in">tryLock</span>()) &#123;</span><br><span class="line">    hour = hour_;</span><br><span class="line">    minute = minute_;</span><br><span class="line">    second = second_;</span><br><span class="line">    mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyElapsedTimer::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">msleep</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    mutex.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mutex.<span class="built_in">unlock</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="QMutexLocker"><a href="#QMutexLocker" class="headerlink" title="QMutexLocker"></a>QMutexLocker</h6><p><code>QMutex</code> 对象的 <code>lock()</code> 和 <code>unlock()</code> 方法必须配对使用。<code>QMutexLocker</code> 类用于简化 <code>QMutex</code> 类的用法，它的构造函数会调用给定 <code>QMutex</code> 对象的 <code>lock()</code> 方法，析构函数会调用 <code>unlock()</code> 方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyElapsedTimer::elapsed</span><span class="params">(<span class="type">int</span> &amp;hour, <span class="type">int</span> &amp;minute, <span class="type">int</span> &amp;second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">QMutexLocker <span class="title">mutexLocker</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">  hour = hour_;</span><br><span class="line">  minute = minute_;</span><br><span class="line">  second = second_;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyElapsedTimer::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">msleep</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">QMutexLocker <span class="title">mutexLocker</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="读写锁-QReadWriteLock"><a href="#读写锁-QReadWriteLock" class="headerlink" title="读写锁 QReadWriteLock"></a>读写锁 QReadWriteLock</h5><p>如果两个线程都只是单纯地读取变量而不更改变量，就无需顾虑它们相互打断的情况。要区分这种情况，可以用 <code>QReadWriteLock</code> 类代替 <code>QMutex</code> 类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyElapsedTimer::elapsed</span><span class="params">(<span class="type">int</span> &amp;hour, <span class="type">int</span> &amp;minute, <span class="type">int</span> &amp;second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (readWriteLock.<span class="built_in">tryLockForRead</span>()) &#123;</span><br><span class="line">    hour = hour_;</span><br><span class="line">    minute = minute_;</span><br><span class="line">    second = second_;</span><br><span class="line">    readWriteLock.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyElapsedTimer::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">msleep</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    readWriteLock.<span class="built_in">lockForWrite</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    readWriteLock.<span class="built_in">unlock</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="QReadLocker-amp-QWriteLocker"><a href="#QReadLocker-amp-QWriteLocker" class="headerlink" title="QReadLocker &amp; QWriteLocker"></a>QReadLocker &amp; QWriteLocker</h6><p>就像 <code>QMutex</code> 类的用法可以用 <code>QMutexLocker</code> 类简化一样，<code>QReadWriteLock</code> 类的用法可以用 <code>QReadLocker</code> 和 <code>QWriteLocker</code> 类简化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyElapsedTimer::elapsed</span><span class="params">(<span class="type">int</span> &amp;hour, <span class="type">int</span> &amp;minute, <span class="type">int</span> &amp;second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">QReadLocker <span class="title">readLocker</span><span class="params">(&amp;readWriteLock)</span></span>;</span><br><span class="line">  hour = hour_;</span><br><span class="line">  minute = minute_;</span><br><span class="line">  second = second_;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyElapsedTimer::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">msleep</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">QWriteLocker <span class="title">writeLocker</span><span class="params">(&amp;readWriteLock)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="QWaitCondition"><a href="#QWaitCondition" class="headerlink" title="QWaitCondition"></a>QWaitCondition</h5><p><code>QWaitCondition</code> 类用于保证不同线程负责的任务的执行顺序：调用 <code>wait()</code> 方法的线程会被阻塞，直到另一个线程调用 <code>wakeAll()</code> 或 <code>wakeOne()</code> 方法。为了确保 <code>wait()</code> 方法在 <code>wakeAll()</code> 方法之前被调用，<code>QWaitCondition</code> 类必须结合 <code>QMutex</code> 类使用。在调用 <code>wait()</code> 方法时，需要提供一个已经上锁的 <code>QMutex</code> 对象。<code>wait()</code> 方法被调用时会给它解锁，在返回时再给它重新上锁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">QMutex mutex;</span><br><span class="line">QWaitCondition condition;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyThread::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mutex.<span class="built_in">lock</span>();</span><br><span class="line">  <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;step 2&quot;</span>;</span><br><span class="line">  condition.<span class="built_in">wakeAll</span>();</span><br><span class="line">  mutex.<span class="built_in">unlock</span>();</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mutex.<span class="built_in">lock</span>();</span><br><span class="line">  myThread.<span class="built_in">start</span>();</span><br><span class="line">  QThread::<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;step 1&quot;</span>;</span><br><span class="line">  condition.<span class="built_in">wait</span>(&amp;mutex);</span><br><span class="line">  <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;step 3&quot;</span>;</span><br><span class="line">  mutex.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="信号量-QSemaphore"><a href="#信号量-QSemaphore" class="headerlink" title="信号量 QSemaphore"></a>信号量 QSemaphore</h5><p><code>QSemaphore</code> 类的作用与 <code>QMutex</code> 类相同。但是 <code>QMuter</code> 类只能管理一个资源，而 <code>QSemaphore</code> 类可以管理一定数量的资源。资源总数在创建 <code>QSemaphore</code> 对象时就需要确定。资源可以用 <code>acquire()</code> 和 <code>release()</code> 方法批量占用和释放。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">QSemaphore <span class="title">freeBytes</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">freeBytes.<span class="built_in">acquire</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; freeBytes.<span class="built_in">available</span>(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>如果没有足够数量的资源可以占用，调用 <code>acquire()</code> 方法的线程就会进入阻塞状态，直到有足够数量的资源被释放出来。</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>totravel
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/" title="Qt 5 入门指南和参考手册">https://totravel.github.io/2022/07/26/2022-07-26-qt-tutorial/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-ND</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a>
              <a href="/tags/Qt/" rel="tag"><i class="fa fa-tag"></i> Qt</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/07/11/2022-07-11-modern-cmake-guide/" rel="prev" title="现代 CMake 指南">
                  <i class="fa fa-chevron-left"></i> 现代 CMake 指南
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/08/19/2022-08-19-charset/" rel="next" title="字符集、字符编码和编码转换">
                  字符集、字符编码和编码转换 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">totravel</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.1/jquery.min.js" integrity="sha256-o88AwQnZB+VDvE9tvIXrMQaPlFFSUTR+nldQm1LuPXQ=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  


  <script src="/js/third-party/fancybox.js"></script>


  





</body>
</html>
